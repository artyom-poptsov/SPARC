\documentclass[a4paper,twoside]{book}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[absolute,overlay,showboxes]{textpos}

\urlstyle{same}
\usepackage[printonlyused,withpage]{acronym}

\graphicspath{ {images/} }

%% This procedure adds the "Example" block to the text.
\newcommand{\example}[1]{
  \fbox {
    \textbf{Пример:}
    \parbox{\linewidth}{#1}
  }
}

\newcommand{\note}[1]{
  \fbox {
    \textbf{Примечание:}
    \parbox{\linewidth}{#1}
  }
}

\newcommand{\hotkey}[1]{
  \texttt{#1}
}

\title{Записки техноволшебника}
\author{Артём ``avp'' Попцов}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Начало пути}

\section{Для кого предназначена данная книга?}
Вы открыли первую страницу книги и задаётесь вопросом -- а стоит ли эта книга
времени, которое будет потрачено на её чтение? К сожалению, вынуждены вас
огорчить -- данную книгу нужно будет не только читать, но и прилагать некоторые
усилия для освоения материала. Как будто собираясь в поход, вы должны
подготовиться и взять с собой необходимые вещи. Но не торопитесь закрывать на
этом книгу -- мы можем предложить вам то, ради чего вы возможно захотите пройти
весь путь до конца. Во-первых, где-то на горизонте, в манящей доступности,
располагаются диковинные земли, до которых вы можете дойти и изучить их, узнав
много нового. Во-вторых, поход будет хоть и не самым простым, но зато подарит
вам массу впечатлений, опыта -- и быть может даже будущую профессию.

\section{Авторы}
В разработке данной книги принимали участие следующие люди:
\begin{itemize}
\item Денис Киселёв -- вклад в разработку отдельных глав книги; вычитка текста,
  участие в разработке и тестирование примеров, приведённых в книге.
\item Сергей Ермейкин -- вычитка текста, исправление ошибок.
\item Илья Маштаков – вычитка и доработка текста.
\end{itemize}

\section{Лицензия}
Copyright © 2016-2022 Артём ``avp'' Попцов.

Права на копирование сторонних изображений и материалов, использованных в данной
работе, принадлежат их владельцам.

Данная работа распространяется на условиях лицензии
«Attribution-NonCommercial-ShareAlike» («Атрибуция — Некоммерческое
использование — На тех же условиях») 4.0 Всемирная (CC BY-NC-SA 4.0):
\url{https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ru}

\chapter{Знакомство с набором разработки Arduino}

\section{Введение}
По нашему мнению, программирование является двоякой дисциплиной: с одной
стороны, это – один из видов творчества, позволяющий человеку создать что-то
необычное, новое и, возможно, полезное для общества; с другой стороны, это –
инструмент, позволяющий решать практические, прикладные задачи. Как кисти и
краски художника, или инструменты музыканта, инструменты программиста имеют
большое разнообразие в видах и применениях. Чтобы освоить их в полной мере
требуются годы. Тем не менее, долгий путь начинается с первого шага.

Данная книга позволяет людям, желающим освоить программирование, сделать первый
шаг на пути в профессии программиста. Вам предлагается изучить основы
программирования на C, разрабатывая приложения для платформы Arduino.

\section{Работа с макетной платой}

Макетная плата позволяет собирать схемы (подключать электронику) без применения
пайки --- это упрощает прототипирование и ускоряет процесс разработки проектов.
Компоненты просто вставляются в слоты на макетной плате для соединения.

\begin{itemize}
\item Черный провод подключен к arduino и идёт на вывод GND (минус)
\item Синий провод подключен к arduino и идёт на вывод 5V (плюс)
\end{itemize}

\emph{Примечание:} обратите внимание, что светодиоды (и некоторые другие
элементы) подключаются к платформе Arduino через резистор -- это необходимо для
обеспечения бесперебойной работы схемы и предупреждения всяческих поломок и
ухудшения работы как отдельных деталей, так и схемы в целом.

\section{Подключение Arduino к компьютеру}
Чтобы подключить ардуино к компьютеру вам потребуется сама платформа Arduino (в
нашем случае мы используем Arduino Mega 2560) и кабель стандарта USB-В.

Соедините Arduino с компьютером через USB-кабель. Вы увидите, как на плате
загорится светодиод «ON».

Теперь необходимо настроить Arduino IDE для работы с подключенной Arduino, для
этого нужно войти в панель “Инструменты” затем “Плата” -- в этом меню выберите
6Arduino с которой вы сейчас работаете, затем в подменю “Порт” выберите порт, к
которому подключена Arduino.

\section{Знакомство со средой разработки Arduino}
Среда разработки Arduino (Arduino IDE) состоит из встроенного текстового
редактора программного кода, области сообщений, окна вывода текста (консоли),
панели инструментов с кнопками часто используемых команд и нескольких меню. Для
загрузки программ и связи с компьютером среда разработки подключается к
аппаратной части Arduino.

Скачать среду разработки можно с официального сайта Arduino:
\url{https://www.arduino.cc/en/Main/Software}.

Перед скачиванием будет предложено пожертвовать денег проекту Arduino для
дальнейшего развития, но этот шаг необязателен и может быть выполнен на ваше
усмотрение.

Ниже приведено описание кнопок в интерфейсе Arduino IDE.

\begin{tabular}{p{4cm}|p{6cm}}
  Название & Описание \\
  \hline \hline
  Verify/Compile (Проверка) & Проверка программного кода. \\
  \hline
  Upload (Загрузка) & Компилирует программный код.\\
  \hline
  New (Создать) & Создание нового скетча.\\
  \hline
  Open (Открыть) & Открыть скетч.\\
  \hline
  Save (Сохранить) & Сохранить скетч.\\
  \hline
  Serial Monitor (Монитор порта) & Открыть монитор порта.\\
\end{tabular}

\section{Основы работы с мультиметром}
Мультиметр -- незаменимый прибор, с его помощью можно узнать сопротивление
резистора, измерить напряжение, произвести проверку на проводимость
(``прозвонка''), узнать цвет и полярность светодиода и многое другое.

Далее приведена таблица на которой отражены основные символы, встречающиеся на
корпусе прибора, необходимые для работы с мультиметром:


\section{Структура программы на Arduino}

Программа для Arduino обычно состоит из двух основных частей, также называемых
функциями: "setup" и "loop". Пример программы, которая мигает одним светодиодом:
\begin{verbatim}
void setup() {
    pinMode(2, OUTPUT);
}

void loop() {
    digitalWrite(2, HIGH);
    delay(500);
    digitalWrite(2, LOW);
    delay(500);
}
\end{verbatim}

Функция \texttt{setup} производит инициализацию микроконтроллера при его
включении. В неё следует помещать все команды, которые должны выполняться
единожды на старте системы.

Цифровой порт (или, по-другому, пин) Arduino может находиться в двух состояниях.
В режиме входа пин считывает напряжение, а в режиме выхода – позволяет выдавать
на пине такое же напряжение.

Рассмотрим приведённый выше пример. В \texttt{setup} выполняется функция
\texttt{pinMode}, которая позволяет настроить режим работы указанного пина как
вход или выход:

\begin{verbatim}
  pinMode(pin, mode);
\end{verbatim}

где \texttt{pin} -- номер пина, \texttt{mode} -- режим работы
(\texttt{INPUT}/\texttt{OUTPUT}).

В \texttt{loop} вызываются две функции: \texttt{digitalWrite} и \texttt{delay}.

Функция
\begin{verbatim}
  digitalWrite(pin,value);
\end{verbatim}

где \texttt{pin} -– номер пина, \texttt{value} -- уровень сигнала
(\texttt{HIGH}/\texttt{LOW}), подаёт на пин высокое или низкое напряжение.

Функция
\begin{verbatim}
delay(value);
\end{verbatim}

где \texttt{value} -- количество миллисекунд, останавливает выполнение программы
на указанное время.

\subsection{Задачи}
\begin{itemize}
\item Соберите на макетной плате ``бегущий огонь'': светодиоды должны поочерёдно
  включаться и выключаться, один за другим.
\item Модифицируйте ``бегущий огонь'' так, чтобы он бежал сначала в одну
  сторону, затем в другую.
\end{itemize}

\section{Переменные и память}

\emph{Переменная} -- это ключевое понятие в программировании. Любая программа
работает с данными. Возьмём для наглядности некую программу- калькулятор,
умеющую складывать два числа. Чтобы микроконтроллер мог работать с этими числами
их нужно где-то хранить. Где? В оперативной памяти. Все данные, которые
используются микроконтроллером во время работы, хранятся именно там. Для работы
нашего калькулятора нужно загрузить в ячейки оперативной памяти два
числа-операнда, которые нужно сложить, например 15 и 3:

\begin{tabular}{p{4cm}|p{6cm}}
  Адрес ячейки & Значение ячейки \\
  \hline \hline
  0000 & 15 \\
  \hline
  0001 & 3 \\
  \hline
  0003 & 0 \\
  ... & ... \\
\end{tabular}

\emph{Переменная} -- это ячейка данных в оперативной памяти (ОЗУ). Объявить
переменную –- значит сказать компьютеру выделить какую-нибудь ячейку памяти для
наших нужд.

Переменная в языке С++ имеет определённый тип и уникальное имя. Объявление
(\emph{инициализация}) переменной выглядит следующим образом:

\begin{verbatim}
тип имя = значение;
\end{verbatim}

То есть, чтобы загрузить в оперативную память два числа 15 и 3, мы должны написать
следующее:

\begin{verbatim}
int a = 15;
int b = 3;
\end{verbatim}

Слово \texttt{int} это тип переменной, означает, что эта переменная является
числом.

Также следует объявить переменную для хранения результата сложения:

Дальше -- складываем значения двух переменных \texttt{a} и \texttt{b}:

\begin{verbatim}
int result = a + b;
\end{verbatim}

Здесь мы присвоили переменной \texttt{result} результат операции сложения двух
переменных.

\emph{ВАЖНО!} Имя переменной может состоять только из букв, цифр и нижнего
подчёркивания, причём имя не может начинаться с цифры.

Вернёмся к нашим светодиодам. Объявим новую переменную:

\begin{verbatim}
int k = 500;
\end{verbatim}

Что мы можем с ней сделать? Например, в программе мигания светодиодом заменим ею
значение задержки в функции \texttt{delay}. Вообще, переменным следует давать
осмысленные имена, в нашем случае пусть это будет не \texttt{k}, а
\texttt{delay\_val}:

\begin{verbatim}
void loop() {
    int delay_val = 500;
    digitalWrite(2, HIGH);
    delay(delay_val);
    digitalWrite(2, LOW);
    delay(delay_val);
}
\end{verbatim}

Таким образом, мы сможем поменять значения всех задержек одной заменой значения
\texttt{delay\_val}:

\begin{verbatim}
void loop() {
    int delayVal = 600;
    // ...
}
\end{verbatim}

Можно, например, увеличивать \texttt{delay\_val} на 100 при каждом выполнении
\texttt{loop}:

\begin{verbatim}
void loop() {
    int delay_val = 100;
    12digitalWrite(2, HIGH);
    delay(delay_val);
    digitalWrite(2, LOW);
    delay(delay_val);
    delay_val = delay_val + 100;
}
\end{verbatim}

Кстати, строчку \texttt{delay\_val = delay\_val + 100} можно заменить на
\texttt{delay\_val += 100} и результат будет тем же, но запись короче.

\texttt{+=} -- оператор присваивания, совмещённый со сложением.

Существуют также другие операторы подобного рода -- например, ``-=''
(читается ``минус-равно'') Если мы запустим этот код, то увидим, что задержка
переключения светодиодов… не меняется. Почему? При каждом выполнении loop()
каждый раз объявляется новая переменная \texttt{delay\_val} со значением 100 и
потому задержка остаётся той же. Сейчас delayVal объявлена как локальная
переменная внутри \texttt{loop}, следует объявить её за пределами функции, чтобы
она стала глобальной:

\begin{verbatim}
int delay_val = 100;

void loop() {
  digitalWrite(2, HIGH);
  delay(delay_val);
  digitalWrite(2, LOW);
  delay(delay_val);

  delay_val += 100;
}
\end{verbatim}

Теперь всё будет работать. Но так задержка будет бесконтрольно расти. Решением
будет сделать так, чтобы \texttt{delay\_val} увеличивалась до какого-то
порогового значения, например, до 600. Для этого нужно добавить условие
(\texttt{if}):

\begin{verbatim}
int delay_val = 100;

void loop() {
    digitalWrite(2, HIGH);
    delay(delay_val);
    digitalWrite(2, LOW);
    delay(delay_val);

    if (delay_val < 600){
      delay_val += 100;
    }
}
\end{verbatim}

Об условиях и других управляющих конструкциях -- в следующей главе.

\chapter{Управляющие конструкции языка C++}

\section{Условия}

Иногда во время выполнения программы следует принять решение о том, что делать
дальше. Для того, чтобы компьютер мог сделать правильный выбор, по какому пути
пойти, нам, как программистам, следует описать условия в коде программы: если
условие выполняется, делаем одно, иначе -- делаем другое.

Условия в программах описываются при помощи специальных управляющих конструкций.
В языке C++ у нас есть две основные конструкции. Первая из них -- оператор
\texttt{if} (буквально в переводе с английского ``если''). Пример использования:

\begin{verbatim}
if (a > 10) {
    // действие, выполняемое, если значение
    // переменной 'a' больше 10.
}
\end{verbatim}

Если нужно проверить равно ли значение переменной чему-либо, используют оператор
сравнения ``=='':

\begin{verbatim}
if (a == 10) {
    // действие, выполняемое, если значение
    // переменной 'a' равно 10.
}
\end{verbatim}

Не путайте оператор сравнения ``=='' с оператором присваивания ``='' - это важно!

Часто необходимо не только делать что-либо при выполнении условия, но и
предоставить альтернативную инструкцию (или набор инструкций), выполняемую
тогда, когда условие не выполняется. В этом случае используют конструкцию
\texttt{if ... else}:

\begin{verbatim}
if (a > 10) {
  // действие, выполняемое, если значение
  // переменной 'a' больше 10.
} else {
  // действие, выполняемое, если значение
  // переменной 'a' меньше или равно 10.
}
\end{verbatim}

Второй оператор, который нам будет встречаться, это так называемый
\emph{оператор выбора} \texttt{switch}. С ним познакомимся позже. Он удобен,
например, тогда, когда нам нужно выполнять несколько разных действий в
зависимости от значения переменной, и этих действий много.

\section{Циклы}

Простые программы, вроде ``бегущего огня'', могут быть написаны простым
копированием и вставкой алгоритма мигания светодиода (возможно, с небольшими
модификациями).

А теперь представьте, что вам требуется запрограммировать ``бегущий огонь'' на
100 светодиодов. Утомительная задача, не правда ли? Для того, чтобы не делать
тупую работу по копированию одного и того же кода много раз, программистами
придуманы специальные управляющие конструкции, называемые \emph{циклами}.

Циклы бывают разные. Основные виды циклов, которые вам будут встречаться
практически в любом языке программирования:
\begin{itemize}
\item Цикл со счётчиком (также называемый ``параметрический цикл'').
\item Цикл с предусловием.
\item Цикл с постусловием.
\end{itemize}

Каждый вид циклов имеет собственную реализацию в языке программирования, который
мы используем (C++).

\subsection{Цикл со счётчиком}

Цикл со счётчиком реализуется конструкцией \texttt{for} -- она позволяет нам
создать счётчик, задать его начальное значение, описать условие выполнения цикла
и операцию изменения счётчика:

\begin{verbatim}
//                   5.
//        1.         2.           4.
for (int pin = 0; pin < 10; pin = pin + 1) {
    // 3. (тело цикла)
}
\end{verbatim}

Выполняется эта конструкция в следующем порядке:
\begin{enumerate}
\item объявляем переменную и присваиваем ей значение 0 (шаг 1);
\item переходим к проверке, где смотрим, выполняется ли условие (шаг 2);
\item после этого, если условие 2 выполняется, мы переходим к телу цикла (шаг 3);
\item после выполнения тела цикла, мы переходим к изменению значения счётчика (шаг 4);
\item после шага 4 мы опять возвращаемся к шагу 2, если условие выполняется, то
  переходим к шагу 3 и т.д.
\end{enumerate}

\subsection{Цикл с предусловием}

Другим распространённым видом цикла является цикл с предусловием, реализуемый в
С++ конструкцией \texttt{while} -- данный вид цикла удобен в тех случаях, когда
мы не знаем точного количества раз, сколько нужно повторить тело цикла (не знаем
количество итераций.)

Общий вид цикла \texttt{while} таков:
\begin{verbatim}
int pin = 2;

while (pin < 10) {
    // тело цикла
}
\end{verbatim}

\subsection{Цикл с постусловием}

Кроме вышеперечисленных видов циклов, есть ещё цикл с постусловием, где
проверка условия выполнения цикла осуществляется после выполнения тела цикла.
Реализуется данный вид циклов конструкцией \texttt{do..while}.

Он достаточно редкоиспользуется и мы не будем на нём здесь останавливаться.

\subsection{Зачем столько видов циклов?}

Обратите внимание, что один вид цикла может быть реализован через другой, т.к.
данные управляющие конструкции взаимозаменяемы. Возникает вопрос -- зачем же
16нам нужно столько видов циклов? Всё дело в удобстве. В одних случаях удобнее
использовать один вид циклов, в других случаях -- другой.

У программистов есть специальный термин для описания подобных конструкций языка
программирования: синтаксический сахар. Синтаксический сахар -- это конструкции
языка, без которых в принципе можно обойтись при разработке программ, но с ними
всё проще ("слаще").

\subsection{Задачи}
\begin{enumerate}
\item Перепишите ``бегущий огонь'' с использованием цикла.
\item Модифицируйте алгоритм ``бегущего огня'' таким образом, чтобы светодиоды
  начинали загораться с обоих концов гирлянды и огни ``бежали'' навстречу друг
  другу.
\end{enumerate}

\chapter{Широтно-импульсная модуляция}

\section{Общее описание принципов работы}

Широтно-импульсная модуляция, или сокращённо \emph{ШИМ}, позволяет выдавать на
цифровом порту Arduino напряжение в диапазоне от 0 до 5 вольт, используя при
этом только два сигнала -- \texttt{HIGH} (логическая единица, при которой на
порт подается 5 В) и \texttt{LOW} (логический ноль, при котором на порт подается
0 В.) Меняя быстро данные значения на порту, можно добиться, например,
напряжения в 2.5 В.

\section{Длина волны}

При создании ``мигающего светодиода'' мы попеременно подавали на цифровой порт
сигналы \texttt{HIGH} и \texttt{LOW}, с указанием задержки (в миллисекундах).
Если мы посмотрим на вид сигнала на цифровом порту во времени (скажем, с помощью
осциллографа), то увидим примерно следующую картину:


Где \emph{длина периода} -- расстояние между двумя ближайшими друг к другу
точками в пространстве, в которых колебания происходят в одинаковой фазе.

Зная длину периода, можно рассчитать \emph{частоту колебаний}, и наоборот --
зная частоту, можно рассчитать длину волны.

При работе с ШИМ мы будем использовать длину периода, заданную в микросекундах
(мкс). 1 микросекунда -- это одна миллионная часть секунды. Для краткости записи
подобных маленьких величин часто используется возведение числа 10 в
отрицательную степень. Ниже приведена таблица с указанием различных долей
секунды\footnote{Для полного списка кратных и дольных единиц см. статью
\href{https://ru.wikipedia.org/wiki/\%D0\%A1\%D0\%B5\%D0\%BA\%D1\%83\%D0\%BD\%D0\%B4\%D0\%B0}{Секунда}
в Википедии.}:

\begin{tabular}{p{4cm}|p{4cm}|p{6cm}}
  Название & Величина & Пример \\
  \hline \hline
  секунда (с) & $ 1 с $ или $ 10^0 с $ & $ 500 * 10^{0} = 500 с $ \\
  \hline
  миллисекунда (мс) & $ 0.001 c $ или $ 10^{-3} c $ & $ 500 * 10^{-3} = 500 мс $ \\
  \hline
  микросекунда (мкс) & $ 0.000001 c $ или $ 10^{-6} c $ & $ 500 * 10^{-6} = 500 мкс $ \\
  \hline
  наносекунда (нс) & $ 0.000000001 c $ или $ 10^{-9} с $ & $ 500 * 10^{-9} = 500 нс $
\end{tabular}

\section{Коэффициент заполнения}

Каким образом задается напряжение из диапазона? Очень просто: путём изменения
времени подачи того или иного сигнала. Чем больше времени на порту сигнал HIGH,
тем выше напряжение. При этом, длина периода \texttt{P} остаётся фиксированной
(например, 1000 микросекунд). Таким образом для ШИМ важно процентное отношение
одного сигнала к другому, и, увеличивая время подачи одного сигнала, следует
уменьшать время подачи другого (следовательно если мы подаем сигнал
\texttt{HIGH} 60\% от отведенного времени, нужно заполнить оставшиеся 40\%
сигналом \texttt{LOW}).

Отношение периода следования сигнала к длительности импульса называется
\emph{скважностью}. В англоязычной литературе величина, обратная скважности,
называется \emph{коэффициентом заполнения} (англ. \emph{duty cycle}).

Мы будем использовать термин ``коэффициент заполнения''.

\example {
  Мы хотим получить 2.5 вольта на цифровом порту 2, имея в
  распоряжении только два значения -- 0 В и 5 В. Для этого нам потребуется
  реализовать ШИМ с коэффициентом заполнения 50\%. При длине волны в 1000
  микросекунд мы должны половину времени (500 микросекунд) заполнить
  положительным сигналом (сигнал \texttt{HIGH}) и подать его на выбранный порт, затем
  остальную часть заполним отрицательным сигналом (сигналом \texttt{LOW}).
  Если всё сделано правильно, то на 2 цифровом порту получим 2.5 вольта.
}

Для генерации нужного сигнала нам потребуется создать инструмент
(\emph{функцию}), который впоследствии мы будем использовать. Мы уже говорили о
важности написания и использования собственных функций в программе -- функции
позволяют нам создавать модульные программы, упрощают поддержку существующего
программного кода и написание нового кода.

Подумаем над тем, какой должна быть наша функция, реализующая ШИМ. Ниже приведён
знакомый нам график, отображающий сигнал на цифровом порту -- мы будем
использовать этот график, как основу для написания функции.

%% TODO: Add the graph.

В программе мы обозначим длину периода константой \texttt{P}, равной 1000 мкс.
Значения задержек, заданных переменными \texttt{d1} и \texttt{d2}, необходимо
вычислить на основе коэффициента заполнения, задаваемого параметром функции
\texttt{duty\_cycle} (который задаётся дробным значением -- к примеру, 0.5.)

Имея перед глазами этот график, нетрудно набросать словесное описание функции
(назовём функцию \texttt{pwm}, как сокращение от англ. \emph{pulse width
  modulation}.)

Начнём с того, что, скорее всего, подобная функция должна принимать три
параметра:
\begin{enumerate}
\item Номер порта (обозначаемый целым числом), на котором следует сгенерировать
  ШИМ сигнал; назовём этот параметр \texttt{pin}.
\item Коэффициент заполнения, заданный дробным числом -- к примеру, 50\% будет
  задано, как 0.5; назовём этот параметр \texttt{duty\_cycle}
\item Длина ШИМ сигнала в микросекундах; назовём этот параметр
  \texttt{signal\_length}.
\end{enumerate}

Запишем тоже самое на языке С++:

\begin{verbatim}
void pwm(int pin, float dc, long signal_length) {
  // тело функции
}
\end{verbatim}

О том, что такое \texttt{void}, будет сказано позже, пока что стоит принять как
факт, что это начало объявления функции. Наверняка появились вопросы по новым
типам переменных -- \texttt{float} и \texttt{long}. Почему нельзя использовать
привычный \texttt{int}? Дело в том, что переменная типа \texttt{int} не может
хранить дробные числа, а также имеет диапазон значений от -32 768 до 32 767. Для
хранения дробных чисел используется \texttt{float}, а для чисел, не входящих в
диапазон \texttt{int}, стоит использовать \texttt{long}, имеющий диапазон от -2
147 483 648 до 2 147 483 647. Теперь подумаем над телом функции. Первым делом
нам необходимо задать константу \texttt{P}:

\begin{verbatim}
const int P = 1000; // мкс
\end{verbatim}

Обратите внимание, что мы используем ключевое слово const для того, чтобы
пометить \texttt{WAVE\_LENGTH}, как константу -- мы всё равно не собираемся
менять это значение. Кроме того, мы указали в комментарии, что значение задано в
микросекундах (мкс), что упрощает чтение кода. В C++, да и в других языках,
константа -- это та же переменная, но её значение нельзя менять после её
объявления.

Следующим этапом будет вычисление в теле функции значений переменных \texttt{d1}
и \texttt{d2} на основе значения \texttt{duty\_cycle}, заданного при вызове
функции:

\begin{verbatim}
int d1 = P * duty_cycle;
int d2 = P - d1;
\end{verbatim}

Видно, что как только мы вычислили \texttt{d1}, вычислить \texttt{d2} не
составляет труда. Осталось только посчитать, сколько раз нужно повторить волну
длиной \texttt{P}, чтобы сгенерировать сигнал длиной \texttt{signal\_length}:

\begin{verbatim}
int count = signal_length / P;
\end{verbatim}

Теперь у нас есть всё, что нужно для генерации нужного нам сигнала. Поскольку
исходя из описания выше нам нужно будет повторять волну count раз, то для этого
удобно использовать цикл \texttt{for} (цикл со счётчиком):

\begin{verbatim}
for (int c = 0; c < count; c++) {
  digitalWrite(pin, HIGH);
  delayMicroseconds(d1);
  digitalWrite(pin, LOW);
  delayMicroseconds(d2);
}
\end{verbatim}

Готово! Осталось только задействовать функцию pwm в нашей программе.

\subsection{Задачи}

\begin{enumerate}
\item Написать программу, плавно включающую и выключающую светодиод. Собрать и
  протестировать схему. 
\item Написать программу, реализующую ``бегущий огонь'' с использованием ШИМ.
  Собрать и протестировать схему.
\item Используя потенциометр, модифицировать систему из задания №2 таким
  образом, чтобы можно было регулировать яркость ``бегущего огня''.
\item Разработать ``бегущий огонь'', где следующий светодиод начинает плавно
  разгораться одновременно с затуханием предыдущего светодиода.
\end{enumerate}

\section{Использование потенциометра}

Поставим себе задачу -- вручную регулировать скорость ``бегущего огня'' в
реальном времени. Микроконтроллер должен принимать извне некий сигнал, величину
которого мы можем регулировать каким-либо элементом управления и использовать в
качестве параметра:

\begin{verbatim}
Сигнал -> Элемент управления -> Arduino -> Параметр
\end{verbatim}

Для считывания сигнала можно использовать аналоговые порты Arduino. На плате они
подписаны как \texttt{A0}, \texttt{A1}, и т.д. Если цифровые порты рассчитаны на
цифровой сигнал, который может быть в двух состояниях - 0 В или 5 В, то
аналоговые, соответственно, рассчитаны на аналоговый, непрерывный, сигнал,
который может принимать любые значения от 0 до 5 В.

Микроконтроллер измеряет напряжение на аналоговом порту и преобразовывает
полученное значение в число от 0 до 1023, которое мы можем использовать для
своих нужд.

В качестве элемента управления может служить такой компонент как потенциометр.
Переменный резистор или потенциометр -- это резистор, сопротивление которого,
как понятно из названия, можно изменять. Используя потенциометр, мы можем влиять
на поступающее напряжение на порт, тем самым регулируя нужный нам параметр.
Подключаем крайние выводы потенциометра к питанию и земле, а центральный -- к
аналоговому порту.

В коде будем использовать функцию \texttt{analogRead}:

\begin{verbatim}
int value = analogRead(A0); // Получаем значение с аналогового порта 0
\end{verbatim}

\texttt{A0} - номер аналогового порта. Функция \texttt{analogRead} возвращает
результат вышеописанной операции -- число от 0 до 1023.

Осталась одна проблема -- нам неизвестно значение, которое получил
микроконтроллер. Для этого воспользуемся последовательным портом.

\section{Последовательный порт}

Последовательный порт в Arduino -- это тот самый USB-B, который мы подключаем
всякий раз, когда желаем включить наш микроконтроллер или загрузить в Arduino
какую-либо программу. С помощью последовательного порта можно передавать данные
с Arduino на компьютер и наоборот.

\subsection{Основы работы с Arduino через последовательный порт}

Прежде, чем начать работать с последовательным портом, нам необходимо его
настроить; делается это следующим образом: в теле функции setup мы должны
написать:

\begin{verbatim}
Serial.begin(9600);
\end{verbatim}

В этом случае мы обеспечиваем обмен данными между компьютером и Arduino с
указанной скоростью, где 9600 -- это скорость, с которой мы передаем данные на
персональный компьютер в \emph{бодах} (битах в секунду.) Обычно данный параметр
принимает одно из следующих значений: 300, 600, 1200, 2400, 4800, 9600, 14400,
19200, 28800, 38400, 57600, 115200.

\subsection{Передача данных с Arduino на компьютер}

Теперь попробуем передать данные с аналогового порта Arduino на компьютер. В
качестве примера мы просто отправим строку ``Hello, world!'' по
последовательному порту. Для начала пропишем настройку порта в функции
\texttt{setup}:

\begin{verbatim}
void setup() {
  Serial.begin(9600); // устанавливаем скорость порта
}
\end{verbatim}

А вот так в нашем случае выглядит функция \texttt{loop}:

\begin{verbatim}
void loop() {
  int value = analogRead(0); // Получаем данные с аналогового порта

  // отправляем переменную value с помощью
  // последовательного порта:
  Serial.println(value);

  delay(100); // ждём 100 мс перед следующей отправкой
}
\end{verbatim}

Результат выполнения программы можно увидеть, открыв монитор порта в Arduino
IDE. Доступ к монитору порта можно получить, нажав кнопку в виде лупы в правом
верхнем углу редактора кода:

Кроме того, открыть монитор порта можно, нажав комбинацию клавиш \hotkey{Ctrl +
  Shift + M}. Также можно использовать плоттер по последовательному соединению,
который выводит графики поступающих данных. Чтобы его открыть, нужно перейти во
вкладку ``Инструменты'' $\rightarrow$ ``Плоттер по последовательному
соединению'':

\subsection{Использование монитора порта для отладки программ}

Передачу данных с Arduino на компьютер можно использовать в множестве разных
задач. Примером одной из таких задач является простейший способ отладки программ
-- с помощью вывода информации о работе программы в Arduino на последовательный
порт. Иными словами, вместо того, чтобы пытаться самим понять, что же пошло не
так и почему что-то не работает, мы просим Arduino саму рассказывать нам, что
она делает.

\subsection{Сбор и обработка данных на стороне компьютера}

Другой задачей, решаемой с помощью функций записи данных в последовательный
порт, является сбор данных на стороне компьютера. Arduino IDE позволяет нам
визуализировать данные через специальный плоттер (доступ к которому можно
получить, выбрав в меню ``Инструменты'' пункт ``Плоттер по последовательному
соединению'', либо нажав комбинацию клавиш \hotkey{Ctrl + Shift + L}.)

\subsection{Передача данных с компьютера на Arduino}

Передавать данные с Arduino на компьютер мы уже научились. Теперь посмотрим на
передачу данных в обратном направлении. Для того чтобы передать данные с
компьютера на Arduino также необходимо выполнить настройку последовательного
порта; кроме этого, нам потребуется задействовать несколько новых функций.

\subsubsection{Чтение отдельных байт}

Функция \texttt{Serial.read} читает байт данных из поступивших на Arduino. То
есть возвращает вам некое целое число, с которым вы вольны делать что вашей душе
угодно. Каждый вызов этого метода будет возвращать вам следующий байт данных из
тех что поступили на Arduino. Если возвращать нечего, то есть вы считали все что
было, данная функция вернет -1.

\note{ Если передаются именно байты, возникает проблема: -1 это 0xFF в
  шестнадцатиричной системе, или 255 в десятичной. Такой же байт, как и все
  остальные, из-за чего невозможно. поэтому нужно сперва вызывать функцию available . }

Допустим мы отправили 1 байт данных на Arduino и использовали нижеприведенный
участок кода:

\begin{verbatim}
int incoming_byte;
void loop() {
  if (Serial.available() > 0) {
      incoming_byte = Serial.read();
  }
}
\end{verbatim}

После того, как вы считаете байт данных, он будет перемещен в вашу переменную
\texttt{incoming\_byte} а функция \texttt{Serial.available} снова будет
возвращать 0, пока не поступят новые данные.

То есть, когда вы считываете байт, показания счетчика принятых байт уменьшается
и \texttt{Serial.available} будет показывать на 1 байт меньше.

Помните, что функция \texttt{Serial.read} возвращает только 1 байт данных, если
например вы передали 4 символа каждый по 1 байту, вам потребуется 4 раза вызвать
данную функцию чтобы прочитать эти символы и самостоятельно позаботится о том
чтобы разместить их в массив символов либо воспользоваться функцией
\texttt{Serial.readBytes}.

\subsubsection{Чтение чисел}

Функция \texttt{Serial.parseInt} просматривает данные, поступившие на Arduino, и
ищет среди них набор кодов (чисел) от 48 до 57, которые соответствуют символам
чисел от 0 до 9 и преобразует все это в правильное целочисленное значение. Таким
образом если вы с монитора порта передадите "число" (на самом деле, строку)
``72'', данный метод увидит 2 последовательных байта 55 и 51, корректно
преобразует его в число 72 и вернет его как правильное целочисленное значение.
Давайте напишем маленькую эхо-программу, которая покажет принцип работы данной
функции и позволит вам узнать какому символу соответствует то или иное число.

\begin{verbatim}
int incoming_int = 0;

void setup()
{
  Serial.begin(9600);
  Serial.setTimeout(2000);
}
void loop()
{
  if (Serial.available() > 0)
  {
    incoming_int = Serial.parseInt();
    Serial.write(incoming_int);
  }
}
\end{verbatim}

Данная программа будет работать так. Если в мониторе порта вы введете строку
``72'' то монитор порта отправит его на Arduino как два байта данных в виде
чисел 55 и 51, функция \texttt{Serial.parseInt} подождет 2000 миллисекунд (как
видите я поменял время ожидание с 1 секунды на 2 секунды, чтобы нагляднее
показать кое какие аспекты) увидит эти два значения и преобразует их в одно
целочисленное 72 и присвоит его переменной \texttt{incoming\_int}, мы с помощью
метода \texttt{Serial.write} передадим число 72 как есть обратно в монитор порта
(почему именно этот метод нужен читайте далее) где монитор порта корректно
преобразует число 72 в соответствующий символ и покажет нам символ ``H'' который
соответствует коду 72. Таким образом мы можем передавать числовые значения с
компьютера на платформу Arduino и дальше использовать эти значения.

\chapter{Аналогово-цифровое преобразование}

Чтобы не терялась нить повествования, в главе ``Использование потенциометра''
стоило умолчать о том, как Arduino проводит преобразование напряжения с
аналогового порта в дискретное значение от 0 до 1023. Задавшись вопросом -- ``А
почему именно 1023?'', мы сможем познакомиться с такой интересной штукой как
АЦП. \emph{Аналого-Цифровой Преобразователь} (АЦП) - это устройство, которое и
проводит преобразование.

\section{Генерация звука}

\section{Подключение динамика}

\subsection{Задачи}

\section{Синтез музыки и технологии}

Теперь мы можем генерировать звуковой сигнал с нужной нам частотой. Однако, если
мы хотим сгенерировать что-нибудь интересное -- вроде мелодии -- то нам
потребуется использовать вполне определённые частоты. Здесь нам очень кстати
будет хотя бы начальное знание музыкальной теории, но если таких знаний нет --
не беда, разберём по ходу дела.

\section{Октавная система}

Как вы, возможно, знаете, музыка строится из нот -- их всего семь: до, ре, ми,
фа, соль, ля, си. Каждой ноте соответствует определённая частота. Мы уже
встречали с вами частоту 261.63 Гц в предыдущей главе -- так вот, данная частота
соответствует ноте ``си''. Ниже в таблице представлена таблица названий нот и их
частот

\section{Программирование простых мелодий}

\section{Использование массива для программирования мелодии}

\subsection{Задачи}
\begin{itemize}
\item Добавьте паузы между воспроизведением нот.
\item Попробуйте сделать управление скоростью воспроизведения мелодии с
  использованием потенциометра.
\item Сделайте ``светомузыку'' -- модифицируйте программу и схему на макетной плате
  таким образом, чтобы на каждую из семи нот загорался свой светодиод. После
  воспроизведения ноты светодиод должен гаснуть.
\end{itemize}

\section{Список сокращений}
\begin{acronym}
  \acro{ШИМ}{Широтно-импульсная модуляция}
\end{acronym}
\end{document}

