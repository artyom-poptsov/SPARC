\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Внешние аппаратные прерывания}

В данном разделе мы рассмотрим обработку внешних (по отношению к
микроконтроллеру) прерываний, а именно прерывания от кнопок.  Кнопки
подключаются на цифровые порты Arduino, и используются для изменения уровня
напряжения на цифровом порту.

Внешние аппаратные прерывания являются хорошим примером для начала изучения темы
этой главы, так как Arduino предоставялет удобные библиотечные процедуры для
работы с подобными прерываниями.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Подключение кнопки}
\index{Прерывания!Подключение кнопки}
\label{section:interrupts-button}

Начнём с подключения кнопки к Arduino.  Мы уже детально рассматривали способы
подключения кнопок в разделе \ref{section:game-dev-controls}.  Сейчас мы
воспользуемся схемой подключения с подтяжкой к 5В.

\figureButtonPullupResistorCircuit{ru}

\begin{listing}[H]
  \begin{minted}{cpp}
    const int BUTTON_PIN = 2;

    void setup() {
      pinMode(BUTTON_PIN, INPUT_PULLUP);
    }

    void loop() {
      // ...
    }
  \end{minted}
  \caption{Настройка порта в режим \texttt{INPUT\_PULLUP}.}
  \label{listing:interrupts-input-pullup}
\end{listing}

Цифровой порт, заданный константой \texttt{BUTTON\_PIN}, мы настраиваем в режим
\texttt{INPUT\_PULLUP} (как показано в листинге
\ref{listing:interrupts-input-pullup}), чтобы избежать необходимости
использовать отдельный подтягивающий резистор.  При нажатии на кнопку напряжение
на данном порту будет падать в ноль, и на это событие мы и будем регистрировать
прерывание.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Номер прерывания}
\label{subsection:interrupts-number}

У каждого внешнего аппаратного прерывания есть свой \emph{номер}.  Нам
необходимо знать номер прерывания, чтобы его обработать.  Важно отметить, что
номер прерывания -- это не тоже самое, что номер цифрового порта, хотя они и
связаны.

Всего на платформах Arduino существуют шесть прерываний, которые именуются
``int.0'', ``int.1'' и так до ``int.5''.

\tableInterrupts{ru}

Узнать номер прерывания, зная номер цифрового порта, можно, используя таблицу
\ref{table:interrupts-table}.  Как можно видеть, на одних платах доступны всего
два цифровых порта для обработки прерываний, тогда как на других вариантов
гораздо больше (см. \cite{arduino:reference}, раздел про
\texttt{attachInterrupt}.)

Например, для Arduino Uno прерывание с номером ноль (``int.0'') соответствует
цифровой порт номер 2.

Чтобы не искать номер цифрового порта для прерывания по таблице, можно
воспользоваться процедурой \texttt{digitalPinToInterrupt} из стандартной
библиотеки Arduino.  Процедура принимает номер порта в качестве параметра и
возвращает номер прерывания для этого порта.  В случае, если порт не может быть
использован с прерыванием, то процедура возвращает -1 (см. описание процедуры
\texttt{digitalPinToInterrupt} в \cite{arduino:reference}.)

\begin{listing}[H]
  \begin{minted}{cpp}
    const int BUTTON_PIN = 2;

    void setup() {
      Serial.begin(9600);
      int interrupt_number = digitalPinToInterrupt(BUTTON_PIN);

      if (interrupt_number == -1) {
        Serial.print("Неподдерживаемый порт: ");
        Serial.println(BUTTON_PIN);
      } else {
        Serial.print("Номер прерывания: ");
        Serial.println(interrupt_pin);
      }
    }

    void loop() {
      // Намеренно оставлена пустой.
    }
  \end{minted}
  \caption{Пример использования процедуры \texttt{digitalPinToInterrupt}.}
  \label{listing:interrupts-digital-pin-to-interrupt}
\end{listing}

Пример использования \texttt{digitalPinToInterrupt} показан в листинге
\ref{listing:interrupts-digital-pin-to-interrupt}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Обработчик прерывания}

Как уже говорилось ранее, \emph{обработчиком прерывания} (который по-английски
называется ``Interrupt Service Routine'', или сокращённо \gls{ISR}) называется
процедура, которая регистрируется для вызова по прерыванию (то есть, по
некоторому событию.)

По сути, ISR ничем не отличается от обычной процедуры, кроме того, что она не
вызывается нами явно в коде, а вместо этого вызывается процессором по событию.

Допустим, мы можем объявить обработчик прерывания, который меняет значение на
цифровом порту номер 13 с высокого \texttt{HIGH} на низкий \texttt{LOW} и
обратно, таким образом включая или выключая подключенный к данному порту
светодиод при каждом срабатывании.

\begin{listing}[ht]
  \begin{minted}{cpp}
    void toggle_led() {
      digitalWrite(13, ! digitalRead(13));
    }
  \end{minted}
  \caption{Процедура, выполняющая роль обработчика прерывания}
  \label{listing:interrupts-handler}
\end{listing}

В листиге \ref{listing:interrupts-handler} для инверсии значения на цифровом
порту используется трюк, заключающийся в том, что мы читаем с порта текущее
значение (либо \texttt{HIGH}, либо \texttt{LOW}) и инверируем его с помощью
логической операциии ``НЕ'' (записываемой в виде воскликцательного знака ``!''),
а потом выставляем полученное значение на порт.  Если на 13-м порту было
значение \texttt{LOW}, то оно после инверсии становится \texttt{HIGH}, и
наоборот.

Как можно видеть, объявление обработчика \texttt{toggle\_led} ничем не
отличается от объявления обычной процедуры.  Даже название данной процедуры
может быть произвольным, в рамках допустимых наименований процедур в C++.
Однако сама по себе эта процедура не будет зарегистрирована, как обработчик --
нам нужно воспользоваться процедурой \texttt{attachInterrupt} для её
регистрации, которая будет описана в следующем подразделе.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Регистрация обработчика прерываний}

Существует четыре вида событий, на которые можно привязать обработчик прерывания
(\gls{ISR}):
\begin{itemize}
\item \texttt{LOW} -- Событие происходит, когда на цифровом порту устанавливается
  низкий уровень напряжения (\texttt{LOW}) на цифровом порту.  Данное событие
  может повторятся, если значение на порту не меняется.
\item \texttt{CHANGE} -- Изменение значения на цифровом порту.  Данное событие
  происходит, когда на цифровом порту значение меняется либо с \texttt{LOW} до
  \texttt{HIGH}, либо наоборот.
\item \texttt{RISING} -- Событие происходит, когда напряжение на цифровом порту
  меняется с \texttt{LOW} на \texttt{HIGH}.
\item \texttt{FALLING} -- Событие происходит, когда напряжение на цифровом порту
  меняется с \texttt{HIGH} на \texttt{LOW}.
\end{itemize}

Для регистрации обработчика прерывания используется процедура
\texttt{attachInterrupt}.

\begin{listing}[H]
  \begin{minted}{cpp}
    attachInterrupt(<interrupt>, <procedure>, <mode>);
  \end{minted}
  \caption{Синтаксис вызова процедуры \texttt{attachInterrupt}.}
  \label{listing:interrupts-attach-interrupt}
\end{listing}

В общем виде, синтаксис вызова процедуры \texttt{attachInterrupt} так, как
показано в листинге \ref{listing:interrupts-attach-interrupt}.  Она принимает
три параметра:
\begin{enumerate}
\item \texttt{<interrupt>} -- номер прерывания.
\item \texttt{<procedure>} -- указатель на процедуру, являющуюся обработчиком
  прерывания.
\item \texttt{<mode>} -- условие срабатывания прерывания.
\end{enumerate}

Как узнать \emph{номер прерывания} мы уже обсуждали в
\ref{subsection:interrupts-number}.  В данном случае мы будем использовать
цифровой порт 2 для кнопки.

\begin{listing}[H]
  \begin{minted}{cpp}
    const int LED_PIN = 13;
    const int BUTTON_PIN = 2;

    void toggle_led() {
      digitalWrite(LED_PIN, ! digitalRead(LED_PIN));
    }

    void setup() {
      int interrupt_number
          = digitalPinToInterrupt(BUTTON_PIN);
      attachInterrupt(interrupt_number,
                      toggle_led,
                      RISING);
    }

    void loop() {
      // Намеренно оставлена пустой.
    }
  \end{minted}
  \caption{Обработка прерывания от кнопки.}
  \label{listing:interrupts-handler}
\end{listing}

В листинге \ref{listing:interrupts-handler} можно видеть, что мы оставили
процедуру \texttt{loop} пустой -- ведь в нашем случае, переключение состояния
светодиода выполняется в обработчике прерывания.  Вместо этого мы могли бы
прописать в \texttt{loop} дополнительную логику программы.  При приходе сигнала
от кнопки, \texttt{loop} приостанавливается и процессор переключается на
обработку прерывания.  Таким образом, создаётся эффект \emph{параллельности}
выполнения задач -- мы и \texttt{loop} выполняем, и обрабатываем нажатия кнопки.
На самом деле, это \emph{псевдо-параллельность}, так как Arduino перключается
между задачами, а не делает их одновременно.

\end{document}
