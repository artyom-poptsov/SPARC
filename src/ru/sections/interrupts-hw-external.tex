\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Внешние аппаратные прерывания}

В данном разделе мы рассмотрим обработку внешних (по отношению к
микроконтроллеру) прерываний, а именно прерывания от кнопок.  Кнопки
подключаются на цифровые порты Arduino, и используются для изменения уровня
напряжения на цифровом порту.

Внешние аппаратные прерывания являются хорошим примером для начала изучения темы
этой главы, так как Arduino предоставялет удобные библиотечные процедуры для
работы с подобными прерываниями.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Подключение кнопки}
\index{Прерывания!Подключение кнопки}
\label{section:interrupts-button}

Начнём с подключения кнопки к Arduino.  Мы уже детально рассматривали способы
подключения кнопок в разделе \ref{section:game-dev-controls}.  Сейчас мы
воспользуемся схемой подключения с подтяжкой к 5В.

\figureButtonPullupResistorCircuit{ru}

\begin{listing}[H]
  \begin{minted}{cpp}
    const int BUTTON_PIN = 2;

    void setup() {
      pinMode(BUTTON_PIN, INPUT_PULLUP);
    }

    void loop() {
      // ...
    }
  \end{minted}
  \caption{Настройка порта в режим \texttt{INPUT\_PULLUP}.}
  \label{listing:interrupts-input-pullup}
\end{listing}

Цифровой порт, заданный константой \texttt{BUTTON\_PIN}, мы настраиваем в режим
\texttt{INPUT\_PULLUP} (как показано в листинге
\ref{listing:interrupts-input-pullup}), чтобы избежать необходимости
использовать отдельный подтягивающий резистор.  При нажатии на кнопку напряжение
на данном порту будет падать в ноль, и на это событие мы и будем регистрировать
прерывание.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Номер прерывания}
\label{subsection:interrupts-number}

У каждого внешнего аппаратного прерывания есть свой \emph{номер}.  Нам
необходимо знать номер прерывания, чтобы его обработать.  Важно отметить, что
номер прерывания -- это не тоже самое, что номер цифрового порта, хотя они и
связаны.

Всего на платформах Arduino существуют шесть прерываний, которые именуются
``int.0'', ``int.1'' и так до ``int.5''.

\tableInterrupts{ru}

Узнать номер прерывания, зная номер цифрового порта, можно, используя таблицу
\ref{table:interrupts-table}.  Как можно видеть, на одних платах доступны всего
два цифровых порта для обработки прерываний, тогда как на других вариантов
гораздо больше (см. \cite{arduino:reference}, раздел про
\texttt{attachInterrupt}.)

Например, для Arduino Uno прерывание с номером ноль (``int.0'') соответствует
цифровой порт номер 2.

Чтобы не искать номер цифрового порта для прерывания по таблице, можно
воспользоваться процедурой \texttt{digitalPinToInterrupt} из стандартной
библиотеки Arduino.  Процедура принимает номер порта в качестве параметра и
возвращает номер прерывания для этого порта.  В случае, если порт не может быть
использован с прерыванием, то процедура возвращает -1 (см. описание процедуры
\texttt{digitalPinToInterrupt} в \cite{arduino:reference}.)

\begin{listing}[H]
  \begin{minted}{cpp}
    const int BUTTON_PIN = 2;

    void setup() {
      Serial.begin(9600);
      int interrupt_number
          = digitalPinToInterrupt(BUTTON_PIN);

      if (interrupt_number == -1) {
        Serial.print("Неподдерживаемый порт: ");
        Serial.println(BUTTON_PIN);
      } else {
        Serial.print("Номер прерывания: ");
        Serial.println(interrupt_pin);
      }
    }

    void loop() {
      // Намеренно оставлена пустой.
    }
  \end{minted}
  \caption{Пример использования процедуры \texttt{digitalPinToInterrupt}.}
  \label{listing:interrupts-digital-pin-to-interrupt}
\end{listing}

Пример использования \texttt{digitalPinToInterrupt} показан в листинге
\ref{listing:interrupts-digital-pin-to-interrupt}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Обработчик прерывания}

Как уже говорилось ранее, \emph{обработчиком прерывания} (который по-английски
называется ``Interrupt Service Routine'', или сокращённо \gls{ISR}) называется
процедура, которая регистрируется для вызова по прерыванию (то есть, по
некоторому событию.)

По сути, ISR ничем не отличается от обычной процедуры, кроме того, что она не
вызывается нами явно в коде, а вместо этого вызывается процессором по событию.

Допустим, мы можем объявить обработчик прерывания, который меняет значение на
цифровом порту номер 13 с высокого \texttt{HIGH} на низкий \texttt{LOW} и
обратно, таким образом включая или выключая подключенный к данному порту
светодиод при каждом срабатывании.

\begin{listing}[ht]
  \begin{minted}{cpp}
    void toggle_led() {
      digitalWrite(13, ! digitalRead(13));
    }
  \end{minted}
  \caption{Процедура, выполняющая роль обработчика прерывания}
  \label{listing:interrupts-handler}
\end{listing}

В листиге \ref{listing:interrupts-handler} для инверсии значения на цифровом
порту используется трюк, заключающийся в том, что мы читаем с порта текущее
значение (либо \texttt{HIGH}, либо \texttt{LOW}) и инверируем его с помощью
логической операциии ``НЕ'' (записываемой в виде воскликцательного знака ``!''),
а потом выставляем полученное значение на порт.  Если на 13-м порту было
значение \texttt{LOW}, то оно после инверсии становится \texttt{HIGH}, и
наоборот.

Как можно видеть, объявление обработчика \texttt{toggle\_led} ничем не
отличается от объявления обычной процедуры.  Даже название данной процедуры
может быть произвольным, в рамках допустимых наименований процедур в C++.
Однако сама по себе эта процедура не будет зарегистрирована, как обработчик --
нам нужно воспользоваться процедурой \texttt{attachInterrupt} для её
регистрации, которая будет описана в следующем подразделе.

Тем не менее, есть определённые особенности обработки прерываний, которые мы
обязаны учитывать при написании обработчика.

Во-первых, на Arduino прерывания обрабатываются последовательно в порядке
приоритета, и пока процессор не закончит обработку одного прерывания, он не
может переключиться на другое.  Следовательно, все операции, завязанные на
прерывания, внутри обработчика будут работать некорректно.

Например, внутри обработчика не будет работать передача данных по
последовательному порту (см. \ref{section:communication-serial-port}); не
работают процедуры \texttt{delay} и \texttt{delayMicroseconds}, а значение,
возвращаемое процедурой \texttt{millis} не инкрементируется -- поскольку все они
завязаны на прерывания.

Во-вторых, обработчик прерывания должен быть максимально короткими и быстрыми,
насколько это возможно.  И это связано с предыдущим замечанием -- ведь чем дольше
система проведёт внутри обработчика, тем дольше она не будет реагировать на все
другие прерывания, а \texttt{loop} будет в ``подвисшем'' состоянии.

\begin{listing}[H]
  \begin{minted}{cpp}
    volatile int counter = 0;

    // Обработчик прерывания:
    void increment_counter() {
      counter++;
    }

    // ...
  \end{minted}
  \caption{Пример использования ключевого слова \texttt{volatile}.}
  \label{listing:interrupts-volatile-variable}
\end{listing}

\index{Программирование!Переменная!Ключевое слово ``volatile''}
В-третьих, все глобальные переменные, которые мы используем внутри обработчика
прерывания, необходимо помечать ключевым словом \texttt{volatile}, чтобы при
сборке проекта компилятор не решил, что они никому не нужны и не удалил их.
Пример использования \texttt{volatile} показан в листинге
\ref{listing:interrupts-volatile-variable}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Регистрация обработчика прерываний}

Существует четыре вида событий, на которые можно привязать обработчик прерывания
(\gls{ISR}):
\begin{itemize}
\item \texttt{LOW} -- Событие происходит, когда на цифровом порту устанавливается
  низкий уровень напряжения (\texttt{LOW}) на цифровом порту.  Данное событие
  может повторятся, если значение на порту не меняется.
\item \texttt{CHANGE} -- Изменение значения на цифровом порту.  Данное событие
  происходит, когда на цифровом порту значение меняется либо с \texttt{LOW} до
  \texttt{HIGH}, либо наоборот.
\item \texttt{RISING} -- Событие происходит, когда напряжение на цифровом порту
  меняется с \texttt{LOW} на \texttt{HIGH}.
\item \texttt{FALLING} -- Событие происходит, когда напряжение на цифровом порту
  меняется с \texttt{HIGH} на \texttt{LOW}.
\end{itemize}

Для регистрации обработчика прерывания используется процедура
\texttt{attachInterrupt}.

\begin{listing}[H]
  \begin{minted}{cpp}
    attachInterrupt(<interrupt>, <procedure>, <mode>);
  \end{minted}
  \caption{Синтаксис вызова процедуры \texttt{attachInterrupt}.}
  \label{listing:interrupts-attach-interrupt}
\end{listing}

В общем виде, синтаксис вызова процедуры \texttt{attachInterrupt} так, как
показано в листинге \ref{listing:interrupts-attach-interrupt}.  Она принимает
три параметра:
\begin{enumerate}
\item \texttt{<interrupt>} -- номер прерывания.
\item \texttt{<procedure>} -- указатель на процедуру, являющуюся обработчиком
  прерывания.
\item \texttt{<mode>} -- условие срабатывания прерывания.
\end{enumerate}

Как узнать \emph{номер прерывания} мы уже обсуждали в
\ref{subsection:interrupts-number}.  В данном случае мы будем использовать
цифровой порт 2 для кнопки.

\begin{listing}[H]
  \begin{minted}{cpp}
    const int LED_PIN = 13;
    const int BUTTON_PIN = 2;

    void toggle_led() {
      digitalWrite(LED_PIN, ! digitalRead(LED_PIN));
    }

    void setup() {
      int interrupt_number
          = digitalPinToInterrupt(BUTTON_PIN);
      attachInterrupt(interrupt_number,
                      toggle_led,
                      FALLING);
    }

    void loop() {
      // Намеренно оставлена пустой.
    }
  \end{minted}
  \caption{Обработка прерывания от кнопки.}
  \label{listing:interrupts-handler}
\end{listing}

В листинге \ref{listing:interrupts-handler} можно видеть, что мы оставили
процедуру \texttt{loop} пустой -- ведь в нашем случае, переключение состояния
светодиода выполняется в обработчике прерывания.  Вместо этого мы могли бы
прописать в \texttt{loop} дополнительную логику программы.  При приходе сигнала
от кнопки, \texttt{loop} приостанавливается и процессор переключается на
обработку прерывания.  Таким образом, создаётся эффект \emph{параллельности}
выполнения задач -- мы и \texttt{loop} выполняем, и обрабатываем нажатия кнопки.
На самом деле, это \emph{псевдо-параллельность}, так как Arduino перключается
между задачами, а не делает их одновременно.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Проблема дребезга контактов}

\emph{Дребезгом контактов} называется эффект, который возникает в электрической
цепи после замыкания кнопки.  Суть его в том, что после замыкания происходят
многократные неконтролируемые замыкания и размыкания контактов кнопки, за счёт
упругости самих контактов и материалов схемы -- некоторое время контакты кнопки
отскакивают друг от друга при соударениях, таким образом замыкая и размыкая
электрическую цепь.

В нашей схеме этот нежелательный эффект проявляется в том, что при однократном
нажатии кнопки может происходить многократное срабатывание прерывания.

\figureButtonBounceGraph{ru}

Визуально эффект ``дребезга'' контактов показан на
рис. \ref{fig:button-bounce-graph}.  Предполагается, что кнопка соединяет
цифровой порт с выводом 5V на Arduino.  При разовом нажатии, кнопка несколько
раз быстро замыкает и размыкает контакт, создавая несколько срабатываний.

Существуют два способа устранения нежелательного влияния дребезга на работу
системы:
\begin{itemize}
\item \textbf{Программные} способы:
  \begin{enumerate}
  \item Путём установления временн\'ой задержки -- после первого срабатывания
    прерывания программа игнорирует последующие срабатывания в течении
    некоторого установленного времени.
  \item Путём подсчёта числа совпадающих значений сигнала замкнутости --
    срабатывание кнопки засчитывается, если программа при последовательном
    считывании состяния контакта кнопки получает установленное количество
    подтверждений замкнутости кнопки.  Требуемое количество подтверждений должно
    подбираться экспериментально.
  \item Путём подсчёта времени устойчивого состояния -- как и в предыдущем
    пункте, нам требуется подтвердить, что кнопка нажата, чтобы игнорировать
    лишние срабатывания.  Для этого программа отсчитывает некоторое
    установленное время, начиная от первого срабатывания кнопки -- если по
    прошествии этого времени не происходит дополнительных срабатываний кнопки,
    то её состояние считается устойчивым и нажатие засчитывается.  Время
    проверки должно подбираться экспериментально.
  \end{enumerate}
\item \textbf{Аппаратные} способы включают в себя различные модификации схемы
  подключения кнопки.  Как правило, в схему добавляют фильтр нижних частот
  (ФНЧ), который сглаживает дребезжания контактов, предотвращая лишние
  срабатывания.
\end{itemize}

Вариант программной защиты от дребезга контактов реализован в примере кода ниже.

\begin{listing}[H]
  \begin{minted}{cpp}
    const int LED_PIN = 13;
    const int BUTTON_PIN = 2;

    // Таймер отсчёта от последнего срабатывания кнопки:
    const int  DEBOUNCE_TIMER = 100; // ms
    // Отметка о времени последнего срабатывания кнопки:
    volatile int timestamp = 0; // ms
    // Статус нажатия кнопки:
    volatile bool is_button_pressed = false;

    void toggle_led() {
      if ((millis() - timestamp) > DEBOUNCE_TIMER) {
        is_button_pressed = true;
      }
      timestamp = millis();
    }

    void setup() {
      Serial.begin(9600); // Для отладки
      pinMode(BUTTON_PIN, INPUT_PULLUP);
      int interrupt_number
          = digitalPinToInterrupt(BUTTON_PIN);
      attachInterrupt(interrupt_number,
                      toggle_led,
                      FALLING);
    }

    void loop() {
      if (is_button_pressed) {
        digitalWrite(LED_PIN, ! digitalRead(LED_PIN));
        is_button_pressed = false;
        Serial.println("Pressed"); // Для отладки
      }
    }
  \end{minted}
  \caption{Обработка прерывания от кнопки с защитой от дребезга контактов.}
  \label{listing:interrupts-handler-button-debounce}
\end{listing}

\end{document}
