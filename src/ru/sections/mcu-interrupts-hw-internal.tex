\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Внутренние аппаратные прерывания}
\index{Аппаратное обеспечение!Прерывания!Внутренние}

Как говорилось ранее, источником внутренних прерываний являются периферийными
цепями внутри микроконтроллера.  Мы будем рассматривать подобные прерывания на
примере работы с \emph{таймерами}.

Таймер можно представить, как некоторый ``будильник'', который можно завести
внутри процессора и по его ``звонку'' вызывать некую процедуру -- обработчик
прерывания.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Принцип работы таймера}
\index{Аппаратное обеспечение!Прерывания!Внутренние!Таймер}

Аппаратный таймер по принципу работы представляет собой счётчик.  Преимуществом
таймера является то, что изменение счётчика происходит по аппаратному тактовому
импульсу, не зависящиму от выполнения программы на микроконтроллере.  Это даёт
определённость (или, как говорят, \emph{детерминизм}) в его работе, что в свою
очередь позволяет с большой точностью отмерять промежутки времени, при условии
учёта частоты процессора.

Микроконтроллеры семейства AVR, на которых основана платформа Arduino, обычно
имеют два 8-битных таймера и один 16-битный.  Восьмибитный таймер может считать
от 0 до 255 ($2^{8}-1$), тогда как 16-битный таймер имеет диапазон от 0 до 65535
($2^{16}-1$.)  Таймер с разрешением в 16 бит является более гибким в
использовании, чем 8-битный, однако не всегда возникает необходимость в таком
большом разрешении.  К тому же, использование 8-битного таймера может дать более
эффективный и компактный код.\cite{avr:timers}

Например, ATmega328p имеет 3 аппаратных таймера:
\begin{itemize}
\item \textbf{Timer0}: 8-битный таймер.
\item \textbf{Timer1}: 16-битный таймер.
\item \textbf{Timer2}: 8-битный таймер.
\end{itemize}

Микроконтроллер может быть настроен на отслеживание событий таймера (которых
существует несколько типов), чтобы по их приходу вызывать обработчик события.

Можно выделить три основных типа событий:
\begin{itemize}
\item Переполнение таймера (англ. ``Timer Overflow'')
\item Совпадение по сравнению (англ. ``Compare Match'')
\item Захват входного сигнала (англ. ``Input Capture'')
\end{itemize}

На данный момент нам наиболее важны первые два варианта, которые мы рассмотрим
сейчас подробнее.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Векторы прерываний}
\label{subsection:mcu-ivt}

Прерывания связываются с их обработчиком в виде \emph{вектора прерывания}.
Вектор прерывания является адресом памяти, который указывает на адрес
обработчика прерывания (\gls{ISR}.)  При срабатывании прерывания, система
переходит на тот адрес, который указан в векторе прерывания, и запускает код
обработчика.

\tableIVT{ru}

Векторы прерываний объединяются в \emph{таблицу векторов прерываний}.  В таблице
\ref{table:mcu-atmega328p-ivt} показаны векторы
прерываний\cite[49]{avr:atmega328p-datasheet} для микроконтроллера ATmega328p.
В контексте данного раздела примечательными для нас являются вектора с 8 по 17
включительно, так как они связаны с обработкой событий от таймеров.  В
частности, те вектора прерываний, для которых источником является ``TIMERx
OVF'', срабатывают при переполнении (англ. ``overflow'') счётчика таймера, о чём
речь пойдёт в следующем подразделе.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Прерывание по переполнению}

\figureInterruptTimerOverflow{ru}

\emph{Переполнение таймера} возникает, когда счётчик таймера доходит до своего
максимального значения.  После этого происходит вызов обработчика прерывания
(если он назначен), потом -- сброс счётчика в ноль и отсчёт начинается заново.
Максимальное значение для таймера определяется его \emph{разрешением}.
Например, для восмибитного таймера (``Timer0'' и ``Timer2'') максимальное
значение будет 255, а для 16-битного -- 65636:

\begin{equation}
  maximum\_value = 2^{timer\_resolution} - 1
\end{equation}

На рис. \ref{fig:timer-overflow-interrupt} схематически показана работа таймера
и красными точками отмечены моменты переполнения счётчика -- то есть, моменты
срабатывания прерывания по переполнению.

Возьмём для примера задачу мигания светодиодом.  Выполнение этой задачи делится
на несколько этапов.

\begin{enumerate}
\item Для начала нам надо настроить режим работы цифрового порта номер 2 (D2) на
  выход (\mintinline{cpp}{OUTPUT}.)  Поскольку мы в данной главе говорим про
  низкоуровневое программирование, то здесь мы также будем делать настройку
  режима порта через регистр ``DDR''.
\item Далее мы должны выставить правильный режим работы таймера, а именно
  установить через регистр ``TCCR1A'' умолчальный режим работы таймера, в
  котором он срабатывает по переполнению.
\item После этого нам надо включить перерывание по таймеру 1.
\item Наконец, мы должны описать обработчик прерывания (Interrupt Service
  Routine.)
\item В обработчике прерывания мы инвертируем значение бита в регистре
  ``PORTD'', соответствующего порту D2.
\item Процедура \mintinline{cpp}{loop} намеренно оставлена пустой, так как
  переключение режима светодиода происходит по прерыванию.
\end{enumerate}

Пример кода показан ниже.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      // 1. Настройка режима порта D2 на выход.
      DDRD |= 1 << 2;

      // 2. Установка таймера 1 в умолчальное
      // состояние, где прерывание срабатывает
      // по переполнению счётчика.
      TCCR1A = 0;

      // 3. Включение прерывания по таймеру 1.
      TIMSK1 |= B00000001;
    }

    // 4. Обработчик прерывания.
    ISR(TIMER1_OVF_vect) {
      // 5. Инверсия значения на порту D2.
      PORTD ^= 1 << 2;
    }

    void loop() {
      // 6. Оставлен пустым специально.
    }
  \end{minted}
  \caption{Пример мигания светодиодом по таймеру для Arduino Nano (ATmega328p.)}
  \label{listing:mcu-timer-example-1}
\end{listing}

Макрос \mintinline{cpp}{ISR} (см. 4 на \ref{listing:mcu-timer-example-1})
используется для регистрации обработчика прерывания для нужного нам вектора
прерываний (то, что мы обсуждали в подразделе \ref{subsection:mcu-ivt}.)

Здесь стоит обратить внимание на то, что обработчик прерывания называется
\mintinline{cpp}{TIMER1_OVF_vect}: по названию можно понять, что он связан с
вектором (``vect'' -- от англ. ``vector'') прерывания на таймере 1 (``TIMER1''),
и будет вызываться при переполнении таймера (``OVF'' -- сокращение от англ.
``overflow''.)  Мы должны именовать этот обработчик именно таким образом, иначе
он не будет вызываться.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Прерывание по сравнению}
\label{subsection:ocr}

\newglossaryentry{OCR}{
  name=OCR,
  description={Output Compare Register, выходной регистр сравнения}}

\emph{Совпадение по сравнению} возникает, когда значение счётчика таймера
достигает до заранее заданной отметки в допустимом диапазоне таймера (про
который мы говориле выше.)  Например, если мы выставим отметку на уровне 127, то
восмибитный таймер сработает на середине пути от нуля до переполнения.

\figureInterruptTimerCompare{ru}

На рис. \ref{fig:timer-overflow-compare-match} можно видеть, что значение
таймера сравнивается с двумя значениями: ``OCR A'' и ``OCR B''. ``OCR''
расшифровывается, как ``Output Compare Register''.  По сути это некая ячейка
памяти (так называемый \emph{регистр процессора}), хранящая значение, с которым
сравнивается значение таймера (из другой ячейки памяти.)  Когда значения двух
ячеек совпадают, то вызывается назначенный на данное событие обработчик
прерывания (\gls{ISR}.)

Для настройки доступно ограниченное количество ячеек ``OCR''.  Для кажого
таймера существуют две ячейки для сравнения, именуемые ``OCRxA'' и ``OCRxB'',
где ``x'' -- это номер таймера.  Скажем, для таймера номер 1 доступны ``OCR1A'' и
``OCR1B''.

Для каждого настроенного ``OCR'' назначается собственный обработчик.  Это
позволяет на одном таймере делать до двух прерываний.

В качестве примера использования прерывания по сравнению мы можем привести
мигание свтодиодом на порту ``D2''.

\begin{listing}[H]
  \begin{minted}{cpp}
    // 01. Частота процессора ATmega328p: 16МГц (16'000'000 Гц)
    const double CPU_FREQ = 16000000.0; // Гц.

    // 02. Предделитель частоты процессора для таймера.
    const int PRESCALER = 256;

    // 03. Желаемое значение задержки после включения
    //    и выключения.
    const double DELAY = 500000.0; // мкс

    // Длина секунды в микросекундах.
    const double SECOND = 1000000; // мкс

    // Частота прибавления счётчика в тактах процессора.
    const double CPU_TICKS_PER_STEP = CPU_FREQ / PRESCALER;

    // Период одного прибавления счётчика таймера
    // в микросекундах.
    const double TICK_PERIOD = SECOND / CPU_TICKS_PER_STEP;

    // 04. Количество тактов таймера между прерываниями.
    const long TICKS_COUNT = round(DELAY / TICK_PERIOD);

    void setup() {
      // 05. Настраиваем порт D2 на выход.
      DDRD |= 1 << 2;
      // 06. Инициализация таймера Timer1A.
      TCCR1A = 0;
      // 07. Устанавливаем делитель частоты процессора
      //     равным 256.
      TCCR1B = B00000100;
      // 08. Включаем прерывание COMPA.
      TIMSK1 |= B00000010;
      // 09. Устанавливаем задержку до первого срабатывания
      //     прерывания.
      OCR1A = TICKS_COUNT;
      // 10. Изначально все порты в "PORTD" выставлены
      //     в ноль.
      PORTD = 0;
    }

    // 11. Обработчик прерывания.
    ISR(TIMER1_COMPA_vect) {
      // 12. Инвертируем значение на порту.
      PORTD ^= 1 << 2;
      // 13. Устанавливаем время до следующего прерывания.
      OCR1A += TICKS_COUNT;
    }

    void loop() {
      // 14. Намеренно оставлен пустым.
    }
  \end{minted}
  \caption{Пример мигания светодиодом по переполнению таймера для Arduino Nano
    (ATmega328p.)}
  \label{listing:mcu-timer-example-2}
\end{listing}

В листинге \ref{listing:mcu-timer-example-2} можно видеть, что обработчик
прерывания (см. 11) имеет имя \mintinline{cpp}{TIMER1_COMPA_vect} -- это говорит
нам о том, что он предназначен для вектора прерывания таймера 1 (``TIMER1''), и
будет срабатывать при совпадении счётчика (``COMPA'') таймера 1 со значением
регистра ``OCR1A''.

\tableTCCRbits{ru}

Регистр ``TCCR1B'' (``Timer/Counter1 Control Register B'') используется для
управления первым таймером.

\tableTCCR{ru}

Биты с 0 по 2-й включительно задают источник тактового импульса для таймера, как
показано в таблице \ref{table:mcu-atmega328p-tccr}.  Если данные биты имеют
значение ``001'', то это означает, что таймер меняет значение счётчика с той
скоростью, с которой работает микроконтроллер.  Если мы хотим замедлить прирост
счётчика -- например, чтобы отсчитывать более долгие промежутки времени -- то
тогда для этих целей можно использовать \emph{предделитель}
(англ. ``prescaler''.)  Нам доступны делители 8, 64, 256 и 1024.

Мы используем встроенный в микроконтроллер генератор тактовых импульсов, где
один такт происходит с частотой процессора.  Номинальная частота ATmega328p
составляет 16МГц (16'000'000 Гц.)  Используя формулу
\ref{equation:mcu-tick-period}, мы можем посчитать время, сколько занимает один
такт процессора.

\begin{align}
  \mbox{Время такта процессора} =& \frac{1\mbox{с}}{\mbox{CPU\_FREQUENCY}} \nonumber \\
  =& \frac{1\mbox{с}}{16000000 \mbox{Гц}} \nonumber \\
  \approx& 0.000000063\mbox{с} \\
  \approx& 63\mbox{нс}
  \label{equation:mcu-tick-period}
\end{align}

Таким образом, мы узнали, что один такт процессора ATmega328p занимает 63
наносекунды (нс), и по-умолчанию прибавление таймера идёт каждый такт
процессора.  В этом случае, 16-битный таймер переполнится за 0.004128768
секунды, или примерно 4 миллисекунды, как показано в формуле
\ref{equation:mcu-16-bit-timer-overflow}.

\begin{align}
  \mbox{Время переполнения таймера} \approx& \mbox{Время такта процессора} * 65536 \nonumber \\
  \approx& 0.000000063\mbox{с} * 65536 \nonumber \\
  \approx& 0.004128768\mbox{с} \\
  \approx& 4\mbox{мс}
  \label{equation:mcu-16-bit-timer-overflow}
\end{align}

Возьмём теперь для примера делитель 256, как в листинге
\ref{listing:mcu-timer-example-2}.  В этом случае мы получим одно прибавление
счётчика таймера каждые 62500 такта процессора, как показано в формуле
\ref{equation:mcu-prescaler-1}.

\begin{align}
  \mbox{Время прибавления счётчика} =& \frac{\mbox{CPU\_FREQUENCY}}{\mbox{PRESCALER}} \nonumber \\
  =& \frac{16000000 \mbox{Гц}}{256} \nonumber \\
  =& 62500
  \label{equation:mcu-prescaler-1}
\end{align}

Более полезной для нас характерстикой является период, с которой идёт
прибавление счётчика, измеряемый в секундах, а не в тактах процессора.

\begin{align}
  \mbox{Время прибавления счётчика} =& \frac{1 \mbox{с}}{\mbox{CPU\_FREQUENCY} / \mbox{PRESCALER}} \nonumber \\
  =& \frac{1 \mbox{с}}{16000000 \mbox{Гц} / 256} \nonumber \\
  =& 0.000016 \mbox{с}
  \label{equation:mcu-prescaler-2}
\end{align}

В формуле \ref{equation:mcu-prescaler-2} показан рассчёт периода прироста
значения счётчика на единицу.  Как видим, при использовании предделителя 256
счётчик таймера будет увеличиваться на единицу каждые 0.000016 секунды (16 мкс.)
Это значит, что при использовании 16-битного таймера он переполнится через
1.048576 секунды, как показано в формуле \ref{equation:mcu-prescaler-3}.

\begin{align}
  \mbox{Время прибавления счётчика} =& 0.0000016\mbox{с} * 2^{16} \nonumber \\
  =& 0.0000016\mbox{с} * 65536 \nonumber \\
  =& 1.048576\mbox{с}
  \label{equation:mcu-prescaler-3}
\end{align}

Как же в этом случае рассчитать необходимое значение таймера, чтобы получить
срабатывание прерывания ровно через 1 секунду?  Всё достаточно просто:
достаточно поделить необходимое нам время на время прибавления счётчика, и
получим нужное количество прибавлений, как показано в формуле
\ref{equation:mcu-prescaler-4}.

\begin{align}
  \mbox{OCR1A} =& \frac{1\mbox{с}}{0.0000016\mbox{с}} \nonumber \\
  =& \frac{1000000\mbox{мкс}}{16\mbox{мкс}} \nonumber \\
  =& 62500
  \label{equation:mcu-prescaler-4}
\end{align}

Таким образом, если мы запишем значение 62500 в регистр ``OCR1A'', то прерывание
сработает через 1 секунду.  А что, если мы захотим запланировать выполнение
прерывания раз в половину секунды, как в примере
\ref{listing:mcu-timer-example-2}?  Попробуем посчитать.

\begin{align}
  \mbox{OCR1A} =& \frac{0.5\mbox{с}}{0.0000016\mbox{с}} \nonumber \\
  =& \frac{500000\mbox{мкс}}{16\mbox{мкс}} \nonumber \\
  =& 31250
  \label{equation:mcu-prescaler-5}
\end{align}

Как видно из формулы \ref{equation:mcu-prescaler-5}, мы должны записать значение
31250 в регистр ``OCR1A'', чтобы прерывание срабатывало 1 раз в 500мс.  В
примере \ref{listing:mcu-timer-example-2} в обработчике прерывания (11) у нас
инвертируется значение на порту; таким образом, раз в половину секунды светодиод
будет менять своё состояние (включённый/выключенный.)  Полный же цикл мигания
будет занимать 1 секунду.

Посмотрим теперь пример кода, где мигают два светодиода, с разной частотой.

\begin{listing}[H]
  \begin{minted}{cpp}
    // 01. Частота процессора ATmega328p: 16МГц (16'000'000 Гц)
    const double CPU_FREQ = 16000000.0; // Гц.

    // 02. Предделитель частоты процессора для таймера.
    const int PRESCALER = 256;

    // 03. Желаемое значение задержки после включения
    //    и выключения.
    const double DELAY_1 = 250000.0; // мкс
    const double DELAY_2 = 750000.0; // мкс

    // Длина секунды в микросекундах.
    const double SECOND = 1000000; // мкс

    // Частота прибавления счётчика в тактах процессора.
    const double CPU_TICKS_PER_STEP = CPU_FREQ / PRESCALER;

    // Период одного прибавления счётчика таймера
    // в микросекундах.
    const double TICK_PERIOD = SECOND / CPU_TICKS_PER_STEP;

    // 04. Количество тактов таймера между прерываниями.
    const long TICKS_COUNT_1 = round(DELAY_1 / TICK_PERIOD);
    const long TICKS_COUNT_2 = round(DELAY_2 / TICK_PERIOD);

    void setup() {
      // 05. Настраиваем порты D2 и D3 на выход.
      DDRD |= (1 << 2) | (1 << 3);
      // 06. Инициализация таймера Timer1A.
      TCCR1A = 0;
      TCCR1B = 0;
      // 07. Устанавливаем делитель частоты процессора
      //     равным 256.
      TCCR1B = B00000100;
      // 08. Включаем прерывание COMPA и COMPB.
      TIMSK1 |= B00000011;
      // 09. Устанавливаем задержку до первого срабатывания
      //     прерывания.
      OCR1A = TICKS_COUNT_1;
      OCR1B = TICKS_COUNT_2;
      // 10. Изначально все порты в "PORTD" выставлены
      //     в ноль.
      PORTD = 0;
    }

    // 11. Обработчик прерывания COMPA.
    ISR(TIMER1_COMPA_vect) {
      // 12. Инвертируем значение на порту.
      PORTD ^= 1 << 2;
      // 13. Устанавливаем время до следующего прерывания.
      OCR1A += TICKS_COUNT_1;
    }

    // 14. Обработчик прерывания COMPB.
    ISR(TIMER1_COMPB_vect) {
      // 15. Инвертируем значение на порту.
      PORTD ^= 1 << 3;
      // 16. Устанавливаем время до следующего прерывания.
      OCR1B += TICKS_COUNT_2;
    }

    void loop() {
      // 17. Намеренно оставлен пустым.
    }
  \end{minted}
  \caption{Пример мигания двумя светодиодами по переполнению таймера для Arduino
    Nano (ATmega328p.)}
  \label{listing:mcu-timer-example-3}
\end{listing}

В листинге \ref{listing:mcu-timer-example-3} можно видеть, что задаются два
вектора прерываний:\\``TIMER1\_COMPA\_vect'' (11) и ``TIMER1\_COMPB\_vect''
(14.)  Совпадение счётчика с ``COMPA'' будет происходить раз в 250мс, тогда как
совпадение с ``COMPB'' будет происходить раз в 750мс.

\end{document}
