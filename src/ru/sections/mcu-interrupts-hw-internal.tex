\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Внутренние аппаратные прерывания}
\index{Аппаратное обеспечение!Прерывания!Внутренние}

Как говорилось ранее, источником внутренних прерываний являются периферийными
цепями внутри микроконтроллера.  Мы будем рассматривать подобные прерывания на
примере работы с \emph{таймерами}.

Таймер можно представить, как некоторый ``будильник'', который можно завести
внутри процессора и по его ``звонку'' вызывать некую процедуру -- обработчик
прерывания.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Принцип работы таймера}
\index{Аппаратное обеспечение!Прерывания!Внутренние!Таймер}

Аппаратный таймер по принципу работы представляет собой счётчик.  Преимуществом
таймера является то, что изменение счётчика происходит по аппаратному тактовому
импульсу, не зависящиму от выполнения программы на микроконтроллере.  Это даёт
определённость (или, как говорят, \emph{детерминизм}) в его работе, что в свою
очередь позволяет с большой точностью отмерять промежутки времени, при условии
учёта частоты процессора.

Микроконтроллеры семейства AVR, на которых основана платформа Arduino, обычно
имеют два 8-битных таймера и один 16-битный.  Восьмибитный таймер может считать
от 0 до 255 ($2^{8}-1$), тогда как 16-битный таймер имеет диапазон от 0 до 65535
($2^{16}-1$.)  Таймер с разрешением в 16 бит является более гибким в
использовании, чем 8-битный, однако не всегда возникает необходимость в таком
большом разрешении.  К тому же, использование 8-битного таймера может дать более
эффективный и компактный код.\cite{avr:timers}

Например, ATmega328p имеет 3 аппаратных таймера:
\begin{itemize}
\item \textbf{Timer0}: 8-битный таймер.
\item \textbf{Timer1}: 16-битный таймер.
\item \textbf{Timer2}: 8-битный таймер.
\end{itemize}

Микроконтроллер может быть настроен на отслеживание событий таймера (которых
существует несколько типов), чтобы по их приходу вызывать обработчик события.

Можно выделить три основных типа событий:
\begin{itemize}
\item Переполнение таймера (англ. ``Timer Overflow'')
\item Совпадение по сравнению (англ. ``Compare Match'')
\item Захват входного сигнала (англ. ``Input Capture'')
\end{itemize}

На данный момент нам наиболее важны первые два варианта, которые мы рассмотрим
сейчас подробнее.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Векторы прерываний}
\label{subsection:mcu-ivt}

Прерывания связываются с их обработчиком в виде \emph{вектора прерывания}.
Вектор прерывания является адресом памяти, который указывает на адрес
обработчика прерывания (\gls{ISR}.)  При срабатывании прерывания, система
переходит на тот адрес, который указан в векторе прерывания, и запускает код
обработчика.

\tableIVT{ru}

Векторы прерываний объединяются в \emph{таблицу векторов прерываний}.  В таблице
\ref{table:mcu-atmega328p-ivt} показаны векторы
прерываний\cite[49]{avr:atmega328p-datasheet} для микроконтроллера ATmega328p.
В контексте данного раздела примечательными для нас являются вектора с 8 по 17
включительно, так как они связаны с обработкой событий от таймеров.  В
частности, те вектора прерываний, для которых источником является ``TIMERx
OVF'', срабатывают при переполнении (англ. ``overflow'') счётчика таймера, о чём
речь пойдёт в следующем подразделе.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Прерывание по переполнению}

\figureInterruptTimerOverflow{ru}

\emph{Переполнение таймера} возникает, когда счётчик таймера доходит до своего
максимального значения.  После этого происходит вызов обработчика прерывания
(если он назначен), потом -- сброс счётчика в ноль и отсчёт начинается заново.
Максимальное значение для таймера определяется его \emph{разрешением}.
Например, для восмибитного таймера (``Timer0'' и ``Timer2'') максимальное
значение будет 255, а для 16-битного -- 65636:

\begin{equation}
  maximum\_value = 2^{timer\_resolution} - 1
\end{equation}

На рис. \ref{fig:timer-overflow-interrupt} схематически показана работа таймера
и красными точками отмечены моменты переполнения счётчика -- то есть, моменты
срабатывания прерывания по переполнению.

Возьмём для примера задачу мигания светодиодом.  Выполнение этой задачи делится
на несколько этапов.

\begin{enumerate}
\item Для начала нам надо настроить режим работы цифрового порта номер 2 (D2) на
  выход (\mintinline{cpp}{OUTPUT}.)  Поскольку мы в данной главе говорим про
  низкоуровневое программирование, то здесь мы также будем делать настройку
  режима порта через регистр ``DDR''.
\item Далее мы должны выставить правильный режим работы таймера, а именно
  установить через регистр ``TCCR1A'' умолчальный режим работы таймера, в
  котором он срабатывает по переполнению.
\item После этого нам надо включить перерывание по таймеру 1.
\item Наконец, мы должны описать обработчик прерывания (Interrupt Service
  Routine.)
\item В обработчике прерывания мы инвертируем значение бита в регистре
  ``PORTD'', соответствующего порту D2.
\item Процедура \mintinline{cpp}{loop} намеренно оставлена пустой, так как
  переключение режима светодиода происходит по прерыванию.
\end{enumerate}

Пример кода показан ниже.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      // 1. Настройка режима порта D2 на выход.
      DDRD |= 1 << 2;

      // 2. Установка таймера 1 в умолчальное
      // состояние, где прерывание срабатывает
      // по переполнению счётчика.
      TCCR1A = 0;

      // 3. Включение прерывания по таймеру 1.
      TIMSK1 |= B00000001;
    }

    // 4. Обработчик прерывания.
    ISR(TIMER1_OVF_vect) {
      // 5. Инверсия значения на порту D2.
      PORTD ^= 1 << 2;
    }

    void loop() {
      // 6. Оставлен пустым специально.
    }
  \end{minted}
  \caption{Пример мигания светодиодом по таймеру для Arduino Nano (ATmega328p.)}
  \label{listing:mcu-timer-example-1}
\end{listing}

Макрос \mintinline{cpp}{ISR} (см. 4 на \ref{listing:mcu-timer-example-1})
используется для регистрации обработчика прерывания для нужного нам вектора
прерываний (то, что мы обсуждали в подразделе \ref{subsection:mcu-ivt}.)

Здесь стоит обратить внимание на то, что обработчик прерывания называется
\mintinline{cpp}{TIMER1_OVF_vect}: по названию можно понять, что он связан с
вектором (``vect'' -- от англ. ``vector'') прерывания на таймере 1 (``TIMER1''),
и будет вызываться при переполнении таймера (``OVF'' -- сокращение от англ.
``overflow''.)  Мы должны именовать этот обработчик именно таким образом, иначе
он не будет вызываться.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Прерывание по сравнению}

\newglossaryentry{OCR}{
  name=OCR,
  description={Output Compare Register, выходной регистр сравнения}}

\emph{Совпадение по сравнению} возникает, когда значение счётчика таймера
достигает до заранее заданной отметки в допустимом диапазоне таймера (про
который мы говориле выше.)  Например, если мы выставим отметку на уровне 127, то
восмибитный таймер сработает на середине пути от нуля до переполнения.

\figureInterruptTimerCompare{ru}

На рис. \ref{fig:timer-overflow-compare-match} можно видеть, что значение
таймера сравнивается с двумя значениями: ``OCR A'' и ``OCR B''. ``OCR''
расшифровывается, как ``Output Compare Register''.  По сути это некая ячейка
памяти (так называемый \emph{регистр процессора}), хранящая значение, с которым
сравнивается значение таймера (из другой ячейки памяти.)  Когда значения двух
ячеек совпадают, то вызывается назначенный на данное событие обработчик
прерывания (\gls{ISR}.)

Подробнее понятие \emph{регистра процессора} мы рассмотрим в последующих
разделах.

Для настройки доступно ограниченное количество ячеек ``OCR''.  Для кажого
таймера существуют две ячейки для сравнения, именуемые ``OCRxA'' и ``OCRxB'',
где ``x'' -- это номер таймера.  Скажем, для таймера номер 1 доступны ``OCR1A'' и
``OCR1B''.

Для каждого настроенного ``OCR'' назначается собственный обработчик.  Это
позволяет на одном таймере делать до двух прерываний.

В качестве примера использования прерывания по сравнению мы можем привести
мигание свтодиодом на порту ``D2''.

\begin{listing}[H]
  \begin{minted}{cpp}
    // 01. Частота процессора ATmega328p: 16МГц (16'000'000 Гц)
    const long CPU_FREQ = 16000000; // Гц.
    // 02. Делитель частоты процессора для таймера.
    const int PRESCALER = 256;
    // 03. Желаемое значение задержки после включения
    //    и выключения.
    const float DELAY = 500.0;
    // 04. Количество тактов таймера между прерываниями.
    const long TICKS_COUNT = \
      round((DELAY * CPU_FREQ) / (PRESCALER * 1000.0));

    void setup() {
      // 05. Настраиваем порт D2 на выход.
      DDRD |= 1 << 2;
      // 06. Инициализация таймера Timer1A.
      TCCR1A = 0;
      // 07. Устанавливаем делитель частоты процессора
      //     равным 256.
      TCCR1B = B00000100;
      // 08. Включаем прерывание COMPA.
      TIMSK1 |= B00000010;
      // 09. Устанавливаем задержку до первого срабатывания
      //     прерывания.
      OCR1A = TICKS_COUNT;
      // 10. Изначально все порты в "PORTD" выставлены
      //     в ноль.
      PORTD = 0;
    }

    // 11. Обработчик прерывания.
    ISR(TIMER1_COMPA_vect) {
      // 12. Инвертируем значение на порту.
      PORTD ^= 1 << 2;
      // 13. Устанавливаем время до следующего прерывания.
      OCR1A += TICKS_COUNT;
    }

    void loop() {
      // 14. Намеренно оставлен пустым.
    }
  \end{minted}
  \caption{Пример мигания светодиодом по переполнению таймера для Arduino Nano
    (ATmega328p.)}
  \label{listing:mcu-timer-example-2}
\end{listing}

В листинге \ref{listing:mcu-timer-example-2} можно видеть, что обработчик
прерывания (см. 11) имеет имя \mintinline{cpp}{TIMER1_COMPA_vect} -- это говорит
нам о том, что он предназначен для вектора прерывания таймера 1 (``TIMER1''), и
будет срабатывать при совпадении счётчика (``COMPA'') таймера 1 со значением
регистра ``OCR1A''.

\tableTCCR{ru}

Регистр ``TCCR1B'' (``Timer/Counter1 Control Register B'') используется для
управления первым таймером.  Биты с 0 по 2-й включительно задают источник
тактового импульса для таймера, как показано в таблице
\ref{table:mcu-atmega328p-tccr}.

\end{document}
