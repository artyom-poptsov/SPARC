\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Процедуры, функции и методы}
\index{Программирование!Процедуры, функции и методы}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Понятие процедуры}
На данный момент мы уже знакомы с базовыми командами Arduino, которые позволяют
нам делать настройку режима цифровых портов, управлять значением на них и ждать
определённое время.  Имея такой набор инструментов, мы уже можем делать базовые
эффекты мигания светодиодами и ``Бегущего огня''.

Со временем мы заметили, что при большом количестве светодиодов размер исходного
кода программы быстро расёт, что делает дальнейшую работу всё менее комфортной.
Мы отчасти решили эту проблему, через использование \emph{циклов}, таким образом
инструктируя компьютер повторять определённый код согласно прописанным
параметрам цикла.

Тем не менее, если мы посмотрим на пример реализации мигания светодиодами через
цикл \mintinline{cpp}{for}, то увидим потенциал для дальнейшего улучшения кода.

\begin{listing}[ht]
  \begin{minted}[
      highlightlines={9-12,15-18}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        digitalWrite(p, HIGH);
        delay(100);
        digitalWrite(p, LOW);
        delay(100);
      }
      for (int p = 6; p > 2; p--) {
        digitalWrite(p, HIGH);
        delay(100);
        digitalWrite(p, LOW);
        delay(100);
      }
    }
  \end{minted}
  \label{listing:for-loop-example-1}
  \caption{Пример реализации мигания светодиодами на базе цикла \texttt{for}.}
\end{listing}

В листинге \ref{listing:for-loop-example-1} можно видеть, что в
\mintinline{cpp}{loop} прописаны два цикла \mintinline{cpp}{for}, создающие
эффект ``Бегущего огня'', где светодиоды мигают сначала в одном порядке, а затем
-- в обратном.  При этом, выделенные части кода (которые как раз и делают эффект
мигания) идентичны в обоих циклах.

Дело в том, что наш компьютер имеет достаточно примитивный набор команд, и
концепция ``мигания'' для него неизвестна -- до тех пор, пока мы не пропишем ему
алгоритм.  Но даже в этом случае, каждый раз мы вынуждены ему объяснять эту
концепцию снова и снова.  Однако у нас есть способ научить объяснить компьютеру
концепцию ``мигания'' так, чтобы он запомнил её -- через создания новой команды
``мигания'' (англ. ``blink''), которую затем мы сможем применять в коде.

Подобные команды, как правило, называются \emph{``процедурами''}, или
\emph{``функциями''}.

Посмотрим на изменённый пример кода.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={7-12, 16, 19}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void blink() {
      digitalWrite(2, HIGH);
      delay(100);
      digitalWrite(2, LOW);
      delay(100);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink();
      }
      for (int p = 6; p > 2; p--) {
        blink();
      }
    }
  \end{minted}
  \label{listing:procedure-example-1}
  \caption{Пример реализации процедуры.}
\end{listing}

Обратите внимание, что появилось описание процедуры ``blink'' на с 7-й по 12-ю
строки.  С 8-й по 11-ю строки (в фигурных скобках) мы можем видеть \emph{тело
процедуры} -- это как раз та полезная работа, которую процедура выполняет при её
вызове.

Далее, на 16-й строке процедура ``blink'' \emph{вызывается} -- то есть, при
выполнении данных строк компьютер запоминает то, над чем он работал, затем
``прыгает'' внутрь процедуры ``blink'', выполняет её тело, потом возвращается
обратно в место вызова и продолжает выполнять код далее.

Как можно видеть, вызывать процедуры можно произвольное количество раз --
например, на 19-й строке мы вызываем её снова.

К сожалению, пока наш пример имеет важный недостаток -- процедура ``blink''
мигает всегда одним и тем же светодиодом (на цифровом порту 2), и мы никак не
можем на это повлиять.  Чтобы это исправить, добавим для процедуры
\emph{параметры} вызова.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Формальные и фактические параметры}

При работе с процедурами часто может возникать необходимость как-то влиять на
то, как она работает внутри.  Для того, чтобы это стало возможным, нам
необходимо задать \emph{параметры} для процедуры.

\begin{listing}[H]
  \begin{minted}[highlightlines={1}]{cpp}
    void blink(int n) {
      digitalWrite(n, HIGH);
      delay(100);
      digitalWrite(n, LOW);
      delay(100);
    }
  \end{minted}
  \label{listing:procedure-example-2}
  \caption{Объявление процедуры ``blink'' с одним параметром.}
\end{listing}

В листинге \ref{listing:procedure-example-2} можно видеть, что описание
процедуры ``blink'' поменялось -- в круглых скобках после её имены была добавлена
переменная с именем \mintinline{cpp}{n}.  Обратим внимание на то, что переменная
не инициализирована значением -- вместо этого, значение она получит при вызове
процедуры.

Параметры, заданные в круглых скобках при объявлении процедуры, называются
\emph{формальными параметрами}.

Внутри тела процедуры переменная \mintinline{cpp}{n} используется, как и любая
другая.  В данном случае она передаётся в \mintinline{cpp}{digitalWrite}, как
номер цифрового порта.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={7-12, 16, 19}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void blink(int n) {
      digitalWrite(n, HIGH);
      delay(100);
      digitalWrite(n, LOW);
      delay(100);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(2);
      }
      for (int p = 6; p > 2; p--) {
        blink(3);
      }
    }
  \end{minted}
  \label{listing:procedure-example-3}
  \caption{Пример вызова процедуры с параметрами.}
\end{listing}

Посмотрим теперь на полный листинг \ref{listing:procedure-example-3}.  Можно
видеть, что на 16-й строке при вызове ``blink'' мы теперь вписали в круглые
скобки число 2 -- данное число будет \emph{скопировано} внутрь процедуры, как
значение переменной \mintinline{cpp}{n}.  На 19-й строке мы вызвали ту же
процедуру, но уже передав в неё значение 3.  Таким образом, в первом цикле у нас
будет мигать 5 раз светодиод на цифровом порту 2, а во втором цикле будет мигать
светоидод на порту 3.

Параметры, заданные при вызове процедуры, называются \emph{фактическими
параметрами}.

Если мы хотим сделать так, чтобы у нас был эффект ``Бегущего огня'', то нам
вместо числовой константы (вроде 2 или 3) надо подставить переменную из цикла.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={3, 6}
    ]{cpp}
    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(p);
      }
      for (int p = 6; p > 2; p--) {
        blink(p);
      }
    }
  \end{minted}
  \label{listing:procedure-example-4}
  \caption{Пример реализации ``Бегущего огня'' с помощью процедуры.}
\end{listing}

Важно отметить, что в примере \ref{listing:procedure-example-4} значение
переменной \mintinline{cpp}{p} \emph{копируется} в процедуру ``blink'',
становясь значением параметра \mintinline{cpp}{n}.

\begin{listing}[H]
  \begin{minted}[highlightlines={1, 3, 5}]{cpp}
    void blink(int n, int d) {
      digitalWrite(n, HIGH);
      delay(d);
      digitalWrite(n, LOW);
      delay(d);
    }
  \end{minted}
  \label{listing:procedure-example-5}
  \caption{Объявление процедуры ``blink'' с двумя параметрами.}
\end{listing}

Теперь посмотрим на пример, где мы будем влиять на два параметра процедуры: на
номер цифрового порта и на время задержки между включением и выключением.  Для
этого нам потребуется модифицировать процедуру ``blink'', как показано в
листинге \ref{listing:procedure-example-5}.

Полный пример кода, с вызовом модифицированной процедуры, показан ниже.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={7-12, 16, 19}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void blink(int n, int d) {
      digitalWrite(n, HIGH);
      delay(d);
      digitalWrite(n, LOW);
      delay(d);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(p, 200);
      }
      for (int p = 6; p > 2; p--) {
        blink(p, 100);
      }
    }
  \end{minted}
  \label{listing:procedure-example-6}
  \caption{Пример вызова процедуры с двумя параметрами.}
\end{listing}

Посмотрим на циклы внутри \mintinline{cpp}{loop} в листинге
\ref{listing:procedure-example-6}.  Видно, что в качестве первого фактического
параметра в процедуру ``blink'' передаётся значение переменной
\mintinline{cpp}{p} (в обоих циклах), тогда как в качестве второго фактического
параметра передётся числовая константа: в первом цикле это число 200, во втором
-- число 100.

Важным моментом является то, что передача параметров внутрь процедуры является
\emph{позиционной} -- то есть, фактические параметры копируются в формальные
параметры процедуры в том порядке, как они перечислены в круглых скобках при
вызове.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={12}
    ]{cpp}
    // ...

    void blink(int n, int d) {
      digitalWrite(n, HIGH);
      delay(d);
      digitalWrite(n, LOW);
      delay(d);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(200, p);
      }
      // ...
    }
  \end{minted}
  \label{listing:procedure-example-7}
  \caption{Пример ошибочного вызова процедуры с двумя параметрами.}
\end{listing}

Иными словами, если мы переставим при вызове процедуры ``blink'' параметры ``p''
и ``100'' местами (как показано в листинге \ref{listing:procedure-example-7}),
то получим значение 100 в параметре ``n'' и значение, зависящее от итерации
цикла, в параметре ``d'' -- что, очевидно, не имеет большого смысла.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Вопросы терминологии}

В большинстве современных языков программирования существует понятие
\emph{процедур}, \emph{функций} или даже \emph{методов}.  Чаще всего, читая
книги, слушая лекции или общаясь с другими программистами\footnote{Возможно,
общение с другими, более опытными, программистами есть один из важнейших
способов обучения.  Здесь мы можем лишь посочувствовать интровертам.} мы будем
встречать именно понятие функции.  Давайте же разберёмся, в чём же разница между
перечисленными нами понятиями и как их правильно использовать в разных
контекстах.

Мы будем придерживаться терминологии, предложенной\cite[28]{sicp-en} авторами
книги ``Структура и интерпретация компьютерных программ'', а именно разделим
понятие ``функции'' и ``процедуры''.  В нашем понимании, ``функция'' есть
математическое понятие, которое далеко не всегда может быть применено к тому,
что мы пишем в программах.  В математике описание функции почти не даёт нам
прямого описания последовательности шагов, которые надо выполнить для достижения
результата -- вместо этого, нам даётся \emph{декларативное} описание (отвечая на
вопрос ``что надо надо сделать?'')  С другой стороны, в информатике (и
программировани в частности) нам необходимо подробно знать порядок шагов,
позволяющий достичь желаемого результата (то есть, знания, отвечающие на вопрос
``как это сделать?'')

Кроме того, в программировании процедуры часто модифицируют некое
\emph{глобальное состояние} системы, на которой они работают -- например,
изменяют значение глобальных переменных, меняют значение на цифровых портах (как
в Arduino) и тому подобное.  Из-за этого повторный вызов одной и той же
процедуры с одинаковыми фактическими параметрами может давать разные эффекты,
исходя из этого глобального состояния.  Это, как правило, отличается от
математических функций, где вызыв с одними и теми же параметрами всегда будет
приводить к одному и тому же результату.

Исходя из всего вышесказанного, мы будем использовать понятие процедуры на
страницах данной книги.

Другое понятие, которое может нам встретиться -- это \emph{метод}.  Данное
понятие встречается в контексте объектно-ориентированного программирования.  Про
эту тему мы будем говорить позже, сейчас же кратко можно дать определение, что
метод есть процедура, описанная внутри класса.  Если на данном этапе плохо
понятен смысл этих слов -- это нормально.  При дальнейшем изучении
программирования данное определение неизбежно станет понятным и простым.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ещё один взгляд на процедуры}

Посмотрим ещё раз на пример процедуры \mintinline{cpp}{blink}, а именно на её
вызов.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={12}
    ]{cpp}
    // ...

    void blink(int n, int d) {
      digitalWrite(n, HIGH);
      delay(d);
      digitalWrite(n, LOW);
      delay(d);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(200, p);
      }
      // ...
    }
  \end{minted}
  \label{listing:procedure-example-8}
  \caption{Пример ошибочного вызова процедуры с двумя параметрами.}
\end{listing}

Как мы видим из примера \ref{listing:procedure-example-8}, вызов
\mintinline{cpp}{blink} очень похож на вызов \mintinline{cpp}{digitalWrite}.
Давайте сравним: сначала на строчке записано имя процедуры
(\mintinline{cpp}{blink} в одном случае, и \mintinline{cpp}{digitalWrite} -- в
другом), потом идут круглые скобки, и в них записаны два фактических параметра.
Можно сделать вывод, что раз эти две вещи похожи, возможно они есть что-то
однотипное.\footnote{Чувство сходства вещей в программировании редко подводит.
Фигурально выражаясь, если что-то выглядит, как утка, и крякает, как утка -- то
возможно это и есть утка.  Накапливая опыт в программировании, мы будем всё
больше видеть сходства вещей не только внутри одного языка программирования, но
и между разными языками.}

И действительно: и \mintinline{cpp}{blink}, и \mintinline{cpp}{digitalWrite}
являются процедурами, которые мы вызываем в коде.  Разница тут лишь в том, что
процедура \mintinline{cpp}{digitalWrite} была написана кем-то до нас и является
частью стандартной библиотеки процедур, а \mintinline{cpp}{blink} мы написали
сами.

Интересной идеей является то, что путём написания собственных процедур мы как бы
расширяем язык программирования новыми командами, ``подгибая'' его под нашу
конкретную задачу.  И это здорово!  Ведь когда мы имеем набор команд именно для
решения наших задач, то это решение может вырисовываться как бы само собой, и
более легко.

\end{document}
