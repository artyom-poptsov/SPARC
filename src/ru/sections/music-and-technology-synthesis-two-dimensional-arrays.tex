\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Двумерные массивы}
\index{Программирование!Массив!Двумерный массив}

Было бы круто разместить наши ноты таким образом, чтобы каждая нота лежала в
ячейке массива вместе со своей длительностью. К счастью, у нас есть такая
возможность -- мы можем использовать \emph{двумерные массивы}.

Схематическое изображение двумерного массива представлено в виде таблицы
\ref{table:array-example-2}.

\tableTwoDimensionalArray{ru}

Каждая строка нашего массива должна содержать описание одной ноты. Столбец с
номером ноль содержит частоту ноты, а столбец номер один содержит её
длительность в виде знаменателя простой дроби, где в числителе у нас находится
длина такта. Например, нота номер ноль (``C4'') имеет в музыкальном произведении
длительность $\frac{1}{4}$, следовательно её длительность будет записана, как 4.

Записать программно мелодию в виде двумерного массива можно следующим образом:

\begin{minted}{cpp}
float melody[28][2] = {
  {c4, 4}, {c4, 4}, {g4, 4}, {g4, 4},
  {a4, 4}, {a4, 4}, {g4, 2},
  {f4, 4}, {f4, 4}, {e4, 4}, {e4, 4},
  {d4, 4}, {d4, 4}, {c4, 2},
  {g4, 4}, {g4, 4}, {f4, 4}, {f4, 4},
  {e4, 4}, {e4, 4}, {d4, 2},
  {g4, 4}, {g4, 4}, {f4, 4}, {f4, 4},
  {e4, 4}, {e4, 4}, {d4, 2},
};
\end{minted}

Как можно видеть, теперь каждый элемент массива -- это по сути одномерный массив
из двух элементов, записанный в фигурных скобках. Например, элемент номер ноль
нашего массива \texttt{melody} содержит массив \texttt{\{c4, 4\}} -- частота ноты
и её длительность.

Теперь мы можем адаптировать код воспроизведения мелодии под наши задачи:

\begin{minted}{cpp}
// ...

void loop() {
  const long BPM = 120;
  const long MINUTE = 60 * 1000000;
  const long T = (MINUTE / BPM) * 4;

  for (int note_idx = 0; note_idx < 28; note_idx++) {
    play_tone(SPEAKER_PIN,
              melody[note_idx][0],
              T / melody[note_idx][1]);
    delay(100);
  }
}
\end{minted}

Используя двумерные массивы, можно кратко и ёмко описать мелодию, даже намного
более сложную, чем ``Twinkle, Twinkle, Little Star''.

На этом этапе нам необходимо разобрать, как же работает \emph{нотный стан}
(называемый также \emph{нотоносцем}), на котором располагаются ноты -- для того,
чтобы уметь самостоятельно определять, где какая нота (частота) находится.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Получение размера массива}
\index{Программирование!Массив!Получение размера}

Наша реализация мелодии имеет сейчас существенный недостаток: мы вручную
подсчитываем количество нот мелодии и указываем размер массива при объявлении.
Например, в мелодии, которую мы обсуждали в предыдущем разделе, 28 нот.  Чем
больше нот в мелодии, тем более трудоёмкой становится задача подсчёта размера
массива.

На самом деле, мы можем не указывать размерность в первой паре квадратных скобок
в массива -- поскольку мы задаём элементы явно, сразу при объявлении массива, то
компьютер способен сам посчитать, сколько необходимо выделить памяти под массив.
Таким образом, мы можем написать так:

\begin{minted}{cpp}
  float melody[][2] = {
    {c4, 4}, {c4, 4}, {g4, 4}, {g4, 4},
    {a4, 4}, {a4, 4}, {g4, 2},
    {f4, 4}, {f4, 4}, {e4, 4}, {e4, 4},
    {d4, 4}, {d4, 4}, {c4, 2},
    {g4, 4}, {g4, 4}, {f4, 4}, {f4, 4},
    {e4, 4}, {e4, 4}, {d4, 2},
    {g4, 4}, {g4, 4}, {f4, 4}, {f4, 4},
    {e4, 4}, {e4, 4}, {d4, 2},
  };
\end{minted}

Можно видеть, что здесь не указано количество строк массива.

Однако это всё ещё не избавляет нас от необходимости подсчитывать количество
нот, так как мы должны использовать это значение для перебора массива в цикле:

\begin{minted}{cpp}
  void loop() {
    const long BPM = 120;
    const long MINUTE = 60000000;
    const long T = (MINUTE / BPM) * 4;

    for (int note_idx = 0; note_idx < 28; note_idx++) {
      play_tone(SPEAKER_PIN,
                melody[note_idx][0],
                T / melody[note_idx][1]);
      delay(100);
    }
  }
\end{minted}

Но и здесь у нас есть возможность переложить труд по подсчёту нот на компьютер --
это можно сделать с помощью процедуры \texttt{sizeof}.  Данная процедура
возвращает количество байт, которые занимает переданный ей объект в памяти
компьютера.

Чтобы узнать количество элементов в массива, мы должны с помощью \texttt{sizeof}
узнать его размер (в байтах) и затем поделить это значение на размер одного
элемента массива (в байтах) -- мы будем брать нулевой элемент:

\begin{minted}{cpp}
  int n = sizeof(melody) / sizeof(melody[0]);
\end{minted}

Далее полученное значение можно использовать в цикле:

\begin{minted}{cpp}
  void loop() {
    const long BPM = 120;
    const long MINUTE = 60000000;
    const long T = (MINUTE / BPM) * 4;

    int n = sizeof(melody) / sizeof(melody[0]);
    for (int note_idx = 0; note_idx < n; note_idx++) {
      play_tone(SPEAKER_PIN,
                melody[note_idx][0],
                T / melody[note_idx][1]);
      delay(100);
    }
  }
\end{minted}

Теперь компьютер будет считать количество нот автоматически, что избавляет нас
от необходимости это делать вручную, и можно теперь сосредоточится на
программировании мелодий.

\end{document}
