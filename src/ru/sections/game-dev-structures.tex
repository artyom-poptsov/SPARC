\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Структуры}
\index{Программирование!Структуры}

При разработке таких комплексных проектов, как компьютерные игры, важно
поддерживать структуированность кода.  Мы уже видим, что некоторые из
вспомогательных процедур игры принимают по два, а то и более параметров.  Кроме
того, мы уже оперируем такими сложными сущностями, как ``Игрок'', ``Игровая
карта'', ``Игровой объект'' и т.п.

В таких условиях передача разрозненных переменных, обозначающих какой-то
конкретный объект, в процедуры, уже не выглядит хорошей идеей.  Лучше было бы
объединить, например, координаты игрока и его очки здоровья в некий комплексный
объект, который целиком передавать в процедуры для обработки.

К счастью, у нас есть способ это сделать -- с помощью \emph{структур}.  Структура
есть спецальный тип переменной, который позволяет хранить внутри неё несколько
разнотипных значений.  Это похоже на обычный массив, однако если в массиве все
элементы принадлежат одному типу, то в стурктуре можно использовать несколько
разных типов для полей.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Объявление}
\index{Программирование!Структуры!Объявление}

Например, структура, которая описывает игрока, может выглядить вот так:

\begin{listing}[H]
  \begin{minted}{cpp}
    struct player {
      int x;
      int y;
      char image;
      byte hp;
    };
  \end{minted}
  \caption{Описание игрока в виде структуры.}
  \label{listing:game-dev-structure}
\end{listing}

Переменные \texttt{x}, \texttt{y}, \texttt{image} и \texttt{hp} являются
\emph{полями} структуры -- они как бы описывают \emph{свойства} объекта.

Объявить структуру можно, например, где-то в глобальной области, за пределами
процедур нашей программы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Создание и инициализация структур}
\index{Программирование!Структуры!Создание и инициализация}

Чтобы создать игрока, мы должны создать \emph{экземпляр} структуры.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Создание переменной "p",
    // хранящей экземпляр структуры "player":
    struct player p;
  \end{minted}
  \caption{Создание экземпляра структуры.}
  \label{listing:game-dev-structure-instance}
\end{listing}

При создании переменной мы должны её инициализировать.  Со структурами дело
обстоит также -- и мы можем выполнить инициализацию сразу при создании экземпляра
структуры:

\begin{listing}[H]
  \begin{minted}{cpp}
    // Создание переменной "p",
    // хранящей экземпляр структуры "player":
    struct player p = {
      0,   // x
      0,   // y
      '@', // image
      100  // HP
    };
  \end{minted}
  \caption{Инициализация экземпляра структуры при объявлении.}
  \label{listing:game-dev-structure-instance-init}
\end{listing}

Важно отметить, что задание значений для полей структуры должно выполняться в
том же порядке, в каком они перечислены в описании структуры.  Обратите внимание
на комментарии возле значений в листинге
\ref{listing:game-dev-structure-instance-init} -- они добавлены специально, чтобы
не перепутать порядок значений.  Это, например, позволяет избежать ситуации,
когда у нас очки здоровья внезапно окажутся кодом символа изображения игрока.

Чтобы решить проблему очередности задания значений, можно воспользоваться
следующим синтаксисом:

\begin{listing}[H]
  \begin{minted}{cpp}
    // Создание переменной "p",
    // хранящей экземпляр структуры "player":
    struct player p = {
      .x     = 0,
      .y     = 0,
      .image = '@',
      .hp    = 100
    };
  \end{minted}
  \caption{Инициализация экземпляра структуры при объявлении, с указанием имён
    полей.}
  \label{listing:game-dev-structure-instance-init-names}
\end{listing}

Способ, показанный в листинге
\ref{listing:game-dev-structure-instance-init-names} позволяет задавать значения
для полей структуры в произвольном порядке, указывая названия полей явно.  При
этом, отпадает необходимость в добавлении комментариев к значением, т.к. по
названию полей можно понять, какое значение что обозначает.  К сожалению, данный
способ не поддерживается на некоторых платформах, в частности, на Arduino.

Ещё одним способом инициализации может быть присвоение значений полям структуры
уже после создания её экземпляра.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Создание переменной "p",
    // хранящей экземпляр структуры "player":
    struct player p;

    void setup() {
      // Задание значений для полей структуры:
      p.x = 0;
      p.y = 0;
      p.hp = 100;
      p.image = '@';
    }
  \end{minted}
  \caption{Задание значений для полей структуры после её создания.}
  \label{listing:game-dev-structure-assignment}
\end{listing}

Обращение к полям структуры производится по именам, которые пишутся через точку.
Точка разделяет имя переменной, хранящей структуру, и поле, к которому идёт
обращение.  Как и в случае с обычными переменными, мы можем присваивать значения
полям структуры и подставлять значения полей в выражения.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ключевое слово ``typedef''}
\index{Программирование!typedef}

В языке C и C++ существует специальное ключевое слово \texttt{typedef}, которое
позволяет создавать краткие и более ёмкие имена для сущетсвующих типов и
структур.

Это особенно полезно при работе со структурами.  Благодаря \texttt{typedef} мы
можем избавить себя от необходимости писать каждый раз ключевое слово
\texttt{struct} при объявлении переменных с типом структуры.

\begin{listing}[H]
  \begin{minted}{cpp}
    struct player {
      int x;
      int y;
      char image;
      byte hp;
    };

    // Создание краткого имени для структуры:
    typedef struct player player_t;

    // Объявление переменной с типом "player_t":
    player_t p;

    void setup() {
      // Задание значений для полей структуры:
      p.x = 0;
      p.y = 0;
      p.hp = 100;
      p.image = '@';
    }

    // ...
  \end{minted}
  \caption{Пример использования ключевого слова \texttt{typedef}.}
  \label{listing:game-dev-structure-typedef}
\end{listing}

В листинге \ref{listing:game-dev-structure-typedef} показано, что для структуры,
описывающей игрока, мы можем задать краткое имя \texttt{player\_t}.

Часто используемым соглашением по именованию новых типов в языке C является
добавление нижнего подчёркивания с буквой ``t'' в конце (от слова ``type'' --
``тип''.)  Мы также будем придерживаться этого стиля далее.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Вложенные структуры}
\index{Программирование!Структуры!Вложенные структуры}

Порой сущность, которую мы хотим описать в виде структуры, является достаточно
сложным, что даёт повод поделить его на несколько более простых сущностей.

В нашем случае, мы можем отдельно описать сущность ``Точка'' (``Point''), как
отдельную структуру.  Это позволит нам объединить разрозненные ``x'' и ``y'' в
один объект и передавать его.

\begin{listing}[H]
  \begin{minted}{cpp}
    struct point {
      int x;
      int y;
    };

    typedef struct point point_t;

    struct player {
      point_t position;
      char image;
      byte hp;
    };

    typedef struct player player_t;
  \end{minted}
  \caption{Описание вложенных структур.}
  \label{listing:game-dev-nested-structures}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Передача структуры в процедуру}
\index{Программирование!Структуры!Использование}

Теперь, когда у нас появились структуры, мы можем сделать код игры более удобным
и читаемым. Например, вместо того, чтобы передавать отдельно координаты
\texttt{x},\texttt{y} в процедуры проверки наличия объекта на карте, мы можем
туда передавать экземпляр структуры ``точка'' (``point''.)

\begin{listing}[H]
  \begin{minted}{cpp}
    // Структура, описывающая точку на игровой карте.
    struct point {
      int x;
      int y;
    };

    typedef struct point point_t;

    // Функция, возвращающая 1 (true) в случае, если
    // на клетке карты в точке point находится ключ.
    // В противном случае функция возвращает 0 (false).
    bool is_key(point_t point) {
      return game_map[point.y][point.x] == KEY;
    }
  \end{minted}
  \caption{Использование структуры для упрощения кода игры.}
  \label{listing:game-dev-structure-usage-00}
\end{listing}

В листинге \ref{listing:game-dev-structure-usage-00} можно видеть, что процедура
\texttt{is\_key} переписана таким образом, чтобы принимать экземпляр структуры.

Однако есть важный момент, который часто приходится учитывать: при передаче
экземпляра структуры в процедуру, как было показано выше, данный экземпляр
\emph{копируется}, и внутри процедуры оказывается \emph{копия} структуры.
Причём, по завершению процедуры, копия структуры уничтожается, как и все
локальные переменные внутри процедуры.  Кроме того, копирование приводит к
дополнительному расходу памяти и замедляет вызов процедуры.

Одним из важных следствий из вышесказанного является то, что если мы попытаемся
изменить значения структуры внутри процедуры, у нас ничего не получится, ведь за
пределами процедуры структура не поменяется.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Ошибочное опредение процедуры,
    // изменяющей значения внутри структуры.
    move(point_t point, int dx, int dy) {
      point.x += dx;
      point.y += dy;
    }

    void loop() {
      // ...

      point_t point = { 10, 20 };
      move(point, 5, 5);

      // Здесь мы обнаружим, что координаты точки
      // всё ещё 10, 20, вместо ожидаемых 15, 25.

      // ...
    }
  \end{minted}
  \caption{Ошибочная попытка изменить значения структуры внутри процедуры.}
  \label{listing:game-dev-structure-usage-01}
\end{listing}

\end{document}
