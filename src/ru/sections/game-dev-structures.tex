\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Структуры}
\index{Программирование!Структуры}

При разработке таких комплексных проектов, как компьютерные игры, важно
поддерживать структуированность кода.  Мы уже видим, что некоторые из
вспомогательных процедур игры принимают по два, а то и более параметров.  Кроме
того, мы уже оперируем такими сложными сущностями, как ``Игрок'', ``Игровая
карта'', ``Игровой объект'' и т.п.

В таких условиях передача разрозненных переменных, обозначающих какой-то
конкретный объект, в процедуры, уже не выглядит хорошей идеей.  Лучше было бы
объединить, например, координаты игрока и его очки здоровья в некий комплексный
объект, который целиком передавать в процедуры для обработки.

К счастью, у нас есть способ это сделать -- с помощью \emph{структур}.  Структура
есть спецальный тип переменной, который позволяет хранить внутри неё несколько
разнотипных значений.  Это похоже на обычный массив, однако если в массиве все
элементы принадлежат одному типу, то в стурктуре можно использовать несколько
разных типов для полей.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Объявление}
\index{Программирование!Структуры!Объявление}

Например, структура, которая описывает игрока, может выглядить вот так:

\begin{listing}[H]
  \begin{minted}{cpp}
    struct player {
      int x;
      int y;
      char image;
      byte hp;
    };
  \end{minted}
  \caption{Описание игрока в виде структуры.}
  \label{listing:game-dev-structure}
\end{listing}

Переменные \texttt{x}, \texttt{y}, \texttt{image} и \texttt{hp} являются
\emph{полями} структуры -- они как бы описывают \emph{свойства} объекта.

Объявить структуру можно, например, где-то в глобальной области, за пределами
процедур нашей программы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Создание и инициализация структур}
\index{Программирование!Структуры!Создание и инициализация}

Чтобы создать игрока, мы должны создать \emph{экземпляр} структуры.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Создание переменной "p",
    // хранящей экземпляр структуры "player":
    struct player p;
  \end{minted}
  \caption{Создание экземпляра структуры.}
  \label{listing:game-dev-structure-instance}
\end{listing}

При создании переменной мы должны её инициализировать.  Со структурами дело
обстоит также -- и мы можем выполнить инициализацию сразу при создании экземпляра
структуры:

\begin{listing}[H]
  \begin{minted}{cpp}
    // Создание переменной "p",
    // хранящей экземпляр структуры "player":
    struct player p = {
      0,   // x
      0,   // y
      '@', // image
      100  // HP
    };
  \end{minted}
  \caption{Инициализация экземпляра структуры при объявлении.}
  \label{listing:game-dev-structure-instance-init}
\end{listing}

Важно отметить, что задание значений для полей структуры должно выполняться в
том же порядке, в каком они перечислены в описании структуры.  Обратите внимание
на комментарии возле значений в листинге
\ref{listing:game-dev-structure-instance-init} -- они добавлены специально, чтобы
не перепутать порядок значений.  Это, например, позволяет избежать ситуации,
когда у нас очки здоровья внезапно окажутся кодом символа изображения игрока.

Чтобы решить проблему очередности задания значений, можно воспользоваться
следующим синтаксисом:

\begin{listing}[H]
  \begin{minted}{cpp}
    // Создание переменной "p",
    // хранящей экземпляр структуры "player":
    struct player p = {
      .x     = 0,
      .y     = 0,
      .image = '@',
      .hp    = 100
    };
  \end{minted}
  \caption{Инициализация экземпляра структуры при объявлении, с указанием имён
    полей.}
  \label{listing:game-dev-structure-instance-init-names}
\end{listing}

Способ, показанный в листинге
\ref{listing:game-dev-structure-instance-init-names} позволяет задавать значения
для полей структуры в произвольном порядке, указывая названия полей явно.  При
этом, отпадает необходимость в добавлении комментариев к значением, т.к. по
названию полей можно понять, какое значение что обозначает.  К сожалению, данный
способ не поддерживается на некоторых платформах, в частности, на Arduino.

Ещё одним способом инициализации может быть присвоение значений полям структуры
уже после создания её экземпляра.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Создание переменной "p",
    // хранящей экземпляр структуры "player":
    struct player p;

    void setup() {
      // Задание значений для полей структуры:
      p.x = 0;
      p.y = 0;
      p.hp = 100;
      p.image = '@';
    }
  \end{minted}
  \caption{Задание значений для полей структуры после её создания.}
  \label{listing:game-dev-structure-assignment}
\end{listing}

Обращение к полям структуры производится по именам, которые пишутся через точку.
Точка разделяет имя переменной, хранящей структуру, и поле, к которому идёт
обращение.  Как и в случае с обычными переменными, мы можем присваивать значения
полям структуры и подставлять значения полей в выражения.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ключевое слово ``typedef''}
\index{Программирование!typedef}

В языке C и C++ существует специальное ключевое слово \texttt{typedef}, которое
позволяет создавать краткие и более ёмкие имена для сущетсвующих типов и
структур.

Это особенно полезно при работе со структурами.  Благодаря \texttt{typedef} мы
можем избавить себя от необходимости писать каждый раз ключевое слово
\texttt{struct} при объявлении переменных с типом структуры.

\begin{listing}[H]
  \begin{minted}{cpp}
    struct player {
      int x;
      int y;
      char image;
      byte hp;
    };

    // Создание краткого имени для структуры:
    typedef struct player player_t;

    // Объявление переменной с типом "player_t":
    player_t p;

    void setup() {
      // Задание значений для полей структуры:
      p.x = 0;
      p.y = 0;
      p.hp = 100;
      p.image = '@';
    }

    // ...
  \end{minted}
  \caption{Пример использования ключевого слова \texttt{typedef}.}
  \label{listing:game-dev-structure-typedef}
\end{listing}

В листинге \ref{listing:game-dev-structure-typedef} показано, что для структуры,
описывающей игрока, мы можем задать краткое имя \texttt{player\_t}.

Часто используемым соглашением по именованию новых типов в языке C является
добавление нижнего подчёркивания с буквой ``t'' в конце (от слова ``type'' --
``тип''.)  Мы также будем придерживаться этого стиля далее.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Вложенные структуры}
\index{Программирование!Структуры!Вложенные структуры}

Порой сущность, которую мы хотим описать в виде структуры, является достаточно
сложным, что даёт повод поделить его на несколько более простых сущностей.

В нашем случае, мы можем отдельно описать сущность ``Точка'' (``Point''), как
отдельную структуру.  Это позволит нам объединить разрозненные ``x'' и ``y'' в
один объект и передавать его.

\begin{listing}[H]
  \begin{minted}{cpp}
    struct point {
      int x;
      int y;
    };

    typedef struct point point_t;

    struct player {
      point_t position;
      char image;
      byte hp;
    };

    typedef struct player player_t;
  \end{minted}
  \caption{Описание вложенных структур.}
  \label{listing:game-dev-nested-structures}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Использование структур}
\index{Программирование!Структуры!Использование}

Теперь, когда у нас появились структуры, мы можем сделать код игры более удобным
и читаемым. Например, вместо того, чтобы передавать отдельно координаты
\texttt{x},\texttt{y} в процедуры проверки наличия объекта на карте, мы можем
туда передавать экземпляр структуры ``точка'' (``point''.)

\begin{listing}[H]
  \begin{minted}{cpp}
    // Структура, описывающая точку на игровой карте.
    struct point {
      int x;
      int y;
    };

    typedef struct point point_t;

    // Функция, возвращающая 1 (true) в случае, если
    // на клетке карты в точке point находится ключ.
    // В противном случае функция возвращает 0 (false).
    bool is_key(point_t point) {
      return game_map[point.y][point.x] == KEY;
    }
  \end{minted}
  \caption{Использование структуры для упрощения кода игры.}
  \label{listing:game-dev-structure-usage-00}
\end{listing}

В листинге \ref{listing:game-dev-structure-usage-00} можно видеть, что процедура
\texttt{is\_key} переписана таким образом, чтобы принимать экземпляр структуры.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Передача структуры по указателю}
\index{Программирование!Структуры!Передача по указателю}

Есть важный момент, который часто приходится учитывать: при передаче экземпляра
структуры в процедуру, как было показано выше, данный экземпляр
\emph{копируется}, и внутри процедуры оказывается \emph{копия} структуры.
Причём, по завершению процедуры, копия структуры уничтожается, как и все
локальные переменные внутри процедуры.  Кроме того, копирование приводит к
дополнительному расходу памяти и замедляет вызов процедуры.

Одним из важных следствий из вышесказанного является то, что если мы попытаемся
изменить значения структуры внутри процедуры, у нас ничего не получится, ведь за
пределами процедуры структура не поменяется.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Ошибочное опредение процедуры,
    // изменяющей значения внутри структуры.
    move(point_t point, int dx, int dy) {
      point.x += dx;
      point.y += dy;
    }

    void loop() {
      // ...

      point_t point = { 10, 20 };
      move(point, 2, 4);

      // Здесь мы обнаружим, что координаты точки
      // всё ещё 10, 20, вместо ожидаемых 12, 24.

      // ...
    }
  \end{minted}
  \caption{Ошибочная попытка изменить значения структуры внутри процедуры.}
  \label{listing:game-dev-structure-usage-01}
\end{listing}

Одним из простых решений данной проблемы является вынос экземпляра структуры в
глобальную область, вместо передачи его в процедуру -- это позволит работать с
данным экземпляром, как и с любой глобальной переменной.  Но этот вариант имеет
существенные недостатки.  Например, как и в случае с любой глобальной
переменной, глобальный экземпляр структуры будет постоянно ``мешаться под
руками'', провоцируя ошибки и перегружая код лишними глобальными именами.  Ведь
чем больше глобальных переменных у нас в коде, тем менее красивый наш код.

\index{Программирование!Указатели}
Правильное же решениее данной проблемы требует от нас изучения дополнительной
темы, которую мы игнорировали до текущего момента.  Если мы хотим изменять поля
структуры внутри процедуры, нам необходимо передавать саму структуру вместо её
копии. Это можно сделать, передав в функцию \emph{указатель}.  Под термином
\emph{указатель} мы понимаем некоторую переменную, хранящую \emph{адрес памяти},
по которому располагается другая переменная.

Указатели и работа с памятью является очень важной темой при изучении таких
низкоуровневых языков программирования, как C и C++.  Про указатели мы подробно
будем говорить позже, а пока надо разобраться лишь с базовым их использованием.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Процедура, изменяющая позицию точки.
    move(point_t* point, int dx, int dy) {
      //        ^
      //        |
      //        `---- Указатель на "point_t"
      point->x += dx;
      point->y += dy;
    }

    void loop() {
      // ...

      point_t point = { 10, 20 };
      move(&point, 2, 4);
      //   ^
      //   |
      //   `------- Получение адреса переменной "point"

      // После завершения процедуры "move",
      // координаты точки будут 12, 24.

      // ...
    }
  \end{minted}
  \caption{Передача указателя на экземпляр структуры внутрь процедуры.}
  \label{listing:game-dev-structure-usage-02}
\end{listing}

В листинге \ref{listing:game-dev-structure-usage-02} можно увидеть
модифицированный пример, где мы во-первых изменили процедуру \texttt{move} таким
образом, чтобы она примала \emph{указатель} на структуру \texttt{point\_t}.
Следует обратить внимание на то, что для параметра \texttt{point} тип указан,
как \texttt{point\_t*}.  Звёздочка возле типа данных говорит нам о том, что
ожидается указатель на объект данного типа.

Внутри процедуры \texttt{move} мы также заменили точки на стрелочки (``->'') при
обращении к полям процедуры -- это необходимо потому, что теперь мы работаем с
указателем на структуру, и надо ``дотянуться'' до её полей, перейдя по указателю
на адрес, на который он указывает.

При вызове процедуры \emph{move} мы можем заметить, что перед переменной
\emph{point} стоит знак амперсанда (``\&'') -- это означает, что мы
\emph{получаем адрес} переменной, перед которой стоит амперсанд.  Этот адрес как
раз и передаётся внутрь процедуры \emph{move}, как значение первого параметра.

\end{document}
