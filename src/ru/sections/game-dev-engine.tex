\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Создание игрового движка}
\index{Разработка игр!Игровой движок}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Что такое ``Игровой движок''?}
В разработке игр со временем у программистов собирается набор необходимых
процедур и типов данных (структур), которые были созданы специально для
упрощения работы над игрой.  Используя эти специализированные инструменты, мы
можем быстро развивать логику игры, без необходимости снова и снова обращаться к
низкоуровневым механизмам, вроде рисования пикселей на экране, алгоритами
движения объектов по карте и т.п.

Когда команда разработчиков сталкивается с необходимостью создавать новую версию
игры, или даже совершенно новую игру -- часто оказывается, что базовые задачи уже
были решены в предыдущей игре.  Не удивительно, ведь работа с игровой картой,
отрисовка текстур, воспроизведение звуков и просчитываение физики существуют во
многих играх.  Зачем же повторять сделанную работу, если мы можем обратиться к
уже созданным процедурам и структурам данных?

Таким образом, мы приходим к тому, чтобы создать свой \emph{игровой движок} --
библиотеку функций и типов, созданных специально для разработки игр.  Даже если
мы будем применять наш движок только для одной игры, это даст нам преимущество в
плане модульности и упорядоченности нашего кода.

На базовом уровне, разработка игрового движка сводится к выносу наших типов
данных и процедур в отдельные файлы.  Это уже следующий уровень модульности --
сначала мы делили логику на процедуры, теперь будем группировать эти процедуры
по отдельным файлам, согласно их назначанию.

Чтобы понять, как правильно сделать это разделение нашего проекта на файлы, мы
должны разобраться с тем, что из себя представляет процесс сборки нашего проекта
в единый исполняемый файл.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Этапы сборки приложения}

До этого мы рассматривали сборку приложения, как некий неделимый процесс --
нажимаем на кнопку загрузки в интерфейсе Arduino IDE, и вот уже компьютер делает
какие-то действия с кодом нашего проекта, затем загружает программу в Arduino и
наконец мы получаем долгожданный мигающий светодиод.  Но не всё так просто, как
кажется на первый взгляд.

Конечно мы уже сталкивались с ситуациями, когда проект не собирался из-за
синтаксических ошибок в нашем коде -- забытые скобки и точки с запятыми дают о
себе знать уже на ранних этапах сборки.  В этом случае мы могли видеть в Arduino
IDE сообщения (порой, пугающие начинающих программистов) об ошибках.  Теперь
пришло время приподнять занавес тайны над процессом компиляции и посмотреть
внутрь.

В самом начале компьютер начинает работать с тем исходным кодом, который был
нами написан.  Важно понимать, что компьютер (точнее, его процессор) не понимает
напрямую наш язык программирования, и требуется специальный ``переводчик'' с
промежуточного языка (то есть, языка программирования) на низкоуровневые
машинные команды.  Однако это -- достаточно сложный процесс, который может быть
разбит на несколько основных этапов, как показано на
рис. \ref{fig:build-process}.

\figureBuildSteps{ru}

\subsubsection{Препроцессор}

Первым делом, исходный код (файл \texttt{main.ino}) обрабатывается
\emph{препроцессором} -- специальной программой.  На этом этапе из исходного кода
удаляются комментарии и обрабатываются \emph{директивы препроцессора} (также
называемые иногда \emph{командами препроцессора}.)  В языках C/C++ язык
пропроцессора является отдельным языком программирования, с достаточно
примитивным набором команд, который описывает операции, которые препроцессор
должен сделать с исходным кодом.

По своей сути, препроцессор оперирует тремя базовыми инструментами: удаление
кода, копирование и вставка.

Например, как мы уже говорили выше, комментарии (все строчки, которые начинаются
с двух прямых слэшей, или строчки. насположенные между \mintinline{cpp}{/*
  ... */}) удаляются и не проходят на дальнейшие этапы сборки.

Другими популярными директивами препроцессора, которые мы можем встретить,
являются команды \mintinline{cpp}{#include} и \mintinline{cpp}{#define}.

Команда \mintinline{cpp}{#define} обычно используется в таком ключе:

\begin{listing}[H]
  \begin{minted}[highlightlines={1, 8, 10}]{cpp}
    #define DELAY_TIME 100
    void setup() {
      pinMode(2, OUTPUT);
    }

    void loop() {
      digitalWrite(2, HIGH);
      delay(DELAY_TIME);
      digitalWrite(2, LOW);
      delay(DELAY_TIME);
    }
  \end{minted}
  \label{listing:preprocessor-define-example-1}
  \caption{Пример использования директивы препроцессора
    \mintinline{cpp}{#define} для задания константы.}
\end{listing}

В листинге \ref{listing:preprocessor-define-example-1} мы видим пример
использования \mintinline{cpp}{#define} для задания именованной константы
\mintinline{cpp}{DELAY_TIME}, определяющей время задержки между включением и
выключением светодиода.  В процедуре \mintinline{cpp}{loop} данная константа
подставляется в качестве значения задержки при вызове процедуры
\mintinline{cpp}{delay}.

Когда препроцессор встречает константу, определённую ранее через
\mintinline{cpp}{#define}, то он заменяет имя константы на фактическое её
значение.  Тут важно понимать, что препроцессор не делает почти никаких проверок
о корректности результата подстановки значения константы.  Таким образом, в
результате неправильного задания константы препроцессор подставить её значение
везде в коде, где константа упоминается, но на более поздних этапах сборки
произойдёт ошибка.

Кроме этого, мы можем видеть на первой строчке в листинге
\ref{listing:preprocessor-define-example-1}, что при объявлении подобной константы
мы не используем уже привычные нам типы данных, и даже не ставим в конце
вездесущую точку с запятой; более того, завершение строчки с
\mintinline{cpp}{#define} точкой с запятой приведёт впоследствии к ошибке.

Возникает вопрос: стоит ли использовать \mintinline{cpp}{#define}, когда у нас
есть ключевое слово \mintinline{cpp}{const}?  Ведь с тем же успехом мы могли бы
написать:

\begin{listing}[H]
  \begin{minted}[highlightlines={1}]{cpp}
    const int DELAY_TIME = 100;
    void setup() {
      pinMode(2, OUTPUT);
    }

    void loop() {
      digitalWrite(2, HIGH);
      delay(DELAY_TIME);
      digitalWrite(2, LOW);
      delay(DELAY_TIME);
    }
  \end{minted}
  \label{listing:preprocessor-define-example-2}
  \caption{Пример задания обычной константы.}
\end{listing}

Действительно, запись, показанная в листинге
\ref{listing:preprocessor-define-example-2} имеет много преимуществ перед
листингом \ref{listing:preprocessor-define-example-1}, где мы использовали
\mintinline{cpp}{#define}.  Например, заданная нами через
\mintinline{cpp}{const} константа имеет типизацию (тип данных
\mintinline{cpp}{int}), и при сборке подобного кода происходят все необходимые
проверки корректности синтаксиса (в отличии от \mintinline{cpp}{#define}.)  По
этой причине в большинстве случаев использование обычных констант
предпочтительнее, чем использование \mintinline{cpp}{#define}.

Но не стоит сразу списывать использование директив препроцессора со счетов --
ведь существуют случаи, когда использование препроцессора допустимо, и даже
необходимо.  Дело в том, что препроцессор выполняет операции именно над исходным
кодом программы, и таким в дальнейшую компиляцию попадает уже обработанный код.
Если мы посмотрим на промежуточное состояние нашего кода на C/C++ после работы
препроцессора, то не увидим там упоминания \mintinline{cpp}{DELAY_TIME},
заданного через \mintinline{cpp}{#define} -- вместо этого, на тех местах, где мы
на данную константу ссылались, будет уже стоять её значение (100).

Другой полезной для нас директивой проепроцессора является
\mintinline{cpp}{#include} -- данная директива инструктирует препроцессор
скопировать и вставить на её место содержимое того файла, на который она
ссылается.

\subsubsection{Транслятор}

После препроцессора в работу вступает \emph{транслятор} -- его задачей является
преобразование высокоуровневого языка программирования (C/C++) в низкоуровневый
\emph{язык ассемблера}.  На данном этапе выявляются \emph{синтаксические
ошибки}, вроде пропущенных скобок и точек с запятыми, ссылок на несуществующие
переменные и т.п.

Получившийся код всё ещё может быть относительно легко прочитан (и даже изменён)
человеком, но он уже написан на гораздо более ``примитивном'' уровне.  После
этого, до машинного (двоичного) кода остаётся один шаг.

Код на ассемблере уже сильно зависим от процессора, под который идёт сборка -- у
разных процессоров может быть разный набор команд.  Говорят, что такой код
\emph{платформо-зависимый}.

\subsubsection{Ассемблер}

Далее в работу вступает программа-ассемблер.  Данная программа берёт код на
языке ассемблера и транслирует его в машинные команды -- непосредственно
низкоуровневые команды процессора, под который идёт сборка.

Результатом работы ассемблера является \emph{объектный файл} -- по сути, это файл
с машинным кодом.  Данный файл ещё не является \emph{исполняемым}, хотя внутри
него уже команды, которые процессор может прочитать и выполнить.

\subsubsection{Линковщик}

В конце исполняемый файл приложения собирается из нескольких ``кусочков'' --
объектных файлов приложения и сторонних библиотек.  Эту ``склейку'' паззла
проводит программа, называемая \emph{линковщиком} (или, буквально,
``связывателем''.)

В случае с Arduino, получившийся двоичный файл загружается на плату для
исполнения.

\end{document}
