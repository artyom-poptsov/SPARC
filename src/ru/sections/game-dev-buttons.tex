\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Реализация управления}
\index{Разработка игр!Управление}
\label{section:game-dev-controls}

Для управления игровым персонажем нам потребуется некоторое устройство ввода
информации в наш компьютер (микроконтроллер).  Мы сделаем своё ``устройство
ввода'', состоящее из нескольких кнопок, расположенных на макетной плате.

\subsection{Подключение кнопки}
\index{Разработка игр!Подключение кнопки}

Попробуем подключить кнопку к Arduino.  Кнопка по своей сути не более чем
замыкатель двух контактов.  Самым простым аналогом кнопки являются два
разъединённых провода (разомкнутая электрическая цепь), которые можно соединить
между собой, или опять разъединить.  Само собой, такой способ управления
устройством неудобен (и даже небезопасен, при больших напряжениях и токах в
электрической цепи), поэтому кнопки обычно представлены некими закрытыми
устройствами, которые имеют некий способ замыкать цепь без необходимости брать в
руки концы проводов.

Кнопки по принципу работы бывают разные.  Самый простой их вид -- \emph{тактовые
кнопки}.

``Тактовыми'' называются кнопки, которые не ``запоминают'' своё состояние, и
сразу же после нажатия возвращаются в исходное состояние (как правило,
разомкнутое.)

Другой вид кнопок, с которыми мы сталкиваемся в быту -- это те, которые
``запоминают'' своё состояние; такие кнопки обычно называются
``переключателями''.

На рис. \ref{fig:game-dev-button-00} можно видеть один из возможных вариантов
подключения кнопки.  Можно подумать, что такой вариант достаточен -- когда кнопка
нажата, то цепь замыкается и ток идёт от \texttt{5V} до цифрового порта номер 2.
И действительно, в этом случае с порта можно считать значение 1 (\texttt{HIGH}).

\figureButtonCircuit{ru}

Пример простейшей программы, считывающей значение с кнопки, представлен ниже.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT);
    }

    void loop() {
      // Считываем значение с кнопки и сохраняем
      // в новую переменную "value".
      int value = digitalRead(2);

      // Далее эту переменную можно использовать
      // в коде, чтобы определить состояние кнопки:
      // если в переменной находится значение 1,
      // то кнопка нажата, если 0 -- то не нажата.
    }
  \end{minted}
  \caption{Обработка нажатия кнопки.}
  \label{listing:button-00}
\end{listing}

Чтобы наглядно получить представление о том, как значение на кнопке будет
меняться при нажатии, мы можем добавить вывод данных на компьютер.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT);
      Serial.begin(9600);
    }

    void loop() {
      // Считываем значение с кнопки и сохраняем
      // в новую переменную "value".
      int value = digitalRead(2);

      // Далее эту переменную можно использовать
      // в коде, чтобы определить состояние кнопки:
      // если в переменной находится значение 1,
      // то кнопка нажата, если 0 -- то не нажата.

      // Выводим значение с кнопки в порт.
      Serial.println(value);
    }
  \end{minted}
  \caption{Обработка нажатия кнопки с выводом значения на компьютер.}
  \label{listing:button-01}
\end{listing}

К сожалению, наблюдение за значением на кнопке скорее всего нам покажет, что
даже когда кнопка не нажата, на ней иногда ``проскакивает'' значение 1.  Как
такое может быть?  Объяснение простое -- как мы видели в главе ``Белый шум'',
вокруг нас присутствует электромагнитный фон, который улавливается схемами и
приводит к тому, что иногда значение на цифровых портах переходит рубеж, после
которого Arduino считает это значение единицей.

Решить эту проблему можно как минимум двумя способами.  Первый способ
заключается в том, чтобы поставить специальный \emph{подтягивающий резистор},
который будет подтягивать значение на порту, куда подключена кнопка, к земле
(GND.)

\figureButtonPulldownResistorCircuit{ru}

Второй способ подключения кнопки -- использование встроенного в Arduino
подтягивающего резистора, который подключен на 5V.  В этом случае схема
подключения значительно упрощается и становится похожа на то, что было показано
на рис. \ref{fig:game-dev-button-00}, но с одним отличием: цифровой порт должен
при нажатии на кнопку замыкаться не на \texttt{5V}, а на \texttt{GND}
(см. рис. \ref{fig:game-dev-button-with-pull-up-resistor}.)

\figureButtonPullupResistorCircuit{ru}

Настройка порта в этом случае должна производиться на режим
\texttt{INPUT\_PULLUP}.  В остальном же код нашего примера остаётся без
изменений.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT_PULLUP);
      Serial.begin(9600);
    }

    void loop() {
      // Считываем значение с кнопки и сохраняем
      // в новую переменную "value".
      int value = digitalRead(2);

      // Далее эту переменную можно использовать
      // в коде, чтобы определить состояние кнопки:
      // если в переменной находится значение 1,
      // то кнопка нажата, если 0 -- то не нажата.

      // Выводим значение с кнопки в порт.
      Serial.println(value);
    }
  \end{minted}
  \caption{Пример использования режима \texttt{INPUT\_PULLUP}.}
  \label{listing:game-dev-input-pullup-example}
\end{listing}

При таком использовании работа с кнопкой ``инвертируется'' -- когда она нажата,
то значение на порту будет ``0'' (\texttt{LOW}), а когда не нажата, то ``1''
(\texttt{HIGH}.)

\subsection{Обработка нажатий}
\index{Разработка игр!Подключение кнопки!Обработка нажатий}

Для начала зададим номер порта, куда подключена наша (пока единственная) кнопка,
в виде именованной константы \texttt{BUTTON\_R} (``R'' от слова ``Right'',
``Вправо''.)

\begin{listing}[H]
  \begin{minted}{cpp}
    #include <LiquidCrystal_I2C.h>

    LiquidCrystal_I2C lcd(0x27,  16, 2);

    // Кнопки управления.
    const char BUTTON_R = 2;      // Кнопка ``Вправо''

    const char PLAYER = '@';

    int player_x = 0;
    int player_y = 0;
  \end{minted}
  \caption{Задание констант для кнопок управления.}
  \label{listing:game-dev-button-constants}
\end{listing}

Далее в \texttt{setup} необходимо настроить режим работы порта для кнопки через
\texttt{pinMode}, как мы делали это в предыдущих примерах.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      lcd.init();
      lcd.backlight();

      // Настройка кнопок управления.
      pinMode(BUTTON_R, INPUT_PULLUP);
    }
  \end{minted}
  \caption{Настройка режима работы \texttt{INPUT\_PULLUP} цифрового порта.}
  \label{listing:game-dev-input-pullup-mode}
\end{listing}

После этого следует определиться, как мы будем обрабатывать нажатия кнопок.
Сейчас самым простым для нас способом обработки нажатий является поочерёдный
опрос кнопок, про другие способы мы с вами поговорим позднее.

Для обработки нажатий мы будем в \texttt{loop} проверять значение на порту, куда
подключена кнопка, используя уже знакомый нам \texttt{digitalRead}, и если
значение будет \texttt{LOW}, то менять позицию персонажа.

\begin{listing}[H]
  \begin{minted}{cpp}
    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        player_x++;
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);
    }
  \end{minted}
  \caption{Изменение позиции персонажа игры по нажатию кнопки ``ВПРАВО''.}
  \label{listing:game-dev-button-right}
\end{listing}

Таким образом, при нажатии кнопки ``ВПРАВО'' мы будем получать смещение
персонажа вправо.

В общем виде, код нашей игры на текущий момент выглядит так:

\begin{listing}[H]
  \begin{minted}{cpp}
    #include <LiquidCrystal_I2C.h>

    LiquidCrystal_I2C lcd(0x27,  16, 2);

    // Кнопки управления.
    const char BUTTON_R = 2;      // Кнопка ``Вправо''

    const char PLAYER = '@';

    int player_x = 0;
    int player_y = 0;

    void setup() {
      lcd.init();
      lcd.backlight();

      // Настройка кнопок управления.
      pinMode(BUTTON_R, INPUT_PULLUP);
    }

    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        player_x++;
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);
    }
  \end{minted}
  \caption{Полный пример реализации движения игрока вправо по кнопке.}
  \label{listing:game-dev-button-right-full-example}
\end{listing}

Здесь, однако же, кроется проблема -- при единичном (на наш взгляд) нажатии
кнопки, игрок может пробежать до конца карты, или даже скрыться за её пределами.
Это возникает, так как короткое (единичное) нажатие на кнопку с точки зрения
человека занимает огромное время с точки зрения компьютера.  За то время, пока
мы держим палец на кнопке, перед тем, как её отпустить, функция \texttt{loop}
успевает сработать несколько раз; следовательно, несколько раз будет считано и
обработано состояние кнопки.

Для борьбы с этой проблемой необходимо добавить короткую задержку (например, в
100мс) в конце \texttt{loop}:

\begin{listing}[H]
  \begin{minted}{cpp}
    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        player_x++;
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);

      // Задержка, чтобы избежать слишком быстрого
      // считывания нажатий на кнопки.
      delay(100);
    }
  \end{minted}
  \caption{Добавление задержки в \texttt{loop} для улучшения считывания кнопки.}
  \label{listing:game-dev-button-delay}
\end{listing}

Точно таким же образом мы можем добавить кнопку движения влево, слегка дополнив
код нашего примера.  Поскольку исходный код нашей игры будет дальше расти, для
краткости будем сокращать уже написанные части, акцентируя внимание на том, что
поменялось.

\begin{listing}[H]
  \begin{minted}{cpp}
    // ... Код подключения библиотеки и создания
    //     переменной "lcd". ...

    // Кнопки управления.
    const char BUTTON_R = 2;      // Кнопка "Вправо"
    const char BUTTON_L = 3;      // Кнопка "Влево"

    const char PLAYER = '@';

    // ... Код задания переменных позиции игрока. ...

    void setup() {
      // ... Код настройки дисплея. ...

      // Настройка кнопок управления.
      pinMode(BUTTON_R, INPUT_PULLUP);
      pinMode(BUTTON_L, INPUT_PULLUP);
    }

    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        player_x++;
      }
      if (digitalRead(BUTTON_L) == LOW) {
        player_x--;
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);

      // Задержка, чтобы избежать слишком быстрого
      // считывания нажатий на кнопки.
      delay(100);
    }
  \end{minted}
  \caption{Обработка нажатия кнопки ``ВЛЕВО''.}
  \label{listing:game-dev-button-left}
\end{listing}

Запустите эту программу, попробуйте походить влево-вправо.  В скором времени вы
заметите, что есть серьёзная проблема -- игрок может выйти за пределы дисплея
(``уйти за карту''.)

\subsection{Ограничение движения игрока}
\index{Разработка игр!Ограничение движения игрока по карте}
\index{Программирование!Условие}

Чтобы исправить вышеописанную проблему, необходимо добавить проверки позиции
игрока прежде, чем позволить ему сдвинуться влево или вправо.  Эти проверки
нужны при обработке нажатий кнопок.

Для движения вправо нам нужно смотреть, не выйдет ли игрок при следующем
``шаге'' (перемещении на клетку) за карту.  Поскольку мы знаем, что размер
нашего дисплея -- 16 столбцов, то мы можем ограничить движение вправо 15-й
клеткой.

\begin{listing}[H]
  \begin{minted}{cpp}
    // ... Код, который мы писали до этого ...

    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        // Делаем ограничение движения игрока вправо.
        // Если игрок уже на 15-й клетке, то дальше
        // двигаться ему нельзя.
        if (player_x < 15) {
          player_x++;
        }
      }
      if (digitalRead(BUTTON_L) == LOW) {
        player_x--;
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);

      // Задержка, чтобы избежать слишком быстрого
      // считывания нажатий на кнопки.
      delay(100);
    }
  \end{minted}
  \caption{Ограничение движения игрока вправо.}
  \label{listing:game-dev-player-right--constrain}
\end{listing}

С движением влево нужна подобная же проверка, с разницей в том, что крайняя
левая точка у нас -- это нулевая клетка.

\begin{listing}[ht]
  \begin{minted}{cpp}
    // ... Код, который мы писали до этого ...

    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        // Делаем ограничение движения игрока вправо.
        // Если игрок уже на 15-й клетке, то дальше
        // двигаться ему нельзя.
        if (player_x < 15) {
          player_x++;
        }
      }
      if (digitalRead(BUTTON_L) == LOW) {
        // Делаем ограничение движения игрока влево.
        // Если игрок уже на нулевой клетке, то левее
        // двигаться ему уже некуда.
        if (player_x > 0) {
          player_x--;
        }
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);

      // Задержка, чтобы избежать слишком быстрого
      // считывания нажатий на кнопки.
      delay(100);
    }
  \end{minted}
  \caption{Ограничение движения игрока влево и вправо.}
  \label{listing:game-dev-player-left-constrain}
\end{listing}

В листинге \ref{listing:game-dev-player-left-constrain} показана реализация
ограничений движения игрока вправо и влево.  Таким образом мы обработали оба
случая, когда игрок мог выйти за нашу игровую карту.

\end{document}
