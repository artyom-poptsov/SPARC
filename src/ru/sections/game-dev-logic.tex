\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Игровая логика}
\index{Разработка игр!Игровая логика}

В большинстве игр обычно есть определённые условия выигрыша и проигрыша, по
которым программа определяет исход игрового процесса.  В данном разделе мы
научимся реализовывать игровую логику, делать подсчёт очков, добавлять
дополнительные условия для выигрыша и проигрыша -- в общем, изучим всё то, что
сделает нашу игру интересной.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Условие выигрыша}
\index{Разработка игр!Игровая логика!Выигрыш}

В нашем игровом процессе выигрыш будет засчитываться тогда, когда игрок войдёт в
некоторую дверь.  Дверь, как и всё остальное в игре, будет представлена
специальным символом -- это может быть встроенный символ, или же нарисованный
нами.  Пусть для начала дверь будет обозначаться символом ``D'':

\begin{minted}{cpp}
  const char SPACE = ' ';    // Пустое пространство.
  const char WALL  = '#';    // Стена.
  const char HP    = '*';    // Аптечка.
  const char DOOR  = 'D';    // Дверь.
\end{minted}

Создадим функцию \texttt{is\_door} для проверки наличия двери в клетке:

\begin{minted}{cpp}
  // Функция, возвращающая 1 (true) в случае, если
  // на клетке карты по координатам x,y находится дверь.
  // В противном случае функция возвращает 0 (false).
  bool is_door(int x, int y) {
    return game_map[y][x] == DOOR;
  }
\end{minted}

Используя данную функцию, мы можем реализовать проверку, вошёл ли игрок в дверь.
Когда игрок входит в дверь, то вызывается функция \texttt{win}:

\begin{minted}{cpp}
  void loop() {
    if (digitalRead(BUTTON_R) == LOW) {
      // ...
    }

    if (digitalRead(BUTTON_L) == LOW) {
      // ...
    }

    if (is_hp(player_x, player_y)) {
      // ...
    }

    if (is_door(player_x, player_y)) {
      win();
    }

    // Вызов функции отрисовки карты на экране дисплея.
    map_show();

    // ...
  }
\end{minted}

Функция \texttt{win} может быть реализована следующим образом:

\begin{minted}{cpp}
  void win() {
    lcd.setCursor(0, 0);
    lcd.print("Y O U  W I N!");
    player_x = 0;
    player_y = 0;
    generate_map();
    delay(1000);
  }
\end{minted}

Как можно видеть, при выигрыше мы отображаем надпись ``Y O U  W I N'', затем
происходит ``сброс'' игры в исходное состояние путём зануления координат
персонажа и повторной генерации карты.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Условие проигрыша}
\index{Разработка игр!Игровая логика!Проигрыш}

Проигрыш в игре можно сделать, например, при столкновении игрока с монстром.
Обозначим монстра в виде константы:

\begin{minted}{cpp}
  const char SPACE   = ' ';    // Пустое пространство.
  const char WALL    = '#';    // Стена.
  const char HP      = '*';    // Аптечка.
  const char DOOR    = 'D';    // Дверь.
  const char MONSTER = 'M';  // Монстр.
\end{minted}

Далее добавим функцию проверки наличия монстра в клетке карты:

\begin{minted}{cpp}
  // Функция, возвращающая 1 (true) в случае, если
  // на клетке карты по координатам x,y находится дверь.
  // В противном случае функция возвращает 0 (false).
  bool is_monster(int x, int y) {
    return game_map[y][x] == MONSTER;
  }
\end{minted}

В функцию \texttt{loop} добавим проверку столкновения игрока с монстром:

\begin{minted}{cpp}
  void loop() {
    if (digitalRead(BUTTON_R) == LOW) {
      // ...
    }

    if (digitalRead(BUTTON_L) == LOW) {
      // ...
    }

    if (is_hp(player_x, player_y)) {
      // ...
    }

    if (is_door(player_x, player_y)) {
      win();
    }

    if (is_monster(player_x, player_y)) {
      game_over();
    }

    // Вызов функции отрисовки карты на экране дисплея.
    map_show();

    // ...
  }
\end{minted}

Простейшая реализация функциии проигрыша \texttt{game\_over} не сильно
отличается от функции выигрыша \texttt{win}:

\begin{minted}{cpp}
  void game_over() {
    lcd.setCursor(0, 0);
    lcd.print("G A M E  O V E R");
    player_x = 0;
    player_y = 0;
    generate_map();
    delay(1000);
  }
\end{minted}

Поскольку и в функции \texttt{game\_over}, и в функции \texttt{win} используется
``сброс'' игры в исходное состояние, то мы можем вынести этот набор операций в
отдельную функцию \texttt{reset\_game}:

\begin{minted}{cpp}
  // Функция "сброса" игры в исходное состояние.
  void reset_game() {
    player_x = 0;
    player_y = 0;
    generate_map();
  }

  void win() {
    lcd.setCursor(0, 0);
    lcd.print("Y O U  W I N!");
    reset_game();
    delay(1000);
  }

  void game_over() {
    lcd.setCursor(0, 0);
    lcd.print("G A M E  O V E R");
    reset_game();
    delay(1000);
  }
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Дополнительные квесты}
\index{Разработка игр!Игровая логика!Квесты}

Обычно в играх прохождение уровня усложнено тем, что нужно решить дополнительные
квесты -- например, для выигрыша нужно взять ключ, который открывает дверь.  Мы
можем это достаточно легко реализовать, добавив дополнительный объект ``КЛЮЧ''
(\texttt{KEY}):

\begin{minted}{cpp}
  const char SPACE = ' ';    // Пустое пространство.
  const char WALL  = '#';    // Стена.
  const char HP    = '*';    // Аптечка.
  const char DOOR  = 'D';    // Дверь.

  // Добвили эту строку:
  const char KEY   = 'K';    // Ключ.
\end{minted}

В дверь можно будет зайти только при наличии ключа -- без него она ``закрыта''.
Эта простая логика реализуется проверкой взятия ключа и изменением двери с
закрытой на открытую.  Таким образом нам требуется теперь два вида дверей --
закрытый вариант (\texttt{CLOSED\_DOOR}) и открытый вариант
(\texttt{OPEN\_DOOR}):

\begin{minted}{cpp}
  const char SPACE = ' ';    // Пустое пространство.
  const char WALL  = '#';    // Стена.
  const char HP    = '*';    // Аптечка.

  // Изменили эти строки:
  const char CLOSED_DOOR  = 'd';    // Закрытая дверь.
  const char OPEN_DOOR    = 'D';    // Открытая дверь.

  const char KEY   = 'K';    // Ключ.
\end{minted}

Важно заметить, что символы для каждого вида двери должны отличаться, чтобы
компьютер также смог их различить в проверках, которые потребуются далее.

Пусть позиция двери у нас будет задана переменными \texttt{door\_x} и
\texttt{door\_y}.  Мы можем доработать функцию \texttt{map\_generate}, добавив
закрытую дверь (\texttt{CLOSED\_DOOR}) на карту по указанным координатам:

\begin{minted}{cpp}
  // Позиция двери на карте:
  byte door_x = 19;
  byte door_y = 3;

  void map_generate() {
    for (int y = 0; y < MAP_H; y++) {
      for (int x = 0; x < MAP_W; x++) {
        game_map[y][x] = SPACE;
      }
    }

    // Добавляем вручную на карту объекты.
    game_map[0][10] = WALL;
    game_map[1][10] = WALL;
    game_map[2][10] = WALL;
    game_map[door_y][door_x] = CLOSED_DOOR;
  }
\end{minted}

Добавим также функцию проверки наличия ключа в указанной клетке карты:

\begin{minted}{cpp}
  // Функция, возвращающая 1 (true) в случае, если
  // на клетке карты по координатам x,y находится ключ.
  // В противном случае функция возвращает 0 (false).
  bool is_key(int x, int y) {
    return game_map[y][x] == KEY;
  }
\end{minted}

Когда игрок ``наступает'' на ключ, то эта закрытая дверь будет заменяться на
открытую.  Для работы с картой мы можем воспользоваться функциями
\texttt{map\_set} и \texttt{map\_clear}, описанными в разделе
\ref{game-dev-game-map:extra-procedures}:

\begin{minted}{cpp}
  void loop() {
    // ... Здесь идёт обработка нажатий клавиш...

    if (is_key(player_x, player_y)) {
      // "Открытие" двери ключом.
      map_set(door_x, door_y, OPEN_DOOR);

      // Очистка клетки карты.
      map_clear(player_x, player_y);
    }

    // ...

    // Вызов функции отрисовки карты на экране дисплея.
    map_show();

    // ...
  }
\end{minted}

Соответственно нам теперь требуется доработка проверки выигрыша, так как войти
можно только в открытую дверь.

Заменим функцию \texttt{is\_door} на \texttt{is\_open\_door} и обновим проверку:

\begin{minted}{cpp}
  // Функция, возвращающая 1 (true) в случае, если
  // на клетке карты по координатам x,y находится дверь.
  // В противном случае функция возвращает 0 (false).
  bool is_open_door(int x, int y) {
    return game_map[y][x] == OPEN_DOOR;
  }
\end{minted}

Обновим также код проверки выигрыша в функции \texttt{loop}:

\begin{minted}{cpp}
  void loop() {
    // ... Здесь идёт обработка нажатий клавиш...

    if (is_key(player_x, player_y)) {
      // "Открытие" двери ключом.
      map_set(door_x, door_y, OPEN_DOOR);

      // Очистка клетки карты.
      map_clear(player_x, player_y);
    }

    if (is_open_door(player_x, player_y)) {
      win();
    }

    // ...

    // Вызов функции отрисовки карты на экране дисплея.
    map_show();

    // ...
  }
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Подсчёт очков}
\index{Разработка игр!Игровая логика!Подсчёт очков}
\index{Программирование!Переменная!Глобальная переменная}

Для подсчёта очков (или собранных предметов) достаточно завести где-нибудь
вверху программы глобальную переменную, которая будет меняться при возникновении
события.  Пусть переменная называется ``score'', что в переводе с английского
как раз и значит ``счёт'':

\begin{minted}{cpp}
int score = 0;
\end{minted}

Изначально счёт равен нулю.

Теперь, когда игрок берёт какой-либо предмет с карты, можно увеличивать значение
счётчика.  Пусть в нашем случае будет подсчитываться количество собранных очков
здоровья (Health Points, ``HP''):

\begin{minted}{cpp}
  void loop() {
    if (digitalRead(BUTTON_R) == LOW) {
      // ...
    }

    if (digitalRead(BUTTON_L) == LOW) {
      // ...
    }

    if (is_hp(player_x, player_y)) {
      score++; // Увеличение счётчика.
      // ...
    }

    // ...

    map_show();

    // ...
  }
\end{minted}

Имея в распоряжении такой счётчик, достаточно легко построить на этом дальнейшую
логику игры.  Например, можно сделать так, чтобы при 10 собранных предметах
происходил выигрыш:

\begin{minted}{cpp}
  void loop() {
    if (digitalRead(BUTTON_R) == LOW) {
      // ...
    }

    if (digitalRead(BUTTON_L) == LOW) {
      // ...
    }

    if (is_hp(player_x, player_y)) {
      score++; // Увеличение счётчика.
      // ...
    }

    // Если собрано 10 предметов, то...
    if (score == 10) {
      win(); // ... засчитывается выигрыш.
    }

    // ...

    map_show();

    // ...
  }
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Отображение жизней персонажа с помощью светодиодов}

Одним из интересных вариантов отображения жизней персонажа (или набранных очков)
является использование подключенных к микроконтроллеру светодиодов -- это
экономит место на дисплее (не нужно занимать его часть отображением информации.)

Для того, чтобы реализовать данную возможность, необходимо подключить несколько
светодиодов к микроконтроллеру, как мы это делали в главе
\ref{chapter:dialogues-with-computer}.

Пусть в нашем случае будет три светодиода для отображения жизней персонажа.
Светодиоды желательно подключить в последовательно расположенные свободные
цифровые порты -- например, с 22-го по 24-й.  Начальный номер порта разумно
задать глобальной константой, также как и максимальное количество жизней, чтобы
было можно потом на них ссылаться:

\begin{minted}{cpp}
  // Начальный номер порта последовательности светодиодов
  // для отображения жизней:
  const byte HP_LED_START = 22;
  // Максимальное количество жизней:
  const byte HP_MAX       = 3;
\end{minted}

В \texttt{setup} необходимо настроить эти порты на режим \texttt{OUTPUT}:

\begin{minted}{cpp}
  void setup() {
    // ...
    for (byte idx = 0; idx < HP_MAX; idx++) {
      pinMode(idx + HP_LED_START, OUTPUT);
    }
  }
\end{minted}

Обратите внимание, как мы используем константы \texttt{HP\_LED\_START},
прибавляя его к счётчику цикла для того, чтобы получить номер пора светодиода --
этот же трюк мы будем использовать далее.

Количество жизней пусть будет задано глобальной переменной \texttt{hp}, можно
задать её сразу после константы \texttt{HP\_LED\_START}:

\begin{minted}{cpp}
  // Начальный номер порта последовательности светодиодов
  // для отображения жизней:
  const byte HP_LED_START = 22;
  // Максимальное количество жизней:
  const byte HP_MAX       = 3;

  byte hp = 3; // Количество жизней персонажа.
\end{minted}

Нам необходима функция, которая будет обновлять светодиоды, чтобы жизни
персонажа отображались на них в реальном временм:

\begin{minted}{cpp}
  void show_hp() {
    for (byte idx = 0; idx < HP_MAX; idx++) {
      if (idx < hp) {
        // Включаем светодиоды, порядковый номер которых
        // меньше, чем текущее количество жизней.
        digitalWrite(HP_LED__START + idx, HIGH);
      } else {
        // Выключаем остальные светодиоды.
        digitalWrite(HP_LED_START + idx, LOW);
      }
    }
  }
\end{minted}

Затем эту функцию необходимо вызвать где-нибудь в \texttt{loop}, чтобы
количество жизней персонажа отображалось в реальном времени:

\begin{minted}{cpp}
  void loop() {
    show_hp();
    // ...
  }
\end{minted}

\end{document}
