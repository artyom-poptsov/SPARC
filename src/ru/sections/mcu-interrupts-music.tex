\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программирование музыки через прерывания}

Имея новые знания о прерываниях и таймерах, пришло время вернуться к теме, уже
рассмотренной нами в главе \ref{chapter:sound} -- а именно к теме
программирования звука и музыки.  Ведь благодаря изученному материалу, у нас
появилась возможность совместить одновременно две мелодии на одном
микроконтроллере.  Но обо всём по-порядку.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Генерация звука с помощью таймера}

Как мы уже говорили, прерывания обрабатываются как бы параллельно с работой
процедуры \mintinline{cpp}{loop}.  Используя прерывания, можно добиться как
гораздо более быстрого отклика на внешние события (за счёт внешних прерываний),
так и точной выдержки промежутков времени (за счёт таймеров.)

В главе \ref{chapter:sound} мы использовали самописную процедуру
\mintinline{cpp}{play_tone} для вывода звука, где использовали процедуру
\mintinline{cpp}{delayMicroseconds} для обеспечения времени полупериодов
звуковой волны.  Использование такого подхода имеет как плюсы, так и минусы.  К
плюсам использования простого цикла с задержками можно отнести то, что код
получается достаточно простой и понятный для начинающих (это и послужило
причиной нашего выбора в пользу такого подхода.)  К минусам же можно отнести то,
что процедура \mintinline{cpp}{play_tone} является \emph{блокирующей} -- в том
смысле, что она явно влияет на ход выполнения программы, ведь пока она не
завершиться, компьютер не перейдёт к следующей инструкции.  Кроме того, что для
нас тоже важно -- использование цикла, а также процедур
\mintinline{cpp}{delayMicroseconds} и \mintinline{cpp}{digitalWrite} в нём,
приводило к дополнительным задержкам и неточности (можно даже сказать, к
нестабильности) выходного сигнала.

Мы будем использовать 16-битный ``Timer1'', так как он позволяет отмерять
большие промежутки времени без необходимости написания более сложной логики
программы с нашей стороны.  Диапазон счётчика данного таймера составляет от 0 до
65535.  Нам необходимо написать процедуру перевода желаемой частоты звука в
значение регистра ``OCR1A'', чтобы создать прерывание, переключающее значение
цифрового порта, в нужный момент времени.

Предположим, что мы хотим получить на выходе частоту 50Гц при предделителе 8.
Формула для этого выглядит следующим образом:

\begin{align}
  \mbox{CPU\_FREQUENCY} =& 16000000 \mbox{Гц} \\
  \mbox{PRESCALER} =& 8 \\
  \mbox{FREQUENCY} =& 50 \mbox{Гц} \\
  \mbox{OCR1A} =& \frac{CPU\_FREQUENCY}{PRESCALER * FREQUENCY * 2} - 1 \\
  =& \frac{16000000 \mbox{Гц}}{8 * 50 \mbox{Гц} * 2} - 1 \\
  =& 19999
  \label{equation:mcu-music-1}
\end{align}

Где \texttt{CPU\_FREQUENCY} -- это частота процессора (в нашем случае, 16МГц),
\texttt{PRESCALER} -- это предделитель частоты процессора для таймера,
\texttt{FREQUENCY} -- желаемая частота выходного сигнала.  Умножение на 2 мы
делаем, чтобы получить значение для полупериода.  После подстановки всех
необходимых значений мы получаем число 19999 -- как только счётчик ``Timer1''
достигнет этого значения, как раз пройдёт время полупериода одного колебания.

\begin{listing}[ht]
  \begin{minted}{cpp}
    const unsigned long CPU_FREQ = 16000000UL;
    const double CPU_PRESCALER = 8.0;

    long frequency_to_timer(double f) {
      return (CPU_FREQ / (CPU_PRESCALER * f * 2)) - 1;
    }
  \end{minted}
  \caption{Процедура перевода частоты в значение регистра сравнения ``OCR''.}
  \label{listing:mcu-music-1}
\end{listing}

Что достаточно легко транслируется в код для Arduino, показанный в листинге
\ref{listing:mcu-music-1}.  Процедура \mintinline{cpp}{frequency_to_timer}
возвращает значение для регистра ``OCR''.  Когда счётчик таймера досчитает до
этого значения, то пройдёт как раз время полупериода для заданной частоты.

Имея на руках процедуру \mintinline{cpp}{frequency_to_timer}, можно уже
сгенерировать на выходе Arduino звук желаемой частоты, как показано в листинге
\ref{listing:mcu-music-2}.  В данном примере мы генерируем звук с частотой 50Гц
на цифровом порту ``D2''.

\newpage
\begin{listing}[H]
  \begin{minted}{cpp}
    // 01. Частота процессора (16МГц.)
    const unsigned long CPU_FREQ = 16000000UL;
    // 02. Предделитель частоты процессора.
    const double CPU_PRESCALER = 8.0;
    // 03. Частота звука.
    const double FREQ = 50;

    // 04. Процедура для преобразования частоты звука
    //     в значение регистра сравнения "OCR".
    long frequency_to_timer(double f) {
      return (CPU_FREQ / (CPU_PRESCALER * f * 2)) - 1;
    }

    void setup() {
      // 05. Настройка порта D2 на выход.
      DDRE |= 1 << 4;
      TCCR1A = B00000000;
      // 06. Задание предделителя частоты.
      TCCR1B = B00000010;
      // 07. Включение перерывания на таймере 1.
      TIMSK1 |= B00000010;
      // 08. Задание начального значения регистра "OCR".
      OCR1A = frequency_to_timer(FREQ);
      // 09. Задание начального значения LOW для порта D2.
      PORTE &= ~(1 << 4);
    }

    // 10. Обработчик прерывания.
    ISR(TIMER1_COMPA_vect) {
      // 11. Инверсия значения на цифровом порту.
      PORTE ^= 1 << 4;
      // 12. Прибавление времени полупериода к
      //     регистру сравнения, чтобы следующее прерывание
      //     корретно сработало.
      OCR1A += frequency_to_timer(FREQ);
    }

    void loop() {
      // Do nothing.
    }
  \end{minted}
  \caption{Код генерации звука с частотой 50Гц с помощью прерывания по таймеру.}
  \label{listing:mcu-music-2}
\end{listing}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Генерация музыки}
\label{subsection:mcu-music-1}

Как только мы получили возможность генерировать звук, до музыки остаётся один
шаг -- нам нужно каким-то образом выстроить звуки в нужном порядке, чтобы
получить музыкальную композицию.  Мы уже использовали с вами двумерные массивы
для хранения мелодии, здесь мы будем делать тоже самое.

В качестве композиции для программирования возьмём песню ``Daisy Bell'' под
авторством Harry Dacre.\footnote{Используется версия
\url{https://musescore.com/crono23/scores/5491815}}

Объявим в файле ``music.ino'' ноты, как показано в листинге
\ref{listing:mcu-music-2-1}.

\begin{listing}[ht]
  \begin{minted}{cpp}
    float c0 = 16.352;
    float d0 = 18.354;
    float e0 = 20.602;
    float f0 = 21.827;
    float g0 = 24.500;
    float a0 = 27.500;
    float b0 = 30.868;

    float c4 = c0 * 16;
    float d4 = d0 * 16;
    float e4 = e0 * 16;
    float e4b = (e4 + d4) / 2;
    float f4 = f0 * 16;
    float g4 = g0 * 16;
    float f4s = (f4 + g4) / 2;
    float a4 = a0 * 16;
    float b4 = b0 * 16;

    float c5 = c0 * 32;
    float d5 = d0 * 32;
    float c5s = (c5 + d5) / 2;
    float e5 = e0 * 32;
    float f5 = f0 * 32;
    float g5 = g0 * 32;
    float f5s = (f5 + g5) / 2;
    float a5 = a0 * 32;
    float b5 = b0 * 32;
    float a5s = (a5 + b5) / 2;

    float c6 = c0 * 64;
    float d6 = d0 * 64;
    float e6 = e0 * 64;

    const float R = 0; // Rest -- Покой, пауза.
  \end{minted}
  \caption{Ноты, необходимые для мелодии ``Daisy Bell''.}
  \label{listing:mcu-music-2-1}
\end{listing}

И здесь же объявим массив с мелодией.

\begin{listing}[H]
  \begin{minted}{cpp}
    float daisy1[][2] = {
      // 1
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 2
      {b4, 4}, {a4, 4}, {g4, 4},
      // 3
      {a4, 2}, {f5s, 4},
      // 4
      {d5, 2}, {d6, 4},
      // 5
      {b5, 8}, {d5, 8},
      {e5, 8}, {f5s, 8},
      {g5, 8}, {a5, 8},
      // 6
      {a5s, 8}, {b5, 8},
      {e6, 8}, {d6, 8},
      {c6, 8}, {g5, 8},
      // 7
      {a5, 2}, {d5, 4},
      // 8
      {b4, 4.0 / 3.0},
      // 9 (vocals)
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 10
      {b4, 4}, {a4, 4}, {g4, 4},
      // 11
      {a4, 2}, {f4s, 4},
      // 12
      {d4, 2}, {R, 4},
      // 13
      {a4, 4.0 / 3.0},
      // 14
      {d4, 4.0 / 3.0},
      // 15
      {d5, 4.0/3.0},
      // 16
      {b4, 2}, {R, 4},
      // 17
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 18
      {b4, 4}, {a4, 4}, {g4, 4},
      // 19
      {a4, 2}, {f4s, 4},
      // 20
      {d4, 2}, {R, 4},
      // 21
      {g4, 4}, {d5, 4}, {g4, 4},
      // 22
      {f4s, 4}, {d4, 4}, {a4, 4},
      // 23
      {g4, 1},
      // 24
      {R, 4}, {R, 4}
    };

    const int LENGTH = sizeof(daisy1) / sizeof(daisy1[0]);
  \end{minted}
  \caption{Часть мелодии ``Daisy Bell''.}
  \label{listing:mcu-music-2-2}
\end{listing}

Константа \mintinline{cpp}{LENGTH} хранит количество нот в мелодии.

Чтобы воспроизвести данную мелодию, нам нужно последовательно брать из массива
ноты и воспроизводить их через прерывания.  Ситуация усложняется тем, что теперь
нельзя просто так взять, и использовать привычный нам цикл.

Для упрощения работы, в файле ``music.h'' сделаем структуру, которая описывает
музыкальный трек.

\begin{listing}[H]
  \begin{minted}{cpp}
    typedef struct {
      // Количество нот в мелодии.
      int length;

      // Индекс (номер) ноты.
      int  note_index;

      // Время начала воспроизведения ноты.
      long note_start_time;

      // Длина ноты.
      long note_length;

      // Задержка после ноты.
      long note_delay;

      // Текущее время.
      long current_time;

      // Время, прошедшее с начала воспроизведения
      // ноты.
      long time_diff;

      // Виртуальный регистр OCR.
      long ocr;

      // Счётчик для таймера.
      long counter;

      // Цифровой порт для вывода звука.
      byte speaker_pin;

      // Текущее значение на выходном цифровом порту.
      byte speaker_pin_value;
    } track_t;
  \end{minted}
  \caption{Структура, описывающая музыкальный трек.}
  \label{listing:mcu-music-3}
\end{listing}

В структуре, показанной в листинге \ref{listing:mcu-music-3}, мы предусмотрели
все необходимые поля, которые потребуются внутри обработчика прерывания.

\mintinline{cpp}{length} задаёт количество нот в мелодии.

\mintinline{cpp}{note_index} является индексом ноты в массиве нот.  Данный
индекс будет использоваться для получения ноты из массива, и будет прибавляться
для перехода на другую ноту.

\mintinline{cpp}{note_start_time} хранит время начала воспроизведения ноты (в
микросекундах.)

\mintinline{cpp}{note_length} хранит время звучания ноты (в микросекундах),
которая рассчитывается исходя из длины такта и длины ноты.

\mintinline{cpp}{current_time} хранит текущее время (в микросекундах.)

\mintinline{cpp}{time_diff} хранит время, прошедшее с начала воспроизведения
ноты.  Для вычисления этого времени мы будем вычитать время начала
воспроизведения ноты \mintinline{cpp}{note_start_time} из текущего времени
\mintinline{cpp}{current_time}.

\mintinline{cpp}{ocr} Виртуальный регистр OCR.  Значение данного поля может быть
больше, чем максимальное значение физического регистра OCR, что позволяет
отсчитывать большие промежутки времени.

\mintinline{cpp}{increment} хранит значение, на которое прибавляется регистр
сравнения OCR, используемого для прерывания.

\mintinline{cpp}{speaker_pin} хранит номер цифрового порта, на который выводится
звук.

\mintinline{cpp}{speaker_pin_value} хранит текущее значение цифрового порта
\mintinline{cpp}{speaker_pin}.

Также в файле ``music.h'' разместим ссылки на внешние (по отношению к данному
файлу) ресурсы -- массив \mintinline{cpp}{daisy1} и на константу
\mintinline{cpp}{LENGTH}, хранящую его длину.  В итоге, содержимое файла
``music.h'' будет выглядеть примерно так, как показано в листинге
\ref{listing:mcu-music-3-2}.

\newpage
\begin{listing}[H]
  \begin{minted}{cpp}
    #ifndef __MUSIC_H__
    #define __MUSIC_H__

    typedef struct {
      // Количество нот в мелодии.
      int length;

      // Индекс (номер) ноты.
      int  note_index;

      // Время начала воспроизведения ноты.
      long note_start_time;

      // Длина ноты.
      long note_length;

      // Задержка после ноты.
      long note_delay;

      // Текущее время.
      long current_time;

      // Время, прошедшее с начала воспроизведения
      // ноты.
      long time_diff;

      // Виртуальный регистр OCR.
      long ocr;

      // Счётчик для таймера.
      long counter;

      // Цифровой порт для вывода звука.
      byte speaker_pin;

      // Текущее значение на выходном цифровом порту.
      byte speaker_pin_value;
    } track_t;

    extern float daisy1[][2];
    extern const int LENGTH;

    #endif /* ifndef __MUSIC_H__ */
  \end{minted}
  \caption{Содержимое файла ``music.h''.}
  \label{listing:mcu-music-3-2}
\end{listing}

\newpage
Далее нам необходимо задать в основном файле, в глобальной области констнанты.
Здесь мы укажем частоту процессора, предделитель частоты и другие необходимые
нам параметры, в том числе \gls{BPM} -- для мелодии ``Daisy Bell'' он равен 172
ударам в минуту.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Порт вывода звука.
    const int SPEAKER_1 = 2;

    // Частота процессора.
    const long CPU_FREQ = 16000000; // Гц

    // Предделитель частоты.
    const long CPU_PRESCALER = 8.0;

    // Время между нотами, равное проценту от длины ноты.
    const float DELAY_PERCENT = 0.05;

    // Скорость мелодии "Daisy Bell".
    const int BPM = 172; // Beats per minute.

    // Одна минута, заданная в микросекундах.
    const long MINUTE = 60000000; // мкс

    // Длина такта.
    const long TAKT = (MINUTE / BPM) * 4; // мкс
  \end{minted}
  \caption{Константы, необходимые для генерации мелодии.}
  \label{listing:mcu-music-4}
\end{listing}

В глобальной области мы разместим также экземпляр структуры
\mintinline{cpp}{track_t}, который мы просто назовём \mintinline{cpp}{track1}.

\begin{listing}[H]
  \begin{minted}{cpp}
    volatile track_t track1;
  \end{minted}
  \caption{Создание экземпляра структуры \mintinline{cpp}{track_t}.}
  \label{listing:mcu-music-5}
\end{listing}

Как было сказано в разделе \ref{subsection:isr}, необходимо использовать
ключевое слово \mintinline{cpp}{volatile} для того, чтобы компилятор сохранил
переменную \mintinline{cpp}{track1} при оптимизации.

Здесь же, в глобальной области, разместим и процедуру
\mintinline{cpp}{frequency_to_timer}.

\begin{listing}[H]
  \begin{minted}{cpp}
    long frequency_to_timer(double f) {
      return (CPU_FREQ / (CPU_PRESCALER * f * 2)) - 1;
    }
  \end{minted}
  \caption{Процедура для преобразования частоты звука в значение регистра
    сравнения ``OCR''.}
  \label{listing:mcu-music-6}
\end{listing}

В процедуре \mintinline{cpp}{setup} необходимо проинициализировать порты и
экземпляр структуры \mintinline{cpp}{track_t}.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(SPEAKER_1, OUTPUT);

      track1.length = LENGTH;
      track1.note_index = 0;
      track1.note_start_time = micros();
      track1.note_length = TAKT / daisy1[0][1];
      track1.note_delay = track1.note_length * DELAY_PERCENT;
      track1.current_time = micros();
      track1.time_diff = 0;
      track1.ocr = frequency_to_timer(daisy1[0][0]);
      track1.counter = track1.ocr;
      track1.speaker_pin_value = HIGH;

      // ...
    }
  \end{minted}
  \caption{Инициализация цифрового порта и структуры.}
  \label{listing:mcu-music-7}
\end{listing}

Затем в \mintinline{cpp}{setup} надо проинициализировать также регистры
процессора, для обработки прерываний от таймера.

\begin{listing}[H]
  \begin{minted}[highlightlines={15-18}]{cpp}
    void setup() {
      pinMode(SPEAKER_1, OUTPUT);

      track1.length = LENGTH;
      track1.note_index = 0;
      track1.note_start_time = micros();
      track1.note_length = TAKT / daisy1[0][1];
      track1.note_delay = track1.note_length * DELAY_PERCENT;
      track1.current_time = micros();
      track1.time_diff = 0;
      track1.ocr = frequency_to_timer(daisy1[0][0]);
      track1.counter = track1.ocr;
      track1.speaker_pin_value = HIGH;

      TCCR1A = B00000000;
      TCCR1B |= B00000010;
      OCR1A = 1024;
      TIMSK1 |= B00000010;
    }
  \end{minted}
  \caption{Инициализация регистров процессора.}
  \label{listing:mcu-music-8}
\end{listing}

Далее нам необходимо реализовать обработчик прерывания
\mintinline{cpp}{TIMER1_COMPA_vect}.

\begin{listing}[H]
  \begin{minted}{cpp}
    ISR(TIMER1_COMPA_vect) {
      if (track1.counter > 65535) {
        OCR1A = 65535;
        track1.counter -= 65535;
        return;
      } else {
        OCR1A += track1.counter;
        track1.counter = track1.ocr;
      }

      // ...
    }
  \end{minted}
  \caption{Задание значения для регистра ``OCR1A'' в обработчике прерывания.}
  \label{listing:mcu-music-9}
\end{listing}

Первым делом в обработчике мы должны задать новое значение регистра ``OCR1A''.
Возможна ситуация, в которой значение счётчика \mintinline{cpp}{track1.counter}
больше, чем максимальное значение 16-битного регистра ``OCR1A'' (65535) -- такое
может возникнуть, если частота звука достаточно низка.  В связи с этим мы не
можем просто писать в регистр это значение напрямую.

Чтобы решить эту проблему, мы используем условие, где проверяем -- если значение
\mintinline{cpp}{track1.counter} больше 65535, то тогда в регистр ``OCR1A''
записывается максиально возможное число и значение
\mintinline{cpp}{track1.counter} уменьшается на значение 65535.  Далее мы делаем
выход из процедуры обработчика прерывания через \mintinline{cpp}{return}, и
таким образом пропускам одно прерывание.  Так может повторяться несколько раз.
Как только значение \mintinline{cpp}{track1.counter} становится меньше
максимального значения регистра ``OCR1A'', то мы добавляем это значение в
регистр и сбрасываем \mintinline{cpp}{track1.counter} в значение
\mintinline{cpp}{track1.ocr}.

\begin{listing}[H]
  \begin{minted}[highlightlines={11-18}]{cpp}
    ISR(TIMER1_COMPA_vect) {
      if (track1.counter > 65535) {
        OCR1A = 65535;
        track1.counter -= 65535;
        return;
      } else {
        OCR1A += track1.counter;
        track1.counter = track1.ocr;
      }

      track1.current_time = micros();
      track1.time_diff = \
        track1.current_time - track1.note_start_time;
      if ((track1.note_length > 0)
          && (track1.time_diff < track1.note_length)) {
        digitalWrite(SPEAKER_1, track1.speaker_pin_value);
        track1.speaker_pin_value = ! track1.speaker_pin_value;
      }

      // ...
    }
  \end{minted}
  \caption{Генерация звукового сигнала в обработчике прерывания.}
  \label{listing:mcu-music-10}
\end{listing}

В листинге \ref{listing:mcu-music-10} добавлен код в обработчике прерывания,
генерирующий звуковой сигнал.  Не нужно забывать, что среди обычных нот нам
могут встречаться паузы, при которых колебания мембраны динамика происходить не
должны.  Одним из возможных решений является использование нулевой длины ноты
(можно сказать, нулевой длины звука) для индикации паузы.  Если длина ноты равна
нулю, то мы не меняем значене на цифровом порту.  Также колебания не должны
происходить после завершения звучания ноты.

В остальных случаях мы устанавливаем на цифровом порту значение \\
\mintinline{cpp}{speaker_pin_value}, а затем интвертируем значение этого поля
структуры.  Таким образом, с значения 0 (\mintinline{cpp}{LOW}) и 1
(\mintinline{cpp}{LOW}) на цифровом порту чередуются, создавая колебания
мембраны динамика.

\begin{listing}[H]
  \begin{minted}[highlightlines={20-40}]{cpp}
    ISR(TIMER1_COMPA_vect) {
      if (track1.counter > 65535) {
        OCR1A = 65535;
        track1.counter -= 65535;
        return;
      } else {
        OCR1A += track1.counter;
        track1.counter = track1.ocr;
      }

      track1.current_time = micros();
      track1.time_diff = \
      track1.current_time - track1.note_start_time;
      if ((track1.note_length > 0)
      && (track1.time_diff < track1.note_length)) {
        digitalWrite(SPEAKER_1, track1.speaker_pin_value);
        track1.speaker_pin_value = ! track1.speaker_pin_value;
      }

      if (track1.time_diff
          >= track1.note_length + track1.note_delay) {
        track1.note_index = \
          (track1.note_index + 1) % track1.length;
        track1.note_start_time = track1.current_time;
        if (daisy1[track1.note_index][0] > 0) {
          track1.ocr \
            = frequency_to_timer(daisy1[track1.note_index][0]);
          track1.note_length \
            = TAKT / daisy1[track1.note_index][1];
          track1.note_delay \
            = track1.note_length * DELAY_PERCENT;
        } else {
          track1.ocr = 100;
          track1.note_delay \
            = TAKT / daisy1[track1.note_index][1];
          track1.note_delay \
            += track1.note_delay * DELAY_PERCENT;
          track1.note_length = 0;
        }
      }
    }
  \end{minted}
  \caption{Переход между нотами и реализация пауз.}
  \label{listing:mcu-music-11}
\end{listing}

В следующем дополнении кода, выделенном в листинге \ref{listing:mcu-music-11} мы
реализуем переход между нотами мелодии и обработка пауз.  Если разница между
временем начала ноты и текущем временем (\mintinline{cpp}{time_diff}) больше или
равна суммарной длительностью ноты и задержки до следующей ноты, то мы
увеличиваем индекс выбора ноты из массива:

\begin{minted}{cpp}
track1.note_index = (track1.note_index + 1) % track1.length;
\end{minted}

Получение остатка от деления на длину массива (\mintinline{cpp}{track1.length})
позволяет нам без дополнительных проверок оставаться в границах массива.

Также нам необходимо запомнить время начала ноты, что мы и делаем в следующем
коде:

\begin{minted}{cpp}
track1.note_start_time = track1.current_time;
\end{minted}

Если частота ноты больше нуля, то мы берём следующую ноту из массива для
воспроизведения, считая необходимые параметры (значение для регистра OCR, длину
ноты, задержку после ноты.)  Если же частота равна нулю, то тогда берутся другие
параметры (регистр OCR равен 100, длина ноты равна нулю, и задержка после ноты,
равная длине ноты плюс задержка после ноты.)  Это позволяет нам корректно
отрабатывать паузы.

Процедура \mintinline{cpp}{loop} в нашем случае просто будет содержать задержку
в 100 мс:

\begin{minted}{cpp}
void loop() {
  delay(100);
}
\end{minted}

Если всё корретно написано, то после загрузки в Arduino Mega 2560, данная
программа будет воспроизводить мелодию ``Daisy Bell'' на втором цифровом порту.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Двухканальная генерация музыки}

Теперь, когда мы смогли сгенерировать музыку с помощью прерываний на одном
цифровом порту, мы можем взяться за задачу воспроизведения двух частей одной
мелодии на одной Arduino Mega 2560.

Для этого мы будем использовать второй регистр сравнения ``OCR1B'' в дополнении
к регистру ``OCR1A''.  Благодаря использованию двух регистров, мы сможем
генерировать два прерывания на одном таймере (``Timer1''.)

Начнём с того, что в файле ``music.ino'' мы объявим необходимые нам ноты, как
показано в листинге \ref{listing:mcu-music-12}.

\newpage
\begin{listing}[H]
  \begin{minted}{cpp}
    float c0 = 16.352;
    float d0 = 18.354;
    float e0 = 20.602;
    float f0 = 21.827;
    float g0 = 24.500;
    float a0 = 27.500;
    float b0 = 30.868;

    float c1 = c0 * 2;

    float c2 = c0 * 4;
    float g2 = g0 * 4;

    float c3 = c0 * 8;
    float d3 = d0 * 8;
    float e3 = e0 * 8;
    float f3 = f0 * 8;
    float g3 = g0 * 8;
    float f3s = (f3 + g3) / 2;
    float a3 = a0 * 8;
    float b3 = b0 * 8;

    float c4 = c0 * 16;
    float d4 = d0 * 16;
    float e4 = e0 * 16;
    float e4b = (e4 + d4) / 2;
    float f4 = f0 * 16;
    float g4 = g0 * 16;
    float f4s = (f4 + g4) / 2;
    float a4 = a0 * 16;
    float b4 = b0 * 16;

    float c5 = c0 * 32;
    float d5 = d0 * 32;
    float c5s = (c5 + d5) / 2;
    float e5 = e0 * 32;
    float f5 = f0 * 32;
    float g5 = g0 * 32;
    float f5s = (f5 + g5) / 2;
    float a5 = a0 * 32;
    float b5 = b0 * 32;
    float a5s = (a5 + b5) / 2;

    float c6 = c0 * 64;
    float d6 = d0 * 64;
    float e6 = e0 * 64;

    const float R = 0;
  \end{minted}
  \caption{Ноты для второй версии мелодии ``Daisy Bell''.}
  \label{listing:mcu-music-12}
\end{listing}

\newpage
В этом же файле мы объявим массивы с двумя дорожками мелодии (см. листинг
\ref{listing:mcu-music-13}.)  Массив \mintinline{cpp}{daisy1} хранит мелодию для
правой руки во вступлении к мелодии и вокал.

\begin{listing}[ht]
  \begin{minted}{cpp}
    float daisy1[][2] = {
      // 1
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 2
      {b4, 4}, {a4, 4}, {g4, 4},
      // 3
      {a4, 2}, {f5s, 4},
      // 4
      {d5, 2}, {d6, 4},
      // 5
      {b5, 8}, {d5, 8},
      {e5, 8}, {f5s, 8},
      {g5, 8}, {a5, 8},
      // 6
      {a5s, 8}, {b5, 8},
      {e6, 8}, {d6, 8},
      {c6, 8}, {g5, 8},
      // 7
      {a5, 2}, {d5, 4},
      // 8
      {b4, 4.0 / 3.0},
      // 9 (vocals)
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 10
      {b4, 4}, {a4, 4}, {g4, 4},
      // 11
      {a4, 2}, {f4s, 4},
      // 12
      {d4, 2}, {R, 4},
      // 13
      {a4, 4.0 / 3.0},
      // 14
      {d4, 4.0 / 3.0},
      // 15
      {d5, 4.0 / 3.0},
      // 16
      {b4, 2}, {R, 4},
      // 17
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 18
      {b4, 4}, {a4, 4}, {g4, 4},
      // 19
      {a4, 2}, {f4s, 4},
      // 20
      {d4, 2}, {R, 4},
      // 21
      {g4, 4}, {d5, 4}, {g4, 4},
      // 22
      {f4s, 4}, {d4, 4}, {a4, 4},
      // 23
      {g4, 1},
      // 24
      {R, 4}, {R, 4}
    };
  \end{minted}
  \caption{Массив с нотами для первой дорожки мелодии ``Daisy Bell''.}
  \label{listing:mcu-music-13}
\end{listing}

В массиве \mintinline{cpp}{daisy2} мы разместим ноты второй дорожки мелодии, как
показано в листинге \ref{listing:mcu-music-14}.  Эта дорожка будет
аккомпанементом, который музыкантом играется левой рукой на пианино.

\begin{listing}[ht]
  \begin{minted}{cpp}
    float daisy1[][2] = {
      // 1
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 2
      {b4, 4}, {a4, 4}, {g4, 4},
      // 3
      {a4, 2}, {f5s, 4},
      // 4
      {d5, 2}, {d6, 4},
      // 5
      {b5, 8}, {d5, 8},
      {e5, 8}, {f5s, 8},
      {g5, 8}, {a5, 8},
      // 6
      {a5s, 8}, {b5, 8},
      {e6, 8}, {d6, 8},
      {c6, 8}, {g5, 8},
      // 7
      {a5, 2}, {d5, 4},
      // 8
      {b4, 4.0 / 3.0},
      // 9 (vocals)
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 10
      {b4, 4}, {a4, 4}, {g4, 4},
      // 11
      {a4, 2}, {f4s, 4},
      // 12
      {d4, 2}, {R, 4},
      // 13
      {a4, 4.0 / 3.0},
      // 14
      {d4, 4.0 / 3.0},
      // 15
      {d5, 4.0 / 3.0},
      // 16
      {b4, 2}, {R, 4},
      // 17
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 18
      {b4, 4}, {a4, 4}, {g4, 4},
      // 19
      {a4, 2}, {f4s, 4},
      // 20
      {d4, 2}, {R, 4},
      // 21
      {g4, 4}, {d5, 4}, {g4, 4},
      // 22
      {f4s, 4}, {d4, 4}, {a4, 4},
      // 23
      {g4, 1},
      // 24
      {R, 4}, {R, 4}
    };
  \end{minted}
  \caption{Массив с нотами для второй дорожки мелодии ``Daisy Bell''.}
  \label{listing:mcu-music-14}
\end{listing}

В конце файла ``music.ino'' мы разместим константы с длинами массивов.

\begin{listing}[H]
  \begin{minted}{cpp}
    const int LENGTH_1 = sizeof(daisy1) / sizeof(daisy1[0]);
    const int LENGTH_2 = sizeof(daisy2) / sizeof(daisy2[0]);
  \end{minted}
  \caption{Длины массивов с нотами мелодии ``Daisy Bell''.}
  \label{listing:mcu-music-15}
\end{listing}

В заголовочном файле ``music.h'' мы пропишем ту же самую структуру
\mintinline{cpp}{track_t}, как и в листинге \ref{listing:mcu-music-3-2}.  Также
нам надо будет экспорировать массивы с мелодией и константы.

\begin{minted}{cpp}
  extern float daisy1[][2];
  extern float daisy2[][2];
  extern const int LENGTH_1;
  extern const int LENGTH_2;
\end{minted}

В главном файле проекта ``daisy\_bell\_2.ino'' отличий не много, по сравнению с
примерами из раздела \ref{subsection:mcu-music-1}.  В верхней части файла мы
разместим константы для указания двух цифровых портов вывода звука.

\begin{minted}{cpp}
  const int SPEAKER_1 = 2;
  const int SPEAKER_2 = 3;
\end{minted}

Далее мы создадим два музыкальных трека.

\begin{minted}{cpp}
  volatile track_t track1;
  volatile track_t track2;
\end{minted}

В процедуре \mintinline{cpp}{setup} настраиваем оба цифровых порта на выход.

\begin{minted}[highlightlines={2-3}]{cpp}
void setup() {
  pinMode(SPEAKER_1, OUTPUT);
  pinMode(SPEAKER_2, OUTPUT);

  // ...
}
\end{minted}

Ниже необходимо инициализировать оба трека.

\begin{minted}[highlightlines={5-14, 16-25}]{cpp}
  void setup() {
    pinMode(SPEAKER_1, OUTPUT);
    pinMode(SPEAKER_2, OUTPUT);

    track1.length = LENGTH_1;
    track1.note_index = 0;
    track1.note_start_time = micros();
    track1.note_length = TAKT / daisy1[0][1];
    track1.note_delay = track1.note_length * DELAY_PERCENT;
    track1.current_time = micros();
    track1.time_diff = 0;
    track1.ocr = frequency_to_timer(daisy1[0][0]);
    track1.counter = track1.ocr;
    track1.speaker_pin_value = HIGH;

    track2.length = LENGTH_2;
    track2.note_index = 0;
    track2.note_start_time = micros();
    track2.note_length = TAKT / daisy2[0][1];
    track2.note_delay = track2.note_length * DELAY_PERCENT;
    track2.current_time = micros();
    track2.time_diff = 0;
    track2.ocr = frequency_to_timer(daisy2[0][0]);
    track2.counter = track2.ocr;
    track2.speaker_pin_value = HIGH;

    // ...
  }
\end{minted}

В конце \mintinline{cpp}{setup} мы инициализируем регистры процессора.
Полностью код процедуры показан в листинге \ref{listing:mcu-music-16}.

\begin{listing}[H]
  \begin{minted}[highlightlines={27-31}]{cpp}
    void setup() {
      pinMode(SPEAKER_1, OUTPUT);
      pinMode(SPEAKER_2, OUTPUT);

      track1.length = LENGTH_1;
      track1.note_index = 0;
      track1.note_start_time = micros();
      track1.note_length = TAKT / daisy1[0][1];
      track1.note_delay = track1.note_length * DELAY_PERCENT;
      track1.current_time = micros();
      track1.time_diff = 0;
      track1.ocr = frequency_to_timer(daisy1[0][0]);
      track1.counter = track1.ocr;
      track1.speaker_pin_value = HIGH;

      track2.length = LENGTH_2;
      track2.note_index = 0;
      track2.note_start_time = micros();
      track2.note_length = TAKT / daisy2[0][1];
      track2.note_delay = track2.note_length * DELAY_PERCENT;
      track2.current_time = micros();
      track2.time_diff = 0;
      track2.ocr = frequency_to_timer(daisy2[0][0]);
      track2.counter = track2.ocr;
      track2.speaker_pin_value = HIGH;

      TCCR1A = B00000000;
      TCCR1B = B00000010;
      OCR1A = 1024;
      OCR1B = 1024;
      TIMSK1 |= B00000110;
    }
  \end{minted}
  \caption{Инициализация регистров процессора для обработки двух прерываний.}
  \label{listing:mcu-music-16}
\end{listing}

Обработчиков прерываний теперь два: \mintinline{cpp}{TIMER1_COMPA_vect} для
первого прерывания, и \mintinline{cpp}{TIMER1_COMPA_vect} -- для второго.
Содержимое обработчиков почти идентично, за исключением того, что в первом
используется \mintinline{cpp}{track1}, а во втором используется
\mintinline{cpp}{track2}.  Листинг кода \mintinline{cpp}{TIMER1_COMPA_vect}
показан в \ref{listing:mcu-music-16}.

\begin{listing}[H]
  \begin{minted}{cpp}
    ISR(TIMER1_COMPA_vect) {
      if (track1.counter > 65535) {
        OCR1A = 65535;
        track1.counter -= 65535;
        return;
      } else {
        OCR1A += track1.counter;
        track1.counter = track1.ocr;
      }

      track1.current_time = micros();
      track1.time_diff \
        = track1.current_time - track1.note_start_time;
      if ((track1.note_length > 0)
          && (track1.time_diff < track1.note_length)) {
        digitalWrite(SPEAKER_1, track1.speaker_pin_value);
        track1.speaker_pin_value = ! track1.speaker_pin_value;
      }

      if (track1.time_diff \
          >= (track1.note_length + track1.note_delay)) {
        track1.note_index \
          = (track1.note_index + 1) % track1.length;
        track1.note_start_time = track1.current_time;
        if (daisy1[track1.note_index][0] > 0) {
          track1.ocr \
            = frequency_to_timer(daisy1[track1.note_index][0]);
          track1.note_length \
            = TAKT / daisy1[track1.note_index][1];
          track1.note_delay \
            = track1.note_length * DELAY_PERCENT;
        } else {
          track1.ocr = 100;
          track1.note_delay \
            = TAKT / daisy1[track1.note_index][1];
          track1.note_delay \
            += track1.note_delay * DELAY_PERCENT;
          track1.note_length = 0;
        }
      }
    }
  \end{minted}
  \caption{Инициализация регистров процессора для обработки двух прерываний.}
  \label{listing:mcu-music-17}
\end{listing}

На данном этапе, если мы загрузим код проекта в Arduino Mega 2560 и подключим
динамик на цифровой порт 2 и 3, то услышим из динамиков мелодию ``Daisy Bell''.

\end{document}
