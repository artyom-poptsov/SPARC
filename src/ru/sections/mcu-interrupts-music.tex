\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программирование музыки через прерывания}

Имея новые знания о прерываниях и таймерах, пришло время вернуться к теме, уже
рассмотренной нами в главе \ref{chapter:sound} -- а именно к теме
программирования звука и музыки.  Ведь благодаря изученному материалу, у нас
появилась возможность совместить одновременно две мелодии на одном
микроконтроллере.  Но обо всём по-порядку.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Генерация звука с помощью таймера}

Как мы уже говорили, прерывания обрабатываются как бы параллельно с работой
процедуры \mintinline{cpp}{loop}.  Используя прерывания, можно добиться как
гораздо более быстрого отклика на внешние события (за счёт внешних прерываний),
так и точной выдержки промежутков времени (за счёт таймеров.)

В главе \ref{chapter:sound} мы использовали самописную процедуру
\mintinline{cpp}{play_tone} для вывода звука, где использовали процедуру
\mintinline{cpp}{delayMicroseconds} для обеспечения времени полупериодов
звуковой волны.  Использование такого подхода имеет как плюсы, так и минусы.  К
плюсам использования простого цикла с задержками можно отнести то, что код
получается достаточно простой и понятный для начинающих (это и послужило
причиной нашего выбора в пользу такого подхода.)  К минусам же можно отнести то,
что процедура \mintinline{cpp}{play_tone} является \emph{блокирующей} -- в том
смысле, что она явно влияет на ход выполнения программы, ведь пока она не
завершиться, компьютер не перейдёт к следующей инструкции.  Кроме того, что для
нас тоже важно -- использование цикла, а также процедур
\mintinline{cpp}{delayMicroseconds} и \mintinline{cpp}{digitalWrite} в нём,
приводило к дополнительным задержкам и неточности (можно даже сказать, к
нестабильности) выходного сигнала.

Мы будем использовать 16-битный ``Timer1'', так как он позволяет отмерять
большие промежутки времени без необходимости написания более сложной логики
программы с нашей стороны.  Диапазон счётчика данного таймера составляет от 0 до
65535.  Нам необходимо написать процедуру перевода желаемой частоты звука в
значение регистра ``OCR1A'', чтобы создать прерывание, переключающее значение
цифрового порта, в нужный момент времени.

Предположим, что мы хотим получить на выходе частоту 50Гц при предделителе 8.
Формула для этого выглядит следующим образом:

\begin{align}
  \mbox{CPU\_FREQUENCY} =& 16000000 \mbox{Гц} \\
  \mbox{PRESCALER} =& 8 \\
  \mbox{FREQUENCY} =& 50 \mbox{Гц} \\
  \mbox{OCR1A} =& \frac{CPU\_FREQUENCY}{PRESCALER * FREQUENCY * 2} - 1 \\
  =& \frac{16000000 \mbox{Гц}}{8 * 50 \mbox{Гц} * 2} - 1 \\
  =& 19999
  \label{equation:mcu-music-1}
\end{align}

Где \texttt{CPU\_FREQUENCY} -- это частота процессора (в нашем случае, 16МГц),
\texttt{PRESCALER} -- это предделитель частоты процессора для таймера,
\texttt{FREQUENCY} -- желаемая частота выходного сигнала.  Умножение на 2 мы
делаем, чтобы получить значение для полупериода.  После подстановки всех
необходимых значений мы получаем число 19999 -- как только счётчик ``Timer1''
достигнет этого значения, как раз пройдёт время полупериода одного колебания.

\begin{listing}[ht]
  \begin{minted}{cpp}
    const unsigned long CPU_FREQ = 16000000UL;
    const double CPU_PRESCALER = 8.0;

    long frequency_to_timer(double f) {
      return (CPU_FREQ / (CPU_PRESCALER * f * 2)) - 1;
    }
  \end{minted}
  \caption{Процедура перевода частоты в значение регистра сравнения ``OCR''.}
  \label{listing:mcu-music-1}
\end{listing}

Что достаточно легко транслируется в код для Arduino, показанный в листинге
\ref{listing:mcu-music-1}.  Процедура \mintinline{cpp}{frequency_to_timer}
возвращает значение для регистра ``OCR''.  Когда счётчик таймера досчитает до
этого значения, то пройдёт как раз время полупериода для заданной частоты.

\begin{listing}[H]
  \begin{minted}{cpp}
    // 01. Частота процессора (16МГц.)
    const unsigned long CPU_FREQ = 16000000UL;
    // 02. Предделитель частоты процессора.
    const double CPU_PRESCALER = 8.0;
    // 03. Частота звука.
    const double FREQ = 50;

    // 04. Процедура для преобразования частоты звука
    //     в значение регистра сравнения "OCR".
    long frequency_to_timer(double f) {
      return (CPU_FREQ / (CPU_PRESCALER * f * 2)) - 1;
    }

    void setup() {
      // 05. Настройка порта D2 на выход.
      DDRE |= 1 << 4;
      TCCR1A = B00000000;
      // 06. Задание предделителя частоты.
      TCCR1B = B00000010;
      // 07. Включение перерывания на таймере 1.
      TIMSK1 |= B00000010;
      // 08. Задание начального значения регистра "OCR".
      OCR1A = frequency_to_timer(FREQ);
      // 09. Задание начального значения LOW для порта D2.
      PORTE &= ~(1 << 4);
    }

    // 10. Обработчик прерывания.
    ISR(TIMER1_COMPA_vect) {
      // 11. Инверсия значения на цифровом порту.
      PORTE ^= 1 << 4;
      // 12. Прибавление времени полупериода к
      //     регистру сравнения, чтобы следующее прерывание
      //     корретно сработало.
      OCR1A += frequency_to_timer(FREQ);
    }

    void loop() {
      // Do nothing.
    }
  \end{minted}
  \caption{Код генерации звука с частотой 50Гц с помощью прерывания по таймеру.}
  \label{listing:mcu-music-2}
\end{listing}

Имея на руках процедуру \mintinline{cpp}{frequency_to_timer}, можно уже
сгенерировать на выходе Arduino звук желаемой частоты, как показано в листинге
\ref{listing:mcu-music-2}.  В данном примере мы генерируем звук с частотой 50Гц
на цифровом порту ``D2''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Генерация музыки}

Как только мы получили возможность генерировать звук, до музыки остаётся один
шаг -- нам нужно каким-то образом выстроить звуки в нужном порядке, чтобы
получить музыкальную композицию.  Мы уже использовали с вами двумерные массивы
для хранения мелодии, здесь мы будем делать тоже самое.

В качестве композиции для программирования возьмём песню ``Daisy Bell'' под
авторством Harry Dacre.\footnote{Используется версия
\url{https://musescore.com/user/33456843/scores/7008698}}

Создадим массив с первыми восемью тактами мелодии.

\begin{listing}[H]
  \begin{minted}{cpp}
    float daisy1[] = {
      // 1
      {d5, 4}, {c5s, 4}, {d5, 4},
      // 2
      {b4, 4}, {a4, 4}, {g4, 4},
      // 3
      {a4, 2}, {f5s, 4},
      // 4
      {d5, 2}, {d6, 4},
      // 5
      {g5, 8}, {d5, 8},
      {e5, 8}, {f5s, 8},
      {g5, 8}, {a5, 8},
      // 6
      {a5s, 8}, {b5, 8},
      {e6, 8}, {d6, 8},
      {c6, 8}, {a5, 8},
      // 7
      {a5, 2}, {d5, 4},
      // 8
      {g5, 2}, {R, 4}
    };
  \end{minted}
  \caption{Часть мелодии ``Daisy Bell''.}
  \label{listing:mcu-music-2}
\end{listing}

Чтобы воспроизвести данную мелодию, нам нужно последовательно брать из массива
ноты и воспроизводить их через прерывания.  Ситуация усложняется тем, что теперь
нельзя просто так взять, и использовать привычный нам цикл.

Для упрощения работы сделаем структуру, которая описывает музыкальный трек.

\begin{listing}[H]
  \begin{minted}{cpp}
    typedef struct {
      // Индекс (номер) ноты.
      int  note_index;

      // Время начала воспроизведения ноты.
      long note_start_time;

      // Длина ноты.
      long note_length;

      // Задержка после ноты.
      long note_delay;

      // Текущее время.
      long current_time;

      // Время, прошедшее с начала воспроизведения
      // ноты.
      long time_diff;

      // Виртуальный регистр OCR.
      long ocr;

      // Счётчик для таймера.
      long counter;

      // Цифровой порт для вывода звука.
      byte speaker_pin;

      // Текущее значение на выходном цифровом порту.
      byte speaker_pin_value;
    } track_t;
  \end{minted}
  \caption{Структура, описывающая музыкальный трек.}
  \label{listing:mcu-music-3}
\end{listing}

В структуре, показанной в листинге \ref{listing:mcu-music-3}, мы предусмотрели
все необходимые поля, которые потребуются внутри обработчика прерывания.

\mintinline{cpp}{note_index} является индексом ноты в массиве нот.  Данный
индекс будет использоваться для получения ноты из массива, и будет прибавляться
для перехода на другую ноту.

\mintinline{cpp}{note_start_time} хранит время начала воспроизведения ноты (в
микросекундах.)

\mintinline{cpp}{note_length} хранит время звучания ноты (в микросекундах),
которая рассчитывается исходя из длины такта и длины ноты.

\mintinline{cpp}{current_time} хранит текущее время (в микросекундах.)

\mintinline{cpp}{time_diff} хранит время, прошедшее с начала воспроизведения
ноты.  Для вычисления этого времени мы будем вычитать время начала
воспроизведения ноты \mintinline{cpp}{note_start_time} из текущего времени
\mintinline{cpp}{current_time}.

\mintinline{cpp}{ocr} Виртуальный регистр OCR.  Значение данного поля может быть
больше, чем максимальное значение физического регистра OCR, что позволяет
отсчитывать большие промежутки времени.

\mintinline{cpp}{increment} хранит значение, на которое прибавляется регистр
сравнения OCR, используемого для прерывания.

\mintinline{cpp}{speaker_pin} хранит номер цифрового порта, на который выводится
звук.

\mintinline{cpp}{speaker_pin_value} хранит текущее значение цифрового порта
\mintinline{cpp}{speaker_pin}.

Далее нам необходимо задать в основном файле, в глобальной области констнанты.
Здесь мы укажем частоту процессора, предделитель частоты и другие необходимые
нам параметры, в том числе \gls{BPM} -- для мелодии ``Daisy Bell'' он равен 172
ударам в минуту.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Порт вывода звука.
    const int SPEAKER_1 = 2;

    // Частота процессора.
    const long CPU_FREQ = 16000000; // Гц

    // Предделитель частоты.
    const long CPU_PRESCALER = 8.0;

    // Время между нотами, равное проценту от длины ноты.
    const float DELAY_PERCENT = 0.05;

    // Скорость мелодии "Daisy Bell".
    const int BPM = 172; // Beats per minute.

    // Одна минута, заданная в микросекундах.
    const long MINUTE = 60000000; // мкс

    // Длина такта.
    const long TAKT = (MINUTE / BPM) * 4; // мкс
  \end{minted}
  \caption{Константы, необходимые для генерации мелодии.}
  \label{listing:mcu-music-4}
\end{listing}

В глобальной области мы разместим также экземпляр структуры
\mintinline{cpp}{track_t}, который мы просто назовём \mintinline{cpp}{track1}.

\begin{listing}[H]
  \begin{minted}{cpp}
    volatile track_t track1;
  \end{minted}
  \caption{Создание экземпляра структуры \mintinline{cpp}{track_t}.}
  \label{listing:mcu-music-5}
\end{listing}

Как было сказано в разделе \ref{subsection:isr}, необходимо использовать
ключевое слово \mintinline{cpp}{volatile} для того, чтобы компилятор сохранил
переменную \mintinline{cpp}{track1} при оптимизации.

Здесь же, в глобальной области, разместим и процедуру
\mintinline{cpp}{frequency_to_timer}.

\begin{listing}[H]
  \begin{minted}{cpp}
    long frequency_to_timer(double f) {
      return (CPU_FREQ / (CPU_PRESCALER * f * 2)) - 1;
    }
  \end{minted}
  \caption{Процедура для преобразования частоты звука в значение регистра
    сравнения ``OCR''.}
  \label{listing:mcu-music-6}
\end{listing}

В процедуре \mintinline{cpp}{setup} необходимо проинициализировать порты и
экземпляр структуры \mintinline{cpp}{track_t}.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(SPEAKER_1, OUTPUT);

      track1.note_index = 0;
      track1.note_start_time = micros();
      track1.note_length = TAKT / daisy1[0][1];
      track1.note_delay = track1.note_length * DELAY_PERCENT;
      track1.current_time = micros();
      track1.time_diff = 0;
      track1.ocr = frequency_to_timer(daisy1[0][0]);
      track1.counter = track1.ocr;
      track1.speaker_pin_value = HIGH;

      // ...
    }
  \end{minted}
  \caption{Инициализация цифрового порта и структуры.}
  \label{listing:mcu-music-7}
\end{listing}

Затем в \mintinline{cpp}{setup} надо проинициализировать также регистры
процессора, для обработки прерываний от таймера.

\begin{listing}[H]
  \begin{minted}[highlightlines={13-15}]{cpp}
    void setup() {
      pinMode(SPEAKER_1, OUTPUT);

      track1.note_index = 0;
      track1.note_start_time = micros();
      track1.note_length = TAKT / daisy1[0][1];
      track1.note_delay = track1.note_length * DELAY_PERCENT;
      track1.current_time = micros();
      track1.time_diff = 0;
      track1.ocr = frequency_to_timer(daisy1[0][0]);
      track1.counter = track1.ocr;
      track1.speaker_pin_value = HIGH;

      TCCR1B |= B00000010;
      OCR1A = 1024;
      TIMSK1 |= B00000010;
    }
  \end{minted}
  \caption{Инициализация регистров процессора.}
  \label{listing:mcu-music-8}
\end{listing}

Далее нам необходимо реализовать обработчик прерывания
\mintinline{cpp}{TIMER1_COMPA_vect}.

\begin{listing}[H]
  \begin{minted}{cpp}
    ISR(TIMER1_COMPA_vect) {
      if (track1.counter > 65535) {
        OCR1A = 65535;
        track1.counter -= 65535;
        return;
      } else {
        OCR1A += track1.counter;
        track1.counter = track1.ocr;
      }

      // ...
    }
  \end{minted}
  \caption{Задание значения для регистра ``OCR1A'' в обработчике прерывания.}
  \label{listing:mcu-music-9}
\end{listing}

Первым делом в обработчике мы должны задать новое значение регистра ``OCR1A''.
Возможна ситуация, в которой значение счётчика \mintinline{cpp}{track1.counter}
больше, чем максимальное значение 16-битного регистра ``OCR1A'' (65535) -- такое
может возникнуть, если частота звука достаточно низка.  В связи с этим мы не
можем просто писать в регистр это значение напрямую.

Чтобы решить эту проблему, мы используем условие, где проверяем -- если значение
\mintinline{cpp}{track1.counter} больше 65535, то тогда в регистр ``OCR1A''
записывается максиально возможное число и значение
\mintinline{cpp}{track1.counter} уменьшается на значение 65535.  Далее мы делаем
выход из процедуры обработчика прерывания через \mintinline{cpp}{return}, и
таким образом пропускам одно прерывание.  Так может повторяться несколько раз.
Как только значение \mintinline{cpp}{track1.counter} становится меньше
максимального значения регистра ``OCR1A'', то мы добавляем это значение в
регистр и сбрасываем \mintinline{cpp}{track1.counter} в значение
\mintinline{cpp}{track1.ocr}.

\end{document}
