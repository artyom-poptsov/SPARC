\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программирование музыки через прерывания}

Имея новые знания о прерываниях и таймерах, пришло время вернуться к теме, уже
рассмотренной нами в главе \ref{chapter:sound} -- а именно к теме
программирования звука и музыки.  Ведь благодаря изученному материалу, у нас
появилась возможность совместить одновременно две мелодии на одном
микроконтроллере.  Но обо всём по-порядку.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Генерация звука с помощью таймера}

Как мы уже говорили, прерывания обрабатываются как бы параллельно с работой
процедуры \mintinline{cpp}{loop}.  Используя прерывания, можно добиться как
гораздо более быстрого отклика на внешние события (за счёт внешних прерываний),
так и точной выдержки промежутков времени (за счёт таймеров.)

В главе \ref{chapter:sound} мы использовали самописную процедуру
\mintinline{cpp}{play_tone} для вывода звука, где использовали процедуру
\mintinline{cpp}{delayMicroseconds} для обеспечения времени полупериодов
звуковой волны.  Использование такого подхода имеет как плюсы, так и минусы.  К
плюсам использования простого цикла с задержками можно отнести то, что код
получается достаточно простой и понятный для начинающих (это и послужило
причиной нашего выбора в пользу такого подхода.)  К минусам же можно отнести то,
что процедура \mintinline{cpp}{play_tone} является \emph{блокирующей} -- в том
смысле, что она явно влияет на ход выполнения программы, ведь пока она не
завершиться, компьютер не перейдёт к следующей инструкции.  Кроме того, что для
нас тоже важно -- использование цикла, а также процедур
\mintinline{cpp}{delayMicroseconds} и \mintinline{cpp}{digitalWrite} в нём,
приводило к дополнительным задержкам и неточности (можно даже сказать, к
нестабильности) выходного сигнала.

Мы будем использовать 16-битный ``Timer1'', так как он позволяет отмерять
большие промежутки времени без необходимости написания более сложной логики
программы с нашей стороны.  Диапазон счётчика данного таймера составляет от 0 до
65535.  Нам необходимо написать процедуру перевода желаемой частоты звука в
значение регистра ``OCR1A'', чтобы создать прерывание, переключающее значение
цифрового порта, в нужный момент времени.

Предположим, что мы хотим получить на выходе частоту 50Гц при предделителе 8.
Формула для этого выглядит следующим образом:

\begin{align}
  \mbox{CPU\_FREQUENCY} =& 16000000 \mbox{Гц} \\
  \mbox{PRESCALER} =& 8 \\
  \mbox{FREQUENCY} =& 50 \mbox{Гц} \\
  \mbox{OCR1A} =& \frac{CPU\_FREQUENCY}{PRESCALER * FREQUENCY * 2} - 1 \\
  =& \frac{16000000 \mbox{Гц}}{8 * 50 \mbox{Гц} * 2} - 1 \\
  =& 19999
  \label{equation:mcu-music-1}
\end{align}

Где \texttt{CPU\_FREQUENCY} -- это частота процессора (в нашем случае, 16МГц),
\texttt{PRESCALER} -- это предделитель частоты процессора для таймера,
\texttt{FREQUENCY} -- желаемая частота выходного сигнала.  Умножение на 2 мы
делаем, чтобы получить значение для полупериода.  После подстановки всех
необходимых значений мы получаем число 19999 -- как только счётчик ``Timer1''
достигнет этого значения, как раз пройдёт время полупериода одного колебания.

Что достаточно легко транслируется в следующий код для Arduino:

\begin{listing}[H]
  \begin{minted}{cpp}
    const unsigned long CPU_FREQ = 16000000UL;
    const double CPU_PRESCALER = 8.0;

    long frequency_to_timer(double f) {
      return (CPU_FREQ / (CPU_PRESCALER * f * 2)) - 1;
    }
  \end{minted}
  \caption{Процедура перевода частоты в значение регистра сравнения ``OCR''.}
  \label{listing:mcu-music-1}
\end{listing}

\end{document}
