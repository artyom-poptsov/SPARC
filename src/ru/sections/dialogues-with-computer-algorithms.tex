\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Алгоритмы}
\index{Программирование!Алгоритм}

Задолго до появления компьютеров люди писали инструкции друг для друга, которые
позволяли понять последовательность действий для достижения какой-либо цели --
например, ``как добыть огонь'', ``как сеять зерно'', ``как запрячь лошадь'' и
т.п.

Последовательность инструкций, позволяющая достичь определённого результата,
называется \emph{алгоритмом}.

Были попытки (достаточно успешные) создания разных механизмов, выполняющих некую
последовательность операций, заменяя тем самым человека.  Но с появлением
компьютеров разработка алгоритмов вышла на ``новый уровень'' -- мы получили
возможность записать алгоритм в память компьютера для того, чтобы он выполнил
его в точности так, как мы задумывали.  Современные компьютеры не понимают язык
человека напрямую, поэтому им необходимо задавать алгоритмы в специальном
\emph{машинном языке}.  Машинный язык представляет собой коды команд обработки
данных, понимаемые процессором (главным вычислителем в компьютере.)

Написание программ на машинном языке является достаточно муторным и сложным
процессом, и вскоре после появления компьютеров были придуманы первые языки
программирования, более близкие человеку.  Первым языком программирования был
\emph{ассемблер}, который по своей сути представлял из себя набор мнемоник --
коротких человекочитаемых имён -- для машинных команды процессора.

Но и ассемблер был по своей сути слишком прост и не позволял кратко и легко
выражать идеи, которые люди хотели заложить в свои алгоритмы.  Поэтому были
придуманы высокоуровневые языки программирования, позволяющие упростить и
ускорить написание программ.  Язык ``C'', основы которого будут рассмотрены в
этой главе, является одним из старейших языков программирования, активно
используемых по сей день.

Чтобы попрактиковаться в составлении алгоритмов, предположим, что у нас есть
светодиод или лампочка, подключенная к компьютеру.  Чтобы объяснить компьютеру,
как сделать эффект мигания лампочки, мы должны сформулировать алгоритм.  Это
процесс называется \emph{формализацией}.  Возможный алгоритм мигания светодиодом
может выглядеть так:

\begin{enumerate}
\item Включить светодиод.
\item Выключить светодиод
\item Повторить алгоритм.
\end{enumerate}

Таким образом, на примере данного алгоритма мы видим не только действия по
включению и выключению условного светодиода, но и некоторую повторяемость,
\emph{цикличность} этих действий.

\experiment{0} { Попробуйте придумать алгоритмы для обыденных операций, которые
  вы выполняете каждый день.  Например, алгоритм заваривания чая, или же
  алгоритм уборки квартиры.  Насколько детально вы сможете объяснить порядок
  выполнения простых действий?  Насколько сложными получаются алгоритмы?}

При составлении алгоритмов необходимо учитывать, что компьютеры в большинстве
своём имеют два важных свойства:
\begin{enumerate}
\item С одной стороны, компьютеры очень быстрые в определённых задачах.  Даже
  центральный процессор микроконтроллерной платформы Arduino Mega 2560 имеет
  частоту 16МГц\footnote{\url{https://docs.arduino.cc/hardware/mega-2560/}}, что
  даёт приблизительно 16 миллионов операций в секунду\footnote{На самом деле,
  конечно меньше, так как разные инструкции процессора занимают разное
  количество циклов.}.  Современные компьютеры значительно превосходят человека
  в скорости вычислений и объёмах хранимой информации.
\item С другой стороны, компьютеры в большинстве своём достаточно ``тупые'' -- в
  том плане, что они делают только то, что было записано в инструкциях.  Мы
  здесь не говорим про более ``интеллектуальные'' системы вроде больших языковых
  моделей и других примеров систем со сложным поведением.
\end{enumerate}

Исходя из этого можно сказать, что компьютер будет очень быстро и усердно делать
то, что программист укажет в программе, даже если инструкции неправильные (при
условии, что они правильно записаны -- т.е. нет синтаксических ошибок.)

Поэтому даже формулирование алгоритмов для, казалось бы, простых операций,
требует большой внимательности.

Например, алгоритм мигания одним светодиодом, который мы сформулировали выше,
имеет один важный недостаток: в нём отсутствует явное указание времени
выполнения операций.  Хотя операция мигания светодиодом по нашему интуитивному
представлению подразумевает некоторую задержку после включения и после
выключения, в алгоритме это явно не указано -- а это значит, что компьютер будет
выполнять эти операции так быстро, насколько способна система.  Результатом
будет то, что для нас светодиод будет казаться постоянно включённым.

Доработаем алгоритм, явно добавив в него необходимые задержки в половину секунды
(500 мс):
\begin{enumerate}
\item Включить светодиод.
\item Подождать 500 мс.
\item Выключить светодиод
\item Подождать 500 мс.
\item Повторить алгоритм.
\end{enumerate}

Чтобы данный алгоритм в принципе мог быть выполнен обычным компьютером, его надо
перевести на некий промежуточный язык, который понятен и человеку, и компьютеру
(при наличии специального переводчика -- \emph{компилятора}.)

\end{document}
