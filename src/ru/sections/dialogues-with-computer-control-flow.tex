\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Управляющие конструкции}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Условия}
\index{Программирование!Условие}

Иногда во время выполнения программы следует принять решение о том, что делать
дальше.  Для того, чтобы компьютер мог сделать правильный выбор, по какому пути
пойти, нам, как программистам, следует описать условия в коде программы: если
условие выполняется, делаем одно, иначе -- делаем другое.

Условия в программах описываются при помощи специальных управляющих конструкций.
В языке C++ у нас есть две основные конструкции.  Первая из них -- оператор
\texttt{if} (буквально в переводе с английского ``если'').  Пример
использования:

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 42;
    if (a > 10) {
      // действие, выполняемое, если значение
      // переменной 'a' больше 10.  В данном случае
      // действие будет выполняться всегда, так как
      // переменная всегда равна 42.
    }
  \end{minted}
  \label{listing:dialogues-with-computer-if-more-than}
  \caption{Пример использования условия (\texttt{if}) для проверки, что значение
    переменной больше числа 10.}
\end{listing}

Если нужно проверить равно ли значение переменной чему-либо, используют оператор
сравнения ``=='':

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 42;
    if (a == 10) {
      // действие, выполняемое, если значение
      // переменной 'a' равно 10.  В данном случае
      // действие никогда выполнено не будет, так как
      // переменная равна 42, что никогда не навно 10.
    }
  \end{minted}
  \label{listing:dialogues-with-computer-if-equals}
  \caption{Пример использования условия (\texttt{if}) для проверки, что значение
    переменной равно числу 10.}
\end{listing}

\note{ Не путайте \emph{оператор сравнения} ``=='' с \emph{оператором
  присваивания} ``='' -- это важно!  Дело в том, что во многих случаях языки
  C/C++ позволяют использовать любой из операторов в одном месте, однако
  результат их работы будет совершенно разный.  В языке C++ знак ``=''
  используется в нескольких ``ролях'', но если мы говорим про работу с
  переменными, то оператор присваивания всегда меняет то, что стоит слева от
  него.}

Проще всего запомнить различие так: одно равно -- присвоение, два равно --
сравнение.

Чтобы наглядно показать различие между оператором сравнения и оператором
присваивания, изменим пример \ref{listing:dialogues-with-computer-if-equals}.

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 42;
    if (a = 10) {
      // действие, выполняемое, если значение
      // переменной 'a' равно 10.  В данном случае
      // действие всегда будет выполняться!
    }
  \end{minted}
  \label{listing:dialogues-with-computer-if-equals-assignment}
  \caption{Пример ошибки с подстановкой оператора присвоения вместо оператора
    сравнения.}
\end{listing}

В листинге \ref{listing:dialogues-with-computer-if-equals-assignment} действие в
теле условия \texttt{if} будет выполняться всегда, несмотря на то, что 42
никогда не равно 10 -- причиной этому является то, что в круглых скобках оператор
присвоения ``='' \emph{изменяет} значение \texttt{a} и оно становится равно 10.
После этого в круглые скобки \texttt{if} подставляется значение \texttt{a} (то
есть, число 10) и система рассматривает это значение, как логический результат --
а с точки зрения языков C/C++ всё, что не ноль, является истинной.

Часто необходимо не только делать что-либо при выполнении условия, но и
предоставить альтернативную инструкцию (или набор инструкций), выполняемую
тогда, когда условие не выполняется.  В этом случае используют конструкцию
\texttt{if..else}:

\begin{listing}[ht]
  \begin{minted}{cpp}
    if (a > 10) {
      // действие, выполняемое, если значение
      // переменной 'a' больше 10.
    } else {
      // действие, выполняемое, если значение
      // переменной 'a' меньше или равно 10.
    }
  \end{minted}
  \label{listing:dialogues-with-computer-if-with-else}
  \caption{Пример использования условия (\texttt{if}) с блоком \texttt{else} для
    обеспечения ветвления хода выполнения программы.}
\end{listing}

Второй оператор, который нам будет встречаться, это так называемый
\emph{оператор выбора} \texttt{switch}.  С ним познакомимся позже.  Он удобен,
например, тогда, когда нам нужно выполнять несколько разных действий в
зависимости от значения переменной, и этих действий много.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Циклы}
\index{Программирование!Цикл}

Простые программы, вроде ``бегущего огня'', могут быть написаны простым
копированием и вставкой алгоритма мигания светодиода (возможно, с небольшими
модификациями).

А теперь представьте, что вам требуется запрограммировать ``бегущий огонь'' на
100 светодиодов. Утомительная задача, не правда ли? Для того, чтобы не делать
тупую работу по копированию одного и того же кода много раз, программистами
придуманы специальные управляющие конструкции, называемые \emph{циклами}.

Циклы бывают разные. Основные виды циклов, которые вам будут встречаться
практически в любом языке программирования:
\begin{itemize}
\item Цикл со счётчиком (также называемый ``параметрический цикл'').
\item Цикл с предусловием.
\item Цикл с постусловием.
\end{itemize}

Каждый вид циклов имеет собственную реализацию в языке программирования, который
мы используем (C++).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Цикл со счётчиком}
\index{Программирование!Цикл!Цикл со счётчиком (for)}

Цикл со счётчиком реализуется конструкцией \texttt{for} -- она позволяет нам
создать счётчик, задать его начальное значение, описать условие выполнения цикла
и операцию изменения счётчика:

\begin{listing}[ht]
  \begin{minted}{cpp}
    //                   5.
    //        1.         2.           4.
    for (int pin = 0; pin < 10; pin = pin + 1) {
      // 3. (тело цикла)
    }
  \end{minted}
  \label{listing:dialogues-with-computer-for}
  \caption{Цикл со счётчиком \texttt{for} с указанием порядка выполнения шагов
    цикла.}
\end{listing}

Выполняется эта конструкция в следующем порядке:
\begin{enumerate}
\item объявляем переменную и присваиваем ей значение 0 (шаг 1);
\item переходим к проверке, где смотрим, выполняется ли условие (шаг 2);
\item после этого, если условие 2 выполняется, мы переходим к телу цикла (шаг 3);
\item после выполнения тела цикла, мы переходим к изменению значения счётчика (шаг 4);
\item после шага 4 мы опять возвращаемся к шагу 2, если условие выполняется, то
  переходим к шагу 3 и т.д.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Цикл с предусловием}
\index{Программирование!Цикл!Цикл с предусловием (while)}

Другим распространённым видом цикла является цикл с предусловием, реализуемый в
С++ конструкцией \texttt{while} -- данный вид цикла удобен в тех случаях, когда
мы не знаем точного количества раз, сколько нужно повторить тело цикла (не знаем
количество итераций.)

Общий вид цикла \texttt{while} таков:

\begin{listing}[ht]
  \begin{minted}{cpp}
    int pin = 2;

    while (pin < 10) {
      // тело цикла
    }
  \end{minted}
  \label{listing:dialogues-with-computer-while}
  \caption{Цикл со предусловием \texttt{while}.}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Цикл с постусловием}
\index{Программирование!Цикл!Цикл с постусловием (do..while)}

Кроме вышеперечисленных видов циклов, есть ещё цикл с постусловием, где
проверка условия выполнения цикла осуществляется после выполнения тела цикла.
Реализуется данный вид циклов конструкцией \texttt{do..while}.

Общий вид цикла \texttt{do..while} таков:

\begin{listing}[ht]
  \begin{minted}{cpp}
    int pin = 2;

    do {
      // тело цикла
    } while (pin < 10);
  \end{minted}
  \label{listing:dialogues-with-computer-do-while}
  \caption{Цикл с постусловием \texttt{do..while}.}
\end{listing}

Исходя из свойства данного вида цикла можно заметить интересный момент: даже
если условие ложно \emph{перед} началом цикла, тело цикла выполнится один раз.
Таким образом можно сказать, что \emph{тело цикла с пост-условием всегда
выполняется хотя бы один раз}.

Возьмём для примера следующий код:

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 2;

    do {
      digitalWrite(13, HIGH);
      delay(200);
      digitalWrite(13, LOW);
      delay(200);
      a = a + 1;
    } while (a < 1);
  \end{minted}
  \label{listing:dialogues-with-computer-do-while-example}
  \caption{Пример использования цикла с постусловием \texttt{do..while}.}
\end{listing}

В данном примере, несмотря на то, что изначально переменная \texttt{a} имеет
значение 2, а по условию цикла переменная \texttt{a} должна быть меньше 1,
светодиод на 13-м порту мигнёт один раз.

Данный вид цикла достаточно редко используется, но в некоторых случаях он очень
удобен.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Зачем столько видов циклов?}

Обратите внимание, что один вид цикла может быть реализован через другой, т.к.
данные управляющие конструкции взаимозаменяемы. Возникает вопрос -- зачем же нам
нужно столько видов циклов? Всё дело в удобстве. В одних случаях удобнее
использовать один вид циклов, в других случаях -- другой.

У программистов есть специальный термин для описания подобных конструкций языка
программирования: \emph{синтаксический сахар}.  Синтаксический сахар -- это
конструкции языка, без которых в принципе можно обойтись при разработке
программ, но с ними всё проще (``слаще''.)

\section{Задачи}
\begin{enumerate}
\item Перепишите ``бегущий огонь'' с использованием цикла.
\item Модифицируйте алгоритм ``бегущего огня'' таким образом, чтобы светодиоды
  начинали загораться с обоих концов гирлянды, и огни ``бежали'' навстречу друг
  другу.
\end{enumerate}

\end{document}
