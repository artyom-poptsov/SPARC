\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Управляющие конструкции}

Команды (операторы) языка программирования, которые отвечают за управление ходом
выполнения программы называются \emph{управляющими конструкциями}.  К ним
относятся команды \emph{ветвления}, \emph{циклов} и другие подобные им.  В целом
можно сказать, что если команда языка изменяет последовательный ход выполнения
кода, то её можно отнести к управляющим конструкциям.

В данном разделе мы посмотрим на основные виды управляющих конструкций, которые
присутствуют в C++ и большинстве других популярных языков программирования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Условия}
\index{Программирование!Условие}

Иногда во время выполнения программы следует принять решение о том, что делать
дальше.  Для того, чтобы компьютер мог сделать правильный выбор, по какому пути
пойти, нам, как программистам, следует описать условия в коде программы: если
условие выполняется, делаем одно, иначе -- делаем другое.

Условия в программах описываются при помощи специальных управляющих конструкций.
В языке C++ у нас есть две основные конструкции.  Первая из них -- оператор
\texttt{if} (буквально в переводе с английского ``если'').  Пример
использования:

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 42;
    if (a > 10) {
      // действие, выполняемое, если значение
      // переменной 'a' больше 10.  В данном случае
      // действие будет выполняться всегда, так как
      // переменная всегда равна 42.
    }
  \end{minted}
  \label{listing:dialogues-with-computer-if-more-than}
  \caption{Пример использования условия (\texttt{if}) для проверки, что значение
    переменной больше числа 10.}
\end{listing}

Если нужно проверить равно ли значение переменной чему-либо, используют оператор
сравнения ``=='':

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 42;
    if (a == 10) {
      // действие, выполняемое, если значение
      // переменной 'a' равно 10.  В данном случае
      // действие никогда выполнено не будет, так как
      // переменная равна 42, что никогда не навно 10.
    }
  \end{minted}
  \label{listing:dialogues-with-computer-if-equals}
  \caption{Пример использования условия (\texttt{if}) для проверки, что значение
    переменной равно числу 10.}
\end{listing}

\note{ Не путайте \emph{оператор сравнения} ``=='' с \emph{оператором
  присваивания} ``='' -- это важно!  Дело в том, что во многих случаях языки
  C/C++ позволяют использовать любой из операторов в одном месте, однако
  результат их работы будет совершенно разный.  В языке C++ знак ``=''
  используется в нескольких ``ролях'', но если мы говорим про работу с
  переменными, то оператор присваивания всегда меняет то, что стоит слева от
  него.}

Проще всего запомнить различие так: одно равно -- присвоение, два равно --
сравнение.

Чтобы наглядно показать различие между оператором сравнения и оператором
присваивания, изменим пример \ref{listing:dialogues-with-computer-if-equals}.

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 42;
    if (a = 10) {
      // действие, выполняемое, если значение
      // переменной 'a' равно 10.  В данном случае
      // действие всегда будет выполняться!
    }
  \end{minted}
  \label{listing:dialogues-with-computer-if-equals-assignment}
  \caption{Пример ошибки с подстановкой оператора присвоения вместо оператора
    сравнения.}
\end{listing}

В листинге \ref{listing:dialogues-with-computer-if-equals-assignment} действие в
теле условия \texttt{if} будет выполняться всегда, несмотря на то, что 42
никогда не равно 10 -- причиной этому является то, что в круглых скобках оператор
присвоения ``='' \emph{изменяет} значение \texttt{a} и оно становится равно 10.
После этого в круглые скобки \texttt{if} подставляется значение \texttt{a} (то
есть, число 10) и система рассматривает это значение, как логический результат --
а с точки зрения языков C/C++ всё, что не ноль, является истинной.

Часто необходимо не только делать что-либо при выполнении условия, но и
предоставить альтернативную инструкцию (или набор инструкций), выполняемую
тогда, когда условие не выполняется.  В этом случае используют конструкцию
\texttt{if..else}:

\begin{listing}[ht]
  \begin{minted}{cpp}
    if (a > 10) {
      // действие, выполняемое, если значение
      // переменной 'a' больше 10.
    } else {
      // действие, выполняемое, если значение
      // переменной 'a' меньше или равно 10.
    }
  \end{minted}
  \label{listing:dialogues-with-computer-if-with-else}
  \caption{Пример использования условия (\texttt{if}) с блоком \texttt{else} для
    обеспечения ветвления хода выполнения программы.}
\end{listing}

Второй оператор, который нам будет встречаться, это так называемый
\emph{оператор выбора} \texttt{switch..case}.  Он удобен, например, тогда, когда
нам нужно выполнять несколько разных действий в зависимости от значения
переменной, и этих действий много.

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 42;
    switch (a) {
      case 10:
        // Действие, если значение 'a' равно 10.
        break;
      case 42:
        // Действие, если значение 'a' равно 42.
        break;
      case 20:
        // Действие, если значение 'a' равно 20.
      case 30:
        // Действие, если значение 'a' равно 20 или 30.
        break;
      case 1:
      case 2:
        // Действие, если значение 'a' равно 1 или 2.
        break;
      default:
        // Действие, если значение 'a' не равно ни одному
        // из вышеперечисленных.
    }
  \end{minted}
  \label{listing:dialogues-with-computer-switch-case}
  \caption{Пример использования оператора множественного выбора
    \texttt{switch..case}.}
\end{listing}

В листинге \ref{listing:dialogues-with-computer-switch-case} показан пример
использования оператора \texttt{switch..case}.  Как можно видеть в примере,
значение переменной \texttt{a} сравнивается поочерёдно с вариантами,
обозначенными \texttt{case}.  Выполняется первый \texttt{case}, который совпал
со значением \texttt{a}, после чего происходит выход из \texttt{switch..case}.

Обратите также внимание на ключевое слово \texttt{break} -- оно указывает место,
где происходит выход из \texttt{switch..case}.  В примере можно видеть, что в
одном месте идут подряд два \texttt{case} -- для значения 20 и для значения 30, а
\texttt{break} стоит только один, после \texttt{case 30}.  Это означает, что
если \texttt{a} равно 20, то будет сделано соответствующий набор инструкций, а
потом уже без всяких проверок будет выполнено тот набор инструкций, что идёт
после \texttt{case 30}.  Похожая ситуация будет в случае с \texttt{case 1} и
\texttt{case 2}, различия лишь в том, что после \texttt{case 1} нет никаких
инструкций -- иными словами, при значениях 1 и 2 будет выполнен тот код, что идёт
после \texttt{case 2}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Циклы}
\index{Программирование!Цикл}

Простые программы, вроде ``бегущего огня'', могут быть написаны простым
копированием и вставкой алгоритма мигания светодиода (возможно, с небольшими
модификациями).

А теперь представьте, что вам требуется запрограммировать ``бегущий огонь'' на
100 светодиодов. Утомительная задача, не правда ли? Для того, чтобы не делать
тупую работу по копированию одного и того же кода много раз, программистами
придуманы специальные управляющие конструкции, называемые \emph{циклами}.

Циклы бывают разные. Основные виды циклов, которые вам будут встречаться
практически в любом языке программирования:
\begin{itemize}
\item Цикл со счётчиком (также называемый ``параметрический цикл'').
\item Цикл с предусловием.
\item Цикл с постусловием.
\end{itemize}

Каждый вид циклов имеет собственную реализацию в языке программирования, который
мы используем (C++).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Цикл с предусловием}
\index{Программирование!Цикл!Цикл с предусловием (while)}

Самым простым видом цикла является \emph{цикл с предусловием}, реализуемый в С++
конструкцией \texttt{while} -- данный вид цикла удобен в тех случаях, когда мы не
знаем точного количества раз, сколько нужно повторить тело цикла (не знаем
количество итераций.)

Общий вид цикла \texttt{while} таков:

\begin{listing}[ht]
  \begin{minted}{cpp}
    int t = 0;

    while (t < 12) {
      // тело цикла
    }
  \end{minted}
  \label{listing:dialogues-with-computer-while}
  \caption{Цикл со предусловием \texttt{while}.}
\end{listing}

Визуализация информации часто помогает лучше понять суть материала. Один из
способов визуализации циклов заключается в представлении линии времени, на
которой происходят некоторые события, как показано на рис.
\ref{fig:control-flow-while-loop}.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \draw[-{Stealth[gray]}] (0, 0) -- (11, 0);
    \foreach \x in {1, 2, ..., 10} {
      \draw (\x, 0.1) -- (\x, -0.1) node[below] {$\x$};
      \draw[dotted, red] (\x, 0.1) -- (\x, 0.5);
    };
    \draw (1.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{int t = 0}$}};
    \draw (2.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{t < 12}$}};
    \draw (3.50, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Тело цикла}$}};
    \draw (4.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{t < 12}$}};
    \draw (5.50, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Тело цикла}$}};
    \draw (6.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{t < 12}$}};
    \draw (7.50, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Тело цикла}$}};
    \draw (8.00, 0.5)  node[above, red] {$\mbox{...}$};
    \draw (11, 0) node[below] {$t$};
  \end{tikzpicture}
  \label{fig:control-flow-while-loop}
  \caption{Визуальное представление цикла \texttt{while}.}
\end{figure}

Как мы видим, цикл есть процесс, протяжённый во времени. Данный процесс может
быть разделён на следующие шаги:

\begin{enumerate}
\item Объявляем переменную и присваиваем ей значение 0.
\item Переходим к проверке, где смотрим, выполняется ли условие.
\item После этого, если условие выполняется, мы переходим к телу цикла.
\item После этого мы опять повторяем проверку (как и на шаге 2) -- если условие
  выполняется, то переходим к выполнению тела цикла и т.д.
\end{enumerate}

Цикл \texttt{while} удобен в тех случаях, когда нам нужно циклически выполнять
некий набор действий и нам известно условие, при котором цикл должен
продолжаться.  При этом, количество повторений может различаться в зависимости
от того, сколько раз условие будет выполняться.

Предположим, что на рис. \ref{fig:control-flow-while-loop} показан некий бытовой
процесс -- например, вы пригласили на день рождения друзей и хотите угостить их
пирожками собственного изготовления.  На то, чтобы испечь пирожки, у вас есть
время только до 12 часов дня.  Вы начинаете работать утром.  Процесс
изготовления одного пирожка известен -- он описан в рецепте (алгоритме), и вам
нужно повторять этот алгоритм.  Вы смотрите на часы и если время ещё меньше 12
часов, то начинаете делать пирожок.  После завершения изготовления одного
пирожка вы смотрите на часы и если время ещё меньше 12 часов, то начинаете
изготовления следующего пирожка, и так далее.  Таким образом, количество
изготовленных пирожков может варьироваться в зависимости от скорости вашей
работы и сложности рецепта, однако вы в любом случае закончите работу в 12
часов.

При этом, важно правильно прописать условие работы цикла, иначе может получится
так, что вы например будете делать пирожки не до 12 часов текущего дня, а до 12
часов следующего дня, или вообще можете уйти в \emph{бесконечный цикл}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Цикл со счётчиком}
\index{Программирование!Цикл!Цикл со счётчиком (for)}

Другим популярным видом цикла является \emph{цикл со счётчиком}, который
реализуется конструкцией \texttt{for} -- она позволяет нам создать счётчик,
задать его начальное значение, описать условие выполнения цикла и операцию
изменения счётчика:

\begin{listing}[ht]
  \begin{minted}{cpp}
    //                   5.
    //        1.         2.           4.
    for (int i = 0; i < 10; i = i + 1) {
      // 3. (тело цикла)
    }
  \end{minted}
  \label{listing:dialogues-with-computer-for}
  \caption{Цикл со счётчиком \texttt{for} с указанием порядка выполнения шагов
    цикла.}
\end{listing}

Как и в случае с циклом \texttt{while}, мы можем представить себе процесс цикла
\texttt{for} в виде череды событий:

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \draw[-{Stealth[gray]}] (0, 0) -- (11, 0);
    \foreach \x in {1, 2, ..., 10} {
      \draw (\x, 0.1) -- (\x, -0.1) node[below] {$\x$};
      \draw[dotted, red] (\x, 0.1) -- (\x, 0.5);
    };
    \draw (1.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{int i = 0}$}};
    \draw (2.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{t < 10}$}};
    \draw (3.50, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Тело цикла}$}};
    \draw (4.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{i++}$}};
    \draw (5.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{i < 10}$}};
    \draw (6.50, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Тело цикла}$}};
    \draw (7.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{i++}$}};
    \draw (8.00, 0.5)  node[above, red] {$\mbox{...}$};
    \draw (11, 0) node[below] {$t$};
  \end{tikzpicture}
  \label{fig:control-flow-for-loop}
  \caption{Визуальное представление цикла \texttt{for}.}
\end{figure}

Выполняется эта конструкция в следующем порядке:
\begin{enumerate}
\item объявляем переменную и присваиваем ей значение 0 (шаг 1);
\item переходим к проверке, где смотрим, выполняется ли условие (шаг 2);
\item после этого, если условие 2 выполняется, мы переходим к телу цикла (шаг 3);
\item после выполнения тела цикла, мы переходим к изменению значения счётчика (шаг 4);
\item после шага 4 мы опять возвращаемся к шагу 2, если условие выполняется, то
  переходим к шагу 3 и т.д.
\end{enumerate}

Как и в случае с циклом \texttt{while} давайте представим процесс изготовления
пирожков в виде цикла.  Допустим, нам нужно изготовить 10 пирожков.
Изготовление одного пирожка описывается определённых алгоритмом действий
(рецептом.)  Для того, чтобы сделать 10 штук, надо повторить данный алгоритм 10
раз.

Цикл начинается с того, что мы заводим переменную-счётчик для подсчёта уже
сделанных пирожков.  Изначально данная переменная равна нулю.  Далее мы
проверяем, истинно ли условие, что пирожков меньше 10.  Ноль меньше 10, так что
мы переходим к изготовлению первого пирожка (выполняем тело цикла.)  После тела
цикла мы переходим к увеличению счётчика пирожков, после чего у нас счётчик
становится равным единице.  После этого мы переходим опять к проверке условия, и
видим, что у нас один пирожок, и один меньше десяти.  После этого идём далее по
циклу.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Цикл с постусловием}
\index{Программирование!Цикл!Цикл с постусловием (do..while)}

Кроме вышеперечисленных видов циклов, есть ещё цикл с постусловием, где
проверка условия выполнения цикла осуществляется после выполнения тела цикла.
Реализуется данный вид циклов конструкцией \texttt{do..while}.

Общий вид цикла \texttt{do..while} таков:

\begin{listing}[ht]
  \begin{minted}{cpp}
    int pin = 2;

    do {
      // тело цикла
    } while (pin < 10);
  \end{minted}
  \label{listing:dialogues-with-computer-do-while}
  \caption{Цикл с постусловием \texttt{do..while}.}
\end{listing}

Исходя из свойства данного вида цикла можно заметить интересный момент: даже
если условие ложно \emph{перед} началом цикла, тело цикла выполнится один раз.
Таким образом можно сказать, что \emph{тело цикла с пост-условием всегда
выполняется хотя бы один раз}, как показано в примере
\ref{listing:dialogues-with-computer-do-while-example}.

\begin{listing}[ht]
  \begin{minted}{cpp}
    int a = 2;

    do {
      digitalWrite(13, HIGH);
      delay(200);
      digitalWrite(13, LOW);
      delay(200);
    } while (a < 1);
  \end{minted}
  \label{listing:dialogues-with-computer-do-while-example}
  \caption{Демонстрация особенности цикла с постусловием \texttt{do..while}.}
\end{listing}

В данном примере, несмотря на то, что изначально переменная \texttt{a} имеет
значение 2, а по условию цикла переменная \texttt{a} должна быть меньше 1,
светодиод на 13-м порту мигнёт один раз.

Данный вид цикла достаточно редко используется, но в некоторых случаях он очень
удобен.

Более реалистичный пример показан на
рис. \ref{listing:dialogues-with-computer-do-while-example-2}: пока кнопка на
порту \texttt{BUTTON\_PIN} не нажата, цикл будет выполняться, мигая светодиодом.
Если даже кнопка была нажата при старте была уже нажата, светодиод мигнёт один
раз.  Но если кнопку нажать, программа выйдет из цикла и пойдёт дальше.

\begin{listing}[ht]
  \begin{minted}{cpp}
    do {
      digitalWrite(13, HIGH);
      delay(200);
      digitalWrite(13, LOW);
      delay(200);
    } while (digitalRead(BUTTON_PIN) == LOW);
  \end{minted}
  \label{listing:dialogues-with-computer-do-while-example-2}
  \caption{Практический пример использования цикла с постусловием
    \texttt{do..while}.}
\end{listing}

Визуально можно представить порядок выполнения цикла из примера
\ref{listing:dialogues-with-computer-do-while-example-2} как на
рис. \ref{fig:control-flow-do-while-loop}.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \draw[-{Stealth[gray]}] (0, 0) -- (11, 0);
    \foreach \x in {1, 2, ..., 10} {
      \draw (\x, 0.1) -- (\x, -0.1) node[below] {$\x$};
      \draw[dotted, red] (\x, 0.1) -- (\x, 0.5);
    };
    \draw (2.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Выполнение тела цикла}$}};
    \draw (3.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Кнопка нажата?} \mapsto \mbox{Нет}$}};
    \draw (4.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Выполнение тела цикла}$}};
    \draw (5.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Кнопка нажата?} \mapsto \mbox{Нет}$}};
    \draw (6.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Выполнение тела цикла}$}};
    \draw (7.25, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Кнопка нажата?} \mapsto \mbox{Да}$}};
    \draw (8.00, 0.5)  node[above, red] {\rotatebox[origin=l]{45}{$\mbox{Завершение цикла}$}};
    \draw (11, 0) node[below] {$t$};
  \end{tikzpicture}
  \label{fig:control-flow-do-while-loop}
  \caption{Визуальное представление цикла \texttt{do..while}.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Зачем столько видов циклов?}

Обратите внимание, что один вид цикла может быть реализован через другой, т.к.
данные управляющие конструкции взаимозаменяемы. Возникает вопрос -- зачем же нам
нужно столько видов циклов? Всё дело в удобстве. В одних случаях удобнее
использовать один вид циклов, в других случаях -- другой.

У программистов есть специальный термин для описания подобных конструкций языка
программирования: \emph{синтаксический сахар}.  Синтаксический сахар -- это
конструкции языка, без которых в принципе можно обойтись при разработке
программ, но с ними всё проще (``слаще''.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Визуализация циклов}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Задачи}
\begin{enumerate}
\item Перепишите ``бегущий огонь'' с использованием цикла.
\item Модифицируйте алгоритм ``бегущего огня'' таким образом, чтобы светодиоды
  начинали загораться с обоих концов гирлянды, и огни ``бежали'' навстречу друг
  другу.
\end{enumerate}

\end{document}
