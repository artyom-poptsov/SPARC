\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Битовые операции}
\index{Программирование!Битовые операции}

Чтобы удобно было оперировать отдельными битами, в языке C существуют так
называемые \emph{битовые операции}.  К ним относятся:

\begin{itemize}
\item Побитовое отрицание ``НЕ'' (``NOT'') -- записывается знаком тильды ``$\sim$''.
\item Побитовое ``И'' (``AND'') -- записывается знаком амперсанда ``\&''.
\item Побитовое ``ИЛИ'' (``OR'') -- записывается знаком вертикальной черты ``|''.
\item Исключающее ``ИЛИ'' (``XOR'') -- записывается знаком ``\textasciicircum''.
\item Побитовые сдвиги влево (``$<<$'') и вправо (``$>>$''.)
\end{itemize}

Операция побитового отрицания является \emph{унарной} -- то есть, работающей
только с одним операндом (одним аргументом.)  Все же остальные перечисленные
операции являются \emph{бинарными} -- то есть, принимающими два операнда
(аргумента.)

Рассмотрим каждую операцию подробнее.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Побитовое ``НЕ''}

\tableBitwiseNOT{ru}

Унарная операция побитового ``НЕ'' (``NOT'') производит логическое отрицание
каждого бита: ноль становится единицей, а единица -- нулём.  Операция
записывается знаком тильды (``$\sim$'') и записывается слева от операнда, к
которому требуется её применить.

Например, если мы применим ``НЕ'' к однобайтовому значению 5
(\mintinline{cpp}{0b00000101} в двоичном коде), то получим следующий результат:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = ~a;
  // Результат:
  //   NOT 0000 0101
  //     = 1111 1010
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Побитовое ``И''}

\tableBitwiseAND{ru}

Побитовое ``И'' (``AND'') является бинарной и производит логическое ``И'' над
каждой парой битов двух значений.  Записывается данная операция знаком
амперсанда (``\&'') и работает с двумя операндами (аргументами), которые
записываются слева и справа от него.

Пример:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = 0b00000100;
  byte c = a & b;
  // Результат:
  //       0000 0101
  //   AND 0000 0100
  //     = 0000 0100
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Побитовое ``ИЛИ''}

\tableBitwiseOR{ru}

Побитовое ``ИЛИ'' (``OR'') производит логическое ``ИЛИ'' над каждой парой бит
двух значений.  Операция записывается знаком вертикальной черты (``|'') и
является бинарной.

Пример:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = 0b00000010;
  byte c = a | b;
  // Результат:
  //       0000 0101
  //    OR 0000 0010
  //     = 0000 0111
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Исключающее ``ИЛИ''}

\tableBitwiseXOR{ru}

Исключающее ``ИЛИ'' (``Exclusive OR'', или сокращённо ``XOR'') является бинарной
операцией и применяется к двум наборам бит одинаковой длины, производя
логическое исключающее ``ИЛИ'' над каждой парой бит в операндах.  Операция
записывается знаком ``\textasciicircum''.

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = 0b00000110;
  byte c = a ^ b;
  // Результат:
  //       0000 0101
  //   XOR 0000 0110
  //     = 0000 0011
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Побитовый сдвиг}

Побитовым сдвигом называется бинарная операция смещения бит в значении слева от
оператора сдвига на указанное справо количество разрядов.  Направление сдвига
определяется видом операции:

\begin{itemize}
\item Левый сдвиг (``left shift'', или сокращённо ``LSH'') обозначается двумя
  знаками ``меньше'', идущими подряд (``$<<$'') и смещает биты влево на
  указанное справа от оператора сдвига от значение.  Справа в число добавляются
  нулевые биты в количестве, равном значению сдвига.  При этом, крайние биты
  слева выталкиваются из числа (стираются) сдвигаемыми битами.
\item Правый сдвиг (``right shift'', сокращённо ``RSH'') обозначается знаками
  ``больше'', идущими подряд (``$>>$'') и смещает биты вправо на указанное
  справа от оператора сдвига значение.  Слева в число добавляются нулевые биты в
  количестве, равном значению сдвига.  При этом, крайние биты справа
  выталкиваются из числа (стираются) сдвигаемыми битами.
\end{itemize}

Пример использования сдвига влево на один бит:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = a << 1;
  // Результат:
  //   LSH 0000 0101
  //    =  0000 1010
\end{minted}

Пример использования сдвига вправо на один бит:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = a >> 1;
  // Результат:
  //   RSH 0000 0101
  //    =  0000 0010
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Практическое применение битовых операций}

\subsubsection{Выставление нужного бита в единицу}

Одной из частых задач является выставление нужного нам бита числа в единицу.
Для этого можно воспользоваться побитовым ``ИЛИ'':

\begin{minted}{cpp}
  byte a = 0b10000000;
  a = a | 0b00010000;
  // Результат:
  //       1000 0000
  //    OR 0001 0000
  //     = 1001 0000
\end{minted}

Чтобы было проще записать ``пятый справа бит'', можно воспользоваться битовым
сдвигом влево на 4 позиции, результат будет тот же -- но запись станет более
краткой:

\begin{minted}{cpp}
  int a = 0b10000000;
  a = a | (1 << 4);
  // Пошаговый разбор вычисления результата:
  //   1. (1 << 4):
  //       0000 0001
  //   LSH 4
  //     = 0001 0000
  //
  //   2. a | (1 << 4):
  //       1000 0000
  //    OR 0001 0000
  //     = 1001 0000
\end{minted}

\subsubsection{Проверка значения бита}

Чтобы узнать, выставлен ли определённый бит в числе в единицу, можно
воспользоваться побитовым ``И'' -- данная операция часто называется ``наложением
битовой маски'':

\begin{minted}{cpp}
  byte a = 0b10010000;

  int mask = 0b00010000;
  // Можно также задать битовую маску через битовый сдвиг,
  // что более удобно и наглядно:
  //   mask = (1 << 4);

  if (a & mask) {
    // Действие, если пятый справа бит выставлен в 1.
  }
\end{minted}

\subsubsection{Выставление значения бита в ноль}

Чтобы ``выключить'' какой-то из битов в числе, мы можем воспользоваться
побитовым ``И'', вместе с инверсией битовой маски:

\begin{minted}{cpp}
  byte a = 0b10010000;
  a = a & ~(1 << 4);
  // Пошаговый разбор вычисления результата:
  //   1. (1 << 4):
  //       0000 0001
  //   LSH 4
  //     = 0001 0000
  //
  //   2. ~(1 << 4):
  //   NOT 0001 0000
  //     = 1110 1111
  //
  //   3. a & ~(1 << 4):
  //       1001 0000
  //   AND 1110 1111
  //     = 1000 0000
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Задачи}

На примере работы с I2C-устройством можно наглядно увидеть работу битовых
операций.

\begin{enumerate}
\item Реализовать эффект ``Бегущий огонь'', используя I2C-адаптер для ЖК-дисплея
  с подключенными свтодиододами, на базе примера
  \ref{listing:communication-pcf8574}.  Для реализации эффекта можно
  использовать битовые операции.
\end{enumerate}
