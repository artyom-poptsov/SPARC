\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Коэффициент заполнения}

Каким образом задается напряжение из диапазона? Очень просто: путём изменения
времени подачи того или иного сигнала. Чем больше времени на порту сигнал HIGH,
тем выше напряжение. При этом, длина периода \texttt{P} остаётся фиксированной
(например, 1000 микросекунд). Таким образом для \gls{ШИМ} важно процентное
отношение одного сигнала к другому, и, увеличивая время подачи одного сигнала,
следует уменьшать время подачи другого (следовательно, если мы подаем сигнал
\texttt{HIGH} 60\% от отведенного времени, нужно заполнить оставшиеся 40\%
сигналом \texttt{LOW}).

Отношение периода следования сигнала к длительности импульса называется
\emph{скважностью}. В англоязычной литературе величина, обратная скважности,
называется \emph{коэффициентом заполнения} (англ. \emph{duty cycle}).

Мы будем использовать термин ``коэффициент заполнения''.

\example {
  Мы хотим получить 2.5 вольта на цифровом порту 2, имея в
  распоряжении только два значения -- 0 В и 5 В. Для этого нам потребуется
  реализовать ШИМ с коэффициентом заполнения 50\%. При длине волны в 1000
  микросекунд мы должны половину времени (500 микросекунд) заполнить
  положительным сигналом (сигнал \texttt{HIGH}) и подать его на выбранный порт, затем
  остальную часть заполним отрицательным сигналом (сигналом \texttt{LOW}).
  Если всё сделано правильно, то на 2 цифровом порту получим 2.5 вольта.
}

Для генерации нужного сигнала нам потребуется создать инструмент
(\emph{функцию}), который впоследствии мы будем использовать. Мы уже говорили о
важности написания и использования собственных функций в программе -- функции
позволяют нам создавать модульные программы, упрощают поддержку существующего
программного кода и написание нового кода.

Подумаем над тем, какой должна быть наша функция, реализующая ШИМ. Ниже приведён
знакомый нам график, отображающий сигнал на цифровом порту -- мы будем
использовать этот график, как основу для написания функции.

\begin{figure}[ht]
  \begin{tikzpicture}
    \draw[thick, ->] (0, 0) -- (12, 0) node[anchor=north west] {t};
    \draw[thick, ->] (0, 0) -- (0,  7) node[anchor=south west] {V};
    \draw[lightgray] (0, 0) grid (10, 6);
    \foreach \x in {0, 2, ..., 8} {
      \draw[ultra thick, teal] (\x, 6) -- (\x + 1, 6);
      \draw[ultra thick, teal] (\x + 1, 6) -- (\x + 1, 1);
      \draw[ultra thick, teal] (\x + 1, 1) -- (\x + 2, 1);
      \draw[ultra thick, teal] (\x + 2, 1) -- (\x + 2, 6);
    }
    \draw[ultra thick, teal, ->] (10, 6) -- (12, 6);
    \draw[orange] (10, 6) node[anchor=north west] {port=?};
    \draw[orange] (0, 6) node[anchor=north west] {d1};
    \draw[orange] (1, 6) node[anchor=north west] {d2};
    \draw[thick, orange] (0,  0) -- (0,   -2);
    \draw[thick, orange] (2,  1) -- (2,   -1);
    \draw[thick, orange] (10, 1) -- (10,  -2);
    \draw[thick, orange, <->] (0, -0.5) -- (2,  -0.5)  node[midway, below] {T=1000мкс};
    \draw[thick, orange, <->] (0, -1.5) -- (10,  -1.5) node[midway, below] {t=?};
  \end{tikzpicture}
  \caption{Графическое отображение процесса генерации ШИМ-сигнала.}
  \label{fig:pwm-graph}
\end{figure}

Имея перед глазами этот график, нетрудно набросать словесное описание функции
(назовём функцию \texttt{pwm}, как сокращение от англ. \emph{pulse width
  modulation}.)

Начнём с того, что, скорее всего, подобная функция должна принимать три
параметра:
\begin{enumerate}
\item Номер порта (обозначаемый целым числом), на котором следует сгенерировать
  ШИМ сигнал; назовём этот параметр \texttt{port}.
\item Коэффициент заполнения, заданный дробным числом -- к примеру, 50\% будет
  задано, как 0.5; назовём этот параметр \texttt{dc} (от слов ``duty cycle'' --
  коэффициент заполнения.)
\item Длина ШИМ-сигнала в микросекундах; назовём этот параметр
  \texttt{t}.
\end{enumerate}

Запишем тоже самое на языке С++:

\begin{minted}{cpp}
void pwm(int port, float dc, long t) {
  // тело функции
}
\end{minted}

О том, что такое \texttt{void}, будет сказано позже, пока что стоит принять как
факт, что это начало объявления функции. Наверняка появились вопросы по новым
типам переменных -- \texttt{float} и \texttt{long}. Почему нельзя использовать
привычный \texttt{int}? Дело в том, что переменная типа \texttt{int} не может
хранить дробные числа, а также имеет диапазон значений от -32 768 до 32 767. Для
хранения дробных чисел используется \texttt{float}, а для чисел, не входящих в
диапазон \texttt{int}, стоит использовать \texttt{long}, имеющий диапазон от -2
147 483 648 до 2 147 483 647. Теперь подумаем над телом функции.

Обозначим длительность одного периода константой \texttt{T}, равной 1000 мкс.

\begin{minted}{cpp}
  const int T = 1000; // мкс
\end{minted}

Обратите внимание, что мы используем ключевое слово const для того, чтобы
пометить \texttt{T}, как константу -- мы всё равно не собираемся менять это
значение.  Кроме того, мы указали в комментарии, что значение задано в
микросекундах (мкс), что упрощает чтение кода.  В C++, да и в других языках,
константа -- это та же переменная, но её значение нельзя менять после её
объявления.

Следующим этапом будет вычисление в теле функции значений переменных \texttt{d1}
и \texttt{d2} на основе значения \texttt{dc}, заданного при вызове функции.

Значения задержек, заданных переменными \texttt{d1} и \texttt{d2}, необходимо
вычислить на основе коэффициента заполнения, задаваемого параметром функции
\texttt{dc} (который задаётся дробным значением -- к примеру, 0.5.)

Формулы вычисления \texttt{d1} и \texttt{d2} представлены ниже.

\begin{equation}
  \mbox{d1} = \mbox{T} * \mbox{dc}
  \label{Формула вычисления времени подачи сигнала ``HIGH''}
\end{equation}

\begin{equation}
  \mbox{d2} = \mbox{T} - \mbox{d1}
  \label{Формула вычисления времени подачи сигнала ``LOW''}
\end{equation}

В коде это будет выглядеть следующим образом.

\begin{minted}{cpp}
int d1 = T * dc;
int d2 = T - d1;
\end{minted}

Видно, что как только мы вычислили \texttt{d1}, вычислить \texttt{d2} не
составляет труда. Осталось только посчитать, сколько раз нужно повторить волну
длиной \texttt{T}, чтобы сгенерировать сигнал длиной \texttt{t}:

\begin{minted}{cpp}
int count = t / T;
\end{minted}

Теперь у нас есть всё, что нужно для генерации нужного нам сигнала. Поскольку,
исходя из описания выше, нам нужно будет повторять волну \texttt{count} раз, то
для этого удобно использовать цикл \texttt{for} (цикл со счётчиком):

\begin{listing}[H]
  \begin{minted}{cpp}
    for (int c = 0; c < count; c++) {
      digitalWrite(port, HIGH);
      delayMicroseconds(d1);
      digitalWrite(port, LOW);
      delayMicroseconds(d2);
    }
  \end{minted}
  \label{listing:pwm-cycle}
  \caption{Цикл генерации ШИМ-сигнала.}
\end{listing}

Полностью функция \texttt{pwm} будет выглядеть вот так:

\begin{listing}[H]
  \begin{minted}{cpp}
    void pwm(int port, float dc, long t) {
      const int T = 1000; // мкс
      int d1 = T * dc;
      int d2 = T - d1;
      int count = t / T;
      for (int c = 0; c < count; c++) {
        digitalWrite(port, HIGH);
        delayMicroseconds(d1);
        digitalWrite(port, LOW);
        delayMicroseconds(d2);
      }
    }
  \end{minted}
  \label{listing:pwm-procedure}
  \caption{Процедура генерации ШИМ-сигнала.}
\end{listing}

Готово! Осталось только задействовать функцию \texttt{pwm} в нашей программе.

\end{document}
