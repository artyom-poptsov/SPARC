\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Внутренние аппаратные прерывания}
\index{Аппаратное обеспечение!Прерывания!Внутренние}

Как говорилось ранее, источником внутренних прерываний являются периферийными
цепями внутри микроконтроллера.  Мы будем рассматривать подобные прерывания на
примере работы с \emph{таймерами}.

Таймер можно представить, как некоторый ``будильник'', который можно завести
внутри процессора и по его ``звонку'' вызывать некую процедуру -- обработчик
прерывания.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Принцип работы таймера}
\index{Аппаратное обеспечение!Прерывания!Внутренние!Таймер}

Аппаратный таймер по принципу работы представляет собой счётчик.  Преимуществом
таймера является то, что изменение счётчика происходит по аппаратному тактовому
импульсу, не зависящиму от выполнения программы на микроконтроллере.  Это даёт
определённость (или, как говорят, \emph{детерминизм}) в его работе, что в свою
очередь позволяет с большой точностью отмерять промежутки времени, при условии
учёта частоты процессора.

Микроконтроллеры семейства AVR, на которых основана платформа Arduino, обычно
имеют два 8-битных таймера и один 16-битный.  Восьмибитный таймер может считать
от 0 до 255 ($2^{8}-1$), тогда как 16-битный таймер имеет диапазон от 0 до 65535
($2^{16}-1$.)  Таймер с разрешением в 16 бит является более гибким в
использовании, чем 8-битный, однако не всегда возникает необходимость в таком
большом разрешении.  К тому же, использование 8-битного таймера может дать более
эффективный и компактный код.\cite{avr:timers}

Микроконтроллер может быть настроен на отслеживание событий таймера (которых
существует несколько типов), чтобы по их приходу вызывать обработчик события.

Можно выделить три основных типа событий:
\begin{itemize}
\item Переполнение таймера (англ. ``Timer Overflow'')
\item Совпадение по сравнению (англ. ``Compare Match'')
\item Захват входного сигнала (англ. ``Input Capture'')
\end{itemize}

На данный момент нам наиболее важны первые два варианта, которые мы рассмотрим
сейчас подробнее.

\subsubsection{Прерывание по переполнению таймера}

\figureInterruptTimerOverflow{ru}

\emph{Переполнение таймера} возникает, когда счётчик таймера доходит до своего
максимального значения.  После этого происходит вызов обработчика прерывания
(если он назначен), потом -- сброс счётчика в ноль и отсчёт начинается заново.
Максимальное значение для таймера определяется его \emph{разрешением}.
Например, для восмибитного таймера максимальное значение будет 255:

\begin{equation}
  maximum\_value = 2^{timer\_resolution} - 1
\end{equation}

На рис. \ref{fig:timer-overflow-interrupt} схематически показана работа таймера
и красными точками отмечены моменты переполнения счётчика -- то есть, моменты
срабатывания прерывания по переполнению.

\subsubsection{Прерывание по сравнению таймера с заданным значением}

\newglossaryentry{OCR}{
  name=OCR,
  description={Output Compare Register, выходной регистр сравнения}}

\emph{Совпадение по сравнению} возникает, когда значение счётчика таймера
достигает до заранее заданной отметки в допустимом диапазоне таймера (про
который мы говориле выше.)  Например, если мы выставим отметку на уровне 127, то
восмибитный таймер сработает на середине пути от нуля до переполнения.

\figureInterruptTimerCompare{ru}

На рис. \ref{fig:timer-overflow-compare-match} можно видеть, что значение
таймера сравнивается с двумя значениями: ``OCR A'' и ``OCR B''. ``OCR''
расшифровывается, как ``Output Compare Register''.  По сути это некая ячейка
памяти (так называемый \emph{регистр процессора}), хранящая значение, с которым
сравнивается значение таймера (из другой ячейки памяти.)  Когда значения двух
ячеек совпадают, то вызывается назначенный на данное событие обработчик
прерывания (\gls{ISR}.)

Подробнее понятие \emph{регистра процессора} мы рассмотрим в последующих
разделах.

Для настройки доступно ограниченное количество ячеек ``OCR''.  Для кажого
таймера существуют две ячейки для сравнения, именуемые ``OCRxA'' и ``OCRxB'',
где ``x'' -- это номер таймера.  Скажем, для таймера номер 1 доступны ``OCR1A'' и
``OCR1B''.

Для каждого настроенного ``OCR'' назначается собственный обработчик.  Это
позволяет на одном таймере делать до двух прерываний.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Архитектура процессора}
\index{Аппаратное обеспечение!Архитектура процессора}

Итак, мы теперь знаем, что есть \gls{OCR}-ячейки, с которыми сравнивается
значение таймера.  Но что же представляют собой данные ячейки?

\index{Архитектура процессора!Память!Регистры}
Как было сказано в предыдущем разделе, ``OCR'' расшифровывается, как ``Output
Compare Register'', или ``Выходной Регистр Сравнения''.  \emph{Регистрами}
называются ячейки самой быстрой памяти, которая находится внутри процессора.
Количество и объём данных ячеек сильно ограничены и зависит от устройства
(архитектуры) процессора.

\subsubsection{Память}
\index{Архитектура процессора!Память!Виды памяти}

Память является одним из основных ресурсов компьютера.  Различают два основных
типа памяти:
\begin{itemize}
\item \emph{Энерго-зависимая} память хранит данные только тогда, когда компьютер
  работает.  Как только питание на память перестаёт поступать, её ячейки
  очищаются.  Таким образом можно сказать, что энерго-зависимая память является
  \emph{вр\'еменной}.
\item \emph{Энерго-независимая} память сохраняет записанные в неё данные даже
  после отключения питания, что делает её \emph{перманентной} (или
  \emph{постоянной}) памятью.
\end{itemize}

Информация в памяти хранится в виде бит, которые как правило сгруппированы в
байты (в большинстве современных компьютеров 1 байт содержит 8 бит.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Архитектура памяти}
\index{Аппаратное обеспечение!Память!Архитектура памяти}

Существуют две основных архитектуры памяти компьютера:
\begin{itemize}
\item \emph{Архитектура фон Неймана} -- названа в честь физика и информатика
  Джона фон Неймана (англ. \textit{John von Neumann}.)  В данной архитектуре
  программные инструкции и данные сохраняются в единой памяти.
\item \emph{Гарвардская архитектура} -- названа в честь компьютера \emph{Mark I},
  созданного в Гарварде.  Главное отличие данной архитектуры заключается в том,
  что она использует два независимых модуля памяти: один предназначен для
  хранения программных инструкций, а другой -- для хранения данных.  В данной
  архитектуре центральный процессор (ЦП) получает доступ к каждому виду памяти
  через различные шины связи.
\end{itemize}

Существуют также гибридные архитектуры, которые берут ``лучшее из двух миров'',
для повышения производительности.

На микроконтроллерах обычно используется Гарвардская архитектура, так как это
позволяет более эффективно выполнять задачи в условиях жёстких ограничений по
ресурсам.

Многие виды Arduino, которые могут вам встретиться, используют именно
Гарвардскую архитектуру -- а именно те, которые основаны микроконтроллерах
семейства AVR.  Например, сюда можно отнести микроконтроллер ATmega2560, лежащий
в основе Arduino Mega 2560 Rev3.\cite{arduino:memory-guide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Карта памяти микроконтроллеров семейства AVR}
\index{Аппаратное обеспечение!Память!Карта памяти}

\newglossaryentry{EEPROM}{name=EEPROM, description={Electrically erasable
    programmable read-only memory}}

\newglossaryentry{RAM}{name=RAM, description={Random access memory}}

\newglossaryentry{ОЗУ}{name=ОЗУ, description={Оперативное запоминающее
    устройство -- см. также \gls{RAM}}}

\figureAVRMemory{ru}

Как мы говорили ранее, выделение памяти различается в разных архитектурах.  На
микроконтроллерах семейства AVR размещение памяти выглядит так, как показано на
рис. \ref{fig:avr-memory} (за основу схемы взята информация из
\cite{arduino:memory-guide} и \cite{avr:atmega328p-datasheet}.)

В левой части рисунка показана энергонезависимая память для хранения программ
(\emph{program memory}.)  В этой памяти располагается записанная в
микроконтроллер программа, также небольшая часть памяти отведена под специальную
программу, называемую \emph{загрузчиком} -- она как раз позволяет программировать
Arduino через обычное USB-подключение.

В центральной части рисунка можно видеть энергозависимую оперативную память
(\gls{ОЗУ}, или по-английски \gls{RAM}), называемую также \emph{памятью данных}
(англ. ``data memory''.)

\index{Архитектура процессора!Память!EEPROM}
В правой части рисунка находится ещё один вид энергонезависимой памяти,
называемый \gls{EEPROM}.  В отличии от памяти для программ, которую работающая
программа не может перезаписать, память EEPROM может быть перезаписана
динамически.  Этот вид памяти обычно используется для хранения данных, которые
должны сохранятся между перезапуском системы -- например, настроек.

Адреса \gls{RAM} с 0 (\mintinline{cpp}{0x0000}) по 31 (\mintinline{cpp}{0x001F})
на самом деле не являются частью физической памяти, а вместо этого представляют
собой отображение 32-х регистров процессора общего назначения (``general purpose
registers''.)  Далее с адреса 32 (\mintinline{cpp}{0x0020}) по 95
(\mintinline{cpp}{0x005F}) следуют 64 регистра ввода-вывода, которые также
являются отображением специализированной памяти процессора.

\end{document}
