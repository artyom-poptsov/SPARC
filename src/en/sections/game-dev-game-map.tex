\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing a game map}
\label{section:game-map}
\index{Game development!Game map}
\index{Programming!Array!Two-dimensional array}

Usually some action takes place around the player in a game -- non-playable
characters (NPC) jealously patrol the map territory; some objects, that player
can interact with, appear and disappear; and finally everywhere lie various
\emph{static} objects that can block the path for the player or can be just a
element of the decoration.

A simple way to place an object on the map is to specify its coordinates on the
map and draw the object there -- the same way as we do it with the game
character.  But if we would create two separate variables for each object (for
storing its coordinates on X and Y axis), the number of the variables would grow
very fast.  We can imagine that a map of 20x4 in size can potentially hold up to
80 objects and it gives us 160 variables for addressing each of them!  To solve
this problem we have to resort to arrays that are already familiar to us, with
just one caveat -- we have to use \emph{two-dimensional arrays}.

A schematic representation of a two-dimensional array is shown in
fig. \ref{fig:2d-array-example}.

\figureArray{en}

We can also imagine a two-dimensional array of 4x20 as an one-dimensional array
consisting of 4 elements, where each of which holds a reference to another
one-dimensional array of 20 cells in length, as is shown in
fig. \ref{fig:2d-array-example-with-references}.

\figureArrayOfPointers{en}

For our game implementation tasks we need to specify an array that stores the
\mintinline{cpp}{char} type.  The size of our array -- or the size of our game
map -- we will specify with named constants, somewhere in the top area of the
code, before the \mintinline{cpp}{setup} procedure.

\begin{listing}[H]
  \begin{minted}{cpp}
    const int MAP_W = 20; // Map width.
    const int MAP_H = 4;  // Map height.
  \end{minted}
  \caption{Specifying the size of the game map.}
  \label{listing:game-dev-map-size}
\end{listing}

Then we will create a two-dimensional array that will become our game map.

\begin{listing}[H]
  \begin{minted}{cpp}
    char game_map[MAP_H][MAP_W];
  \end{minted}
  \caption{Creating a game map as a two-dimensional array of symbols.}
  \label{listing:game-dev-map-array}
\end{listing}

It should be noted that when we declare the array we use two pairs of square
brackets.  In the first pair the height of the array is specified (the number of
rows), and in the second pair the width of the array is specified (the number of
columns.)

Then we have to declare a procedure that displays the game map on the screen --
let's call the procedure \mintinline{cpp}{map_show}.

\begin{listing}[ht]
  \begin{minted}{cpp}
    void map_show() {
      for (int y = 0; y < MAP_H; y++) {
        for (int x = 0; x < MAP_W; x++) {
          lcd.setCursor(x, y);
          lcd.print( game_map[y][x] );
        }
      }
    }
  \end{minted}
  \caption{A procedure that shows (renders) the game map on an LCD.}
  \label{listing:game-dev-map-show}
\end{listing}

As can be seen from the listing \ref{listing:game-dev-map-show} the procedure
body consists of two loops, one being inlined into other.  The first loop
iterates over the \mintinline{cpp}{y} axis (the rows of the array.)  The second
loop iterates over \mintinline{cpp}{x} axis (the columns of the array.)  As the
second loop is inlined into the first loop, each single step over
\mintinline{cpp}{y} takes full iteration over \mintinline{cpp}{x} values from 0
to \mintinline{cpp}{MAP_W}.

In the inlined loop we call \mintinline{cpp}{setCursor} procedure to set the
position of the cursor on the display.  Then a symbol from the map is printed
into this position using \mintinline{cpp}{print} procedure.

As the \mintinline{cpp}{game_map} has the \mintinline{cpp}{char} type, the
symbols stored in it are readily printed to the display in the right format --
that is, as graphical symbols instead of symbol codes from the character table.

The \mintinline{cpp}{map_show} must be called in \mintinline{cpp}{loop} to print
the game map on the display.

\begin{listing}[H]
  \begin{minted}{cpp}
    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        // ...
      }
      if (digitalRead(BUTTON_L) == LOW) {
        // ...
      }

      // Calling to the procedure that
      // prints the game map on the display.
      map_show();

      // Drawing the game character over
      // the map.
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);

      delay(100);
    }
  \end{minted}
  \caption{Calling to the game map drawing procedure in \texttt{loop}.}
  \label{listing:game-dev-map-show-call}
\end{listing}

It should be noted that the map drawing is done before the drawing of the game
character.  If we would change this order then the player would not be seen on
the screen as it would be overwritten by the game map.

After uploading this program we may notice that the display is filled with
random characters.  It happens as we didn't initialize the
\mintinline{cpp}{game_map} array with values, so it is filled with
\emph{garbage} -- that is, with some unexpected values.

To fix that situation we need to create a procedure for map generation, that
fills the map with something sensible.  To begin with, we will fill the map with
spaces, that symbolize the empty space on the map.

Let's create a special char constant for the empty space on the map in the
global scope, before \mintinline{cpp}{setup} procedure.

\begin{minted}{cpp}
  const char SPACE = ' ';    // Empty space.
\end{minted}

Now we can use this \mintinline{cpp}{SPACE} constant for specifying the empty
space.

Let's continue with the description of game map generation procedure.

\begin{listing}[H]
  \begin{minted}{cpp}
    void map_generate() {
      for (int y = 0; y < MAP_H; y++) {
        for (int x = 0; x < MAP_W; x++) {
          game_map[y][x] = SPACE;
        }
      }
    }
  \end{minted}
  \caption{A procedure for the game map generation.}
  \label{listing:game-dev-map-generate}
\end{listing}

As we can see from the listing \ref{listing:game-dev-map-generate}, the
\mintinline{cpp}{map_generate} procedure is not very different from the
\mintinline{cpp}{map_show} procedure.

The \mintinline{cpp}{map_generate} procedure should be called once in
\mintinline{cpp}{setup} procedure.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      lcd.init();
      lcd.backlight();

      // Control buttons configuration.
      pinMode(BUTTON_R, INPUT_PULLUP);
      pinMode(BUTTON_L, INPUT_PULLUP);

      // Calling to the map generation
      // procedure.
      map_generate();
    }
  \end{minted}
  \caption{Calling to the map generation procedure in the
    \mintinline{cpp}{setup} procedure.}
  \label{listing:game-dev-map-generate-call}
\end{listing}

After uploading the new version of the program to the Arduino, we should see a
screen where only the player is displayed, as the game map is ``empy'' (filled
with spaces.)

Now we've got the ability to place objects on the game map. We start with a new
game objects -- let it be a ``wall'', that is, an impassable part of a map. We
will use ``\#'' as the wall symbol.

\begin{listing}[H]
  \begin{minted}{cpp}
    const char SPACE = ' ';    // Empty space.
    const char WALL  = '#';    // A wall.
  \end{minted}
  \caption{Creating a wall.}
  \label{listing:game-dev-map-objects}
\end{listing}

After that we can place this object to map, by modifying the
\mintinline{cpp}{map_generate} procedure.  Let's add several walls.

\begin{listing}[H]
  \begin{minted}{cpp}
    void map_generate() {
      for (int y = 0; y < MAP_H; y++) {
        for (int x = 0; x < MAP_W; x++) {
          game_map[y][x] = SPACE;
        }
      }

      // Here we manually add objects to
      // the map.
      game_map[0][10] = WALL;
      game_map[1][10] = WALL;
      game_map[2][10] = WALL;
    }
  \end{minted}
  \caption{Placing objects on the game map.}
  \label{listing:game-dev-map-objects-set}
\end{listing}

After uploading the new version of the program to the Arduino we should see that
the objects appeared on the screen.  The same way we can place other objects
here.  But here's a new problem -- how to interact with them?  In the current
game implementation the player can go through the walls as if they a ghost.  The
solution of this problem is described in the next section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Exercises}
\begin{enumerate}
\item Create new game objects as character constants, as we did it for
  \mintinline{cpp}{SPACE} and \mintinline{cpp}{WALL} -- for example, we can add a
  door to the next game level, or some other type of walls.
\item Add additional objects to the map, to create the desired game world.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Interaction of the player with game objects}
\index{Game development!Handling collisions}

Probably we had an opportunity to work with graphical editors such as GNU Image
Manipulation Program (GIMP) -- such advanced graphical editors allow us to create
multi-layered images.  Each layer can have transparent areas, through which we
can see the underlying layer.  Thus we can create complex compositions.
Nevertheless when we export our project into a raster graphical format (PNG, for
example) all those layers are combined into one layer, starting from bottom to
top -- that is, each layer is being applied upon the previous layer, with the
transparency taken into account.

We can imagine our game world as the similar set of ``layers''.  Currently we
have two layers -- the bottom one (let's call it layer number 0), that holds all
the game objects of our world (and that is exactly what
\mintinline{cpp}{game_map} array is for.)  The upper layer (let's call it the
layer number 1) contains the player.

To allow the player from the layer number 1 to interact with game objects on the
layer number 0, we have to juxtapose the player position with the contents of
the zeroth layer.

\begin{listing}[H]
  \begin{minted}{cpp}
    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        if (player_x < 15) {
          // Check what is on the map to the right
          // of the player.
          if (game_map[player_y][player_x + 1] != WALL) {
            // If the right cell contains something other
            // than a wall, we allow the player to move
            // one cell to the right.
            player_x++;
          }
        }
      }

      // ...
    }
  \end{minted}
  \caption{Handling the player collisions with walls.}
  \label{listing:game-dev-map-collisions-00}
\end{listing}

\end{document}
