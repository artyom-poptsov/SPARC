\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing a game map}
\label{section:game-map}
\index{Game development!Game map}
\index{Programming!Array!Two-dimensional array}

Usually some action takes place around the player in a game -- non-playable
characters (NPC) jealously patrol the map territory; some objects, that player
can interact with, appear and disappear; and finally everywhere lie various
\emph{static} objects that can block the path for the player or can be just a
element of the decoration.

A simple way to place an object on the map is to specify its coordinates on the
map and draw the object there -- the same way as we do it with the game
character.  But if we would create two separate variables for each object (for
storing its coordinates on X and Y axis), the number of the variables would grow
very fast.  We can imagine that a map of 20x4 in size can potentially hold up to
80 objects and it gives us 160 variables for addressing each of them!  To solve
this problem we have to resort to already familiar for us arrays, with just one
caveat -- we have to use \emph{two-dimensional arrays}.

A schematic representation of a two-dimensional array is shown on the
fig. \ref{fig:2d-array-example}.

\figureArray{en}

We can also imagine a two-dimensional array of 4x20 as an one-dimensional array
consisting of 4 elements, where each of which holds a reference to another
one-dimensional array of 20 cells in length, as is shown on the
fig. \ref{fig:2d-array-example-with-references}.

\figureArrayOfPointers{en}

For our game implementation tasks we need to specify an array that stores the
\mintinline{cpp}{char} type.  The size of our array -- or the size of our game
map -- we will specify with named constants, somewhere in the top area of the
code, before the \mintinline{cpp}{setup} procedure.

\begin{listing}[H]
  \begin{minted}{cpp}
    const int MAP_W = 20; // Map width.
    const int MAP_H = 4;  // Map height.
  \end{minted}
  \caption{Specifying the size of the game map.}
  \label{listing:game-dev-map-size}
\end{listing}

Then we will create a two-dimensional array that will become our game map.

\begin{listing}[H]
  \begin{minted}{cpp}
    char game_map[MAP_H][MAP_W];
  \end{minted}
  \caption{Creating a game map as a two-dimensional array of symbols.}
  \label{listing:game-dev-map-array}
\end{listing}

It should be noted that when we declare the array we use two pairs of square
brackets.  In the first pair the height of the array is specified (the number of
rows), and in the second pair the width of the array is specified (the number of
columns.)

Then we have to declare a procedure that displays the game map on the screen --
let's call the procedure \mintinline{cpp}{map_show}.

\begin{listing}[ht]
  \begin{minted}{cpp}
    void map_show() {
      for (int y = 0; y < MAP_H; y++) {
        for (int x = 0; x < MAP_W; x++) {
          lcd.setCursor(x, y);
          lcd.print( game_map[y][x] );
        }
      }
    }
  \end{minted}
  \caption{A procedure that shows (renders) the game map on an LCD.}
  \label{listing:game-dev-map-show}
\end{listing}

As can be seen from the listing \ref{listing:game-dev-map-show} the procedure
body consists of two loops, one being inlined into other.  The first loop
iterates over the \mintinline{cpp}{y} axis (the rows of the array.)  The second
loop iterates over \mintinline{cpp}{x} axis (the columns of the array.)  As the
second loop is inlined into the first loop, each single step over
\mintinline{cpp}{y} takes full iteration over \mintinline{cpp}{x} values from 0
to \mintinline{cpp}{MAP_W}.

In the inlined loop we call \mintinline{cpp}{setCursor} procedure to set the
position of the cursor on the display.  Then a symbol from the map is printed
into this position using \mintinline{cpp}{print} procedure.

As the \mintinline{cpp}{game_map} has the \mintinline{cpp}{char} type, the
symbols stored in it are readily printed to the display in the right format --
that is, as graphical symbols instead of symbol codes from the character table.

The \mintinline{cpp}{map_show} must be called in \mintinline{cpp}{loop} to print
the game map on the display.

\begin{listing}[H]
  \begin{minted}{cpp}
    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        // ...
      }
      if (digitalRead(BUTTON_L) == LOW) {
        // ...
      }

      // Calling to the procedure that
      // prints the game map on the display.
      map_show();

      // Drawing the game character over
      // the map.
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);

      delay(100);
    }
  \end{minted}
  \caption{Calling to the game map drawing procedure in \texttt{loop}.}
  \label{listing:game-dev-map-show-call}
\end{listing}

It should be noted that the map drawing is done before the drawing of the game
character.  If we would change this order then the player would not be seen on
the screen as it would be overwritten by the game map.

After uploading this program we may notice that the display is filled with
random characters.  It happens as we didn't initialize the
\mintinline{cpp}{game_map} array with values, so it is filled with
\emph{garbage} -- that is, with some unexpected values.

To fix that situation we need to create a procedure for map generation, that
fills the map with something sensible.  To begin with, we will fill the map with
spaces, that symbolize the empty space on the map.

Let's create a special char constant for the empty space on the map in the
global scope, before \mintinline{cpp}{setup} procedure.

\begin{minted}{cpp}
  const char SPACE = ' ';    // Empty space.
\end{minted}

Now we can use this \mintinline{cpp}{SPACE} constant for specifying the empty
space.

\end{document}
