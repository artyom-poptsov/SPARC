\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing the controls}
\index{Game development!Controls}
\label{section:game-dev-controls}

To control the game character, we must have some device to input information
into a computer (or in our case, a micro-controller.)  We will implement such
device using several buttons connected through a breadboard to Arduino.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Button connection}
\index{Game development!Button connection}

Let's try to connect a button to an Arduino board.  A button is but a contractor
between two contacts.  The simplest button replacement is two disconnected wires
(an open electric circuit) that we can connect together (close the circuit), or
open the circuit again.  Of course this method of control is inconvenient (and
even dangerous, when high voltages and currents are used in an electric
circuit), and that's why buttons usually implemented as some enclosed devices
that provide a way to connect two wires without the need to grab and connect the
wire ends with bare hands.

Buttons differ in terms of working principles.  The simplest type of buttons are
\emph{push-buttons}.

They are called \emph{push-buttons} because they don't ``remember'' their state,
and after they pushed they return the default (usually ``open'') state.

Another common type of buttons is those that ``remember'' their state; those
buttons also usually called ``switches''.

On the fig. \ref{fig:game-dev-button-00} we can find one of the possible ways of
button connection.  On the first glance we can think that this variant is good
enough -- when the button is pressed the circuit is closed and electric current
flows from \texttt{5V} to the digital port number 2.  And indeed in this case we
can read the value 1 (\texttt{HIGH}) from the digital port.

\figureButtonCircuit{en}

An example of a simplest program that reads the button value is shown below.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT);
    }

    void loop() {
      // Read a value from the button and store
      // it in the new variable "value".
      int value = digitalRead(2);

      // Then we can use this variable in the code
      // to determine the current button state:
      // if the variable contains the value 1 then
      // the button is pressed, and if it contains 0
      // then the button is not pressed.
    }
  \end{minted}
  \caption{Handling of button presses.}
  \label{listing:button-00}
\end{listing}

To clearly see how the value on the button port changes when button is pressed,
we can log the value to the computer.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT);
      Serial.begin(9600);
    }

    void loop() {
      // Read a value from the button and store
      // it in the new variable "value".
      int value = digitalRead(2);

      // Then we can use this variable in the code
      // to determine the current button state:
      // if the variable contains the value 1 then
      // the button is pressed, and if it contains 0
      // then the button is not pressed.

      // Print the value to the serial port.
      Serial.println(value);
    }
  \end{minted}
  \caption{Logging button states to a computer.}
  \label{listing:button-01}
\end{listing}

Unfortunately when we look close enough we will see that even if the button is
not pressed, sometimes there are stray ``1'' values in the log.  How is it so?
The explanation is simple: as we seen in the ``White noise'' chapter, we are
surrounded by electromagnetic background that captured by circuits and this in
turn leads to the situation where sometimes the value on digital ports crosses
the bar where Arduino considers it as the value ``1''.

We can solve this problem at least in two ways.  The first one is that we can
use a special \emph{pull-down resistor} that will pull the value on a digital
port where the button is connected to the ground (GND.)

\figureButtonPulldownResistorCircuit{en}

The digital port must be configured in \mintinline{cpp}{INPUT_PULLUP} mode.  The
rest of the example code stays the same.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT_PULLUP);
      Serial.begin(9600);
    }

    void loop() {
      // Read a value from the button and store
      // it in the new variable "value".
      int value = digitalRead(2);

      // Then we can use this variable in the code
      // to determine the current button state:
      // if the variable contains the value 1 then
      // the button is pressed, and if it contains 0
      // then the button is not pressed.

      // Print the value to the serial port.
      Serial.println(value);
    }
  \end{minted}
  \caption{An example of \mintinline{cpp}{INPUT_PULLUP} mode usage.}
  \label{listing:game-dev-input-pullup-example}
\end{listing}

In this mode the button behavior is ``inverted'' -- when it is pressed, then the
digital port value will be ``0'' (\mintinline{cpp}{LOW}) and when it is not, the
value will be ``1'' (\mintinline{cpp}{HIGH}.)

\end{document}
