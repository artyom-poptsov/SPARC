\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing the controls}
\index{Game development!Controls}
\label{section:game-dev-controls}

To control the game character, we must have some device to input information
into a computer (or in our case, a micro-controller.)  We will implement such
device using several buttons connected through a breadboard to Arduino.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Button connection}
\index{Game development!Button connection}

Let's try to connect a button to an Arduino board.  A button is but a contractor
between two contacts.  The simplest button replacement is two disconnected wires
(an open electric circuit) that we can connect together (close the circuit), or
open the circuit again.  Of course this method of control is inconvenient (and
even dangerous, when high voltages and currents are used in an electric
circuit), and that's why buttons usually implemented as some enclosed devices
that provide a way to connect two wires without the need to grab and connect the
wire ends with bare hands.

Buttons differ in terms of working principles.  The simplest type of buttons are
\emph{push-buttons}.

They are called \emph{push-buttons} because they don't ``remember'' their state,
and after they pushed they return the default (usually ``open'') state.

Another common type of buttons is those that ``remember'' their state; those
buttons also usually called ``switches''.

On the fig. \ref{fig:game-dev-button-00} we can find one of the possible ways of
button connection.  On the first glance we can think that this variant is good
enough -- when the button is pressed the circuit is closed and electric current
flows from \texttt{5V} to the digital port number 2.  And indeed in this case we
can read the value 1 (\texttt{HIGH}) from the digital port.

\figureButtonCircuit{en}

An example of a simplest program that reads the button value is shown below.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT);
    }

    void loop() {
      // Read a value from the button and store
      // it in the new variable "value".
      int value = digitalRead(2);

      // Then we can use this variable in the code
      // to determine the current button state:
      // if the variable contains the value 1 then
      // the button is pressed, and if it contains 0
      // then the button is not pressed.
    }
  \end{minted}
  \caption{Handling of button presses.}
  \label{listing:button-00}
\end{listing}

To clearly see how the value on the button port changes when button is pressed,
we can log the value to the computer.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT);
      Serial.begin(9600);
    }

    void loop() {
      // Read a value from the button and store
      // it in the new variable "value".
      int value = digitalRead(2);

      // Then we can use this variable in the code
      // to determine the current button state:
      // if the variable contains the value 1 then
      // the button is pressed, and if it contains 0
      // then the button is not pressed.

      // Print the value to the serial port.
      Serial.println(value);
    }
  \end{minted}
  \caption{Logging button states to a computer.}
  \label{listing:button-01}
\end{listing}

Unfortunately when we look close enough we will see that even if the button is
not pressed, sometimes there are stray ``1'' values in the log.  How is it so?
The explanation is simple: as we seen in the ``White noise'' chapter, we are
surrounded by electromagnetic background that captured by circuits and this in
turn leads to the situation where sometimes the value on digital ports crosses
the bar where Arduino considers it as the value ``1''.

We can solve this problem at least in two ways.  The first one is that we can
use a special \emph{pull-down resistor} that will pull the value on a digital
port where the button is connected to the ground (GND.)

\figureButtonPulldownResistorCircuit{en}

The digital port must be configured in \mintinline{cpp}{INPUT_PULLUP} mode.  The
rest of the example code stays the same.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      pinMode(2, INPUT_PULLUP);
      Serial.begin(9600);
    }

    void loop() {
      // Read a value from the button and store
      // it in the new variable "value".
      int value = digitalRead(2);

      // Then we can use this variable in the code
      // to determine the current button state:
      // if the variable contains the value 1 then
      // the button is pressed, and if it contains 0
      // then the button is not pressed.

      // Print the value to the serial port.
      Serial.println(value);
    }
  \end{minted}
  \caption{An example of \mintinline{cpp}{INPUT_PULLUP} mode usage.}
  \label{listing:game-dev-input-pullup-example}
\end{listing}

In this mode the button behavior is ``inverted'' -- when it is pressed, then the
digital port value will be ``0'' (\mintinline{cpp}{LOW}) and when it is not, the
value will be ``1'' (\mintinline{cpp}{HIGH}.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Handling button presses}
\index{Game development!Button connection!Handling button presses}

First let's set the digital port number to which our first (and the only, for
now) button is connected as a named constant \mintinline{cpp}{BUTTON_R} (``R''
stands for ``Right''.)

\begin{listing}[H]
  \begin{minted}{cpp}
    #include <LiquidCrystal_I2C.h>

    LiquidCrystal_I2C lcd(0x27,  16, 2);

    // Control buttons.
    const char BUTTON_R = 2;      // "RIGHT"

    const char PLAYER = '@';

    int player_x = 0;
    int player_y = 0;
  \end{minted}
  \caption{Setting constants for control buttons.}
  \label{listing:game-dev-button-constants}
\end{listing}

Then in \mintinline{cpp}{setup} we have to configure the digital port mode for
the button using \mintinline{cpp}{pinMode} procedure, as we did in the previous
examples.

\begin{listing}[H]
  \begin{minted}{cpp}
    void setup() {
      lcd.init();
      lcd.backlight();

      // Control buttons configuration.
      pinMode(BUTTON_R, INPUT_PULLUP);
    }
  \end{minted}
  \caption{Setting the \mintinline{cpp}{INPUT_PULLUP} mode for a digital port.}
  \label{listing:game-dev-input-pullup-mode}
\end{listing}

After that we have to choose how we will handle button presses.  Currently the
easiest way for us is to sequential polling of button ports, other ways to
handle buttons we will discuss later.

To handle the button presses we will check in \mintinline{cpp}{loop} the value
for digital port where the button is connected, using the already familiar
\mintinline{cpp}{digitalRead}.  When the check shows that the button value is
\mintinline{cpp}{LOW}, we will change the player position in the game.

\begin{listing}[H]
  \begin{minted}{cpp}
    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        player_x++;
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);
    }
  \end{minted}
  \caption{Changing the player position on the ``RIGHT'' button press.}
  \label{listing:game-dev-button-right}
\end{listing}

Thus when we press the ``RIGHT'' button, we will get the movement of a player to
the right.

Overall, the full code of our game currently looks like this:

\begin{listing}[H]
  \begin{minted}{cpp}
    #include <LiquidCrystal_I2C.h>

    LiquidCrystal_I2C lcd(0x27,  16, 2);

    // Control buttons.
    const char BUTTON_R = 2;      // "RIGHT"

    const char PLAYER = '@';

    int player_x = 0;
    int player_y = 0;

    void setup() {
      lcd.init();
      lcd.backlight();

      // Configuration of control buttons.
      pinMode(BUTTON_R, INPUT_PULLUP);
    }

    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        player_x++;
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);
    }
  \end{minted}
  \caption{The full example of ``RIGHT'' button handling.}
  \label{listing:game-dev-button-right-full-example}
\end{listing}

Nevertheless, here lies a problem -- after a single (to our naive observation)
button press the player may run to the end of the game map, or even run away
from the display altogether.  This is due to the fact that even a short (single)
button press from the point of computer view takes a very long time.  During
this time, while we hold our finger on a button before releasing it, the
\mintinline{cpp}{loop} procedure can run several times; thus the button value
gets read and handled many times.

To fix this problem we can add a short delay (100ms, for example) at the end of
\mintinline{cpp}{loop} procedure:

\begin{listing}[H]
  \begin{minted}{cpp}
    void loop() {
      if (digitalRead(BUTTON_R) == LOW) {
        player_x++;
      }
      lcd.setCursor(player_x, player_y);
      lcd.print(PLAYER);

      // A delay to avoid too fast reading
      // of the button state.
      delay(100);
    }
  \end{minted}
  \caption{Adding a delay to the \mintinline{cpp}{loop} procedure to improve the
    button reading.}
  \label{listing:game-dev-button-delay}
\end{listing}

\end{document}
