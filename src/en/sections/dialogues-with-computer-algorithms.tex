\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algorithms}
\index{Programming!Algorithm}

Long before computer was made, people were already writing instructions for each
other that allowed us to understand the sequence of steps to achieve some goal --
for example, ``how to make a fire'', ``how to sow grain'', ``how to harness a
horse'' and so on.

A sequence of instructions that allows us to achieve a desired result called an
\emph{algorithm}.

There were some (rather successful) attempts to build different mechanisms that
did some sequence of operations to replace human labor.  But after inventing
electronic computers the development of algorithms reached ``another level'' --
now we can write an algorithm into computer memory so the computer will execute
the instructions exactly as we want them.  Modern computers don't understand
human languages directly so we have to write down our algorithms in the form of
special \emph{machine language}.  A machine language is a set of commands
understood by a processor (the main computation device in a computer.)

Writing programs in machine language is a quite hard and tedious task so soon
after computers were invented people came up with the first programming
languages that are more friendly to humans.  The first programming language was
called \emph{assembler} (also known as \emph{assembly language}), that is but a
set of mnemonics (that is, a set of short human-understandable names) for
machine commands of a processor.

But assembler was too simple and did not provide programmers with tools to
easily express ideas that they wanted to implement in their algorithms in
concise manner.  So high-level programming languages were invented that
simplified and sped-up the process of writing programs.  ``C'' language which
basics we will discuss in this chapter is one of the oldest programming language
that are actively used to this day.

To practice with composition of algorithms let's assume that we have an LED that
is connected to a computer.  To explain to a computer how to blink this LED we
have to formulate an algorithm.  This process is called \emph{formalization}.
One of possible algorithms for this task could look as follows:

\begin{enumerate}
\item Turn on the LED.
\item Turn off the LED.
\item Repeat the algorithm.
\end{enumerate}

In this example we see not only the instructions to turn on/turn off the LED but
also some kind of \emph{loop}, the cyclic nature of the process.

\experiment{0} { Try to come up with algorithms for ordinary operations that you
  do daily.  For example, you can try to formulate an algorithm of how to
  prepare a tea, or an algorithm of house cleaning activities.  How precise can
  you describe the sequence of actions for simple tasks?  How complicated is the
  resulting algorithm? }

When we are composing algorithms we have to consider the fact that computers
mostly have two important properties:
\begin{enumerate}
\item On one hand, computers are very fast at solving some tasks.  Even the CPU
  of the Arduino Mega 2560 microcontroller platform has the frequency of
  16MHz\footnote{\url{https://docs.arduino.cc/hardware/mega-2560/}} which gives
  us around 16 millions operations per second.\footnote{In reality this value is
  lesser than that indeed as different processor instructions take different
  number of processor cycles.}  Modern computers greatly surpass humans in the
  speed of computation and the amount of the stored information.
\item On the other hand, computers are mostly ``dumb'' -- in the sense that they
  only do what was written in the instructions.  Here we don't talk about more
  ``intellectual'' systems, such as large language models or other systems with
  complex behavior.
\end{enumerate}

From this we can say that a computer will diligently and quickly do what a
programmer specified in a program, even if the instructions are wrong (with one
rule that they must be properly written -- in other words, without syntax
errors.)

Thus, even the process of formulating algorithms for seemingly simple tasks
require great attention to the details.

For example, the algorithm for blinking one LED that we formulated above, has
one important drawback: it does not specify the explicit time span for
operations.  Although the LED blinking operation implies some delay after
turning LED on and off (as intuition tells us), the algorithm does not specify
it -- therefore the computer will do those operations as quickly as the system
allows it to do.  In the result, the LED will appear for us as constantly turned
on.

Let's improve our algorithm by adding the required half-second delays (500ms) to
it:

\begin{enumerate}
\item Turn on the LED.
\item Wait for 500ms.
\item Turn off the LED.
\item Wait for 500ms.
\item Repeat the algorithm.
\end{enumerate}

In order for this algorithm to be executed in principle, we have to translate it
into some kind of intermediate language that is understood both by a human and a
computer (given that we have the right translator -- a \emph{compiler}.)

\end{document}
