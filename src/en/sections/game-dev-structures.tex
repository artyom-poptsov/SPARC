\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structures}
\index{Programming!Structures}

When we are developing complex projects, such as computer games, it is important
to keep the source code structured.  As we saw before, some of the auxiliary
game procedures accept two or even more parameters.  Also now we are operating
with such complex entities as ``Player'', ``Game map'', ``Game object'' and so
on.

In such conditions, passing separate variables that describe some concrete
object to procedures does not seem like a good idea.  It would be better to
group, for example, player coordinates and the health points into a complex
object that we can pass to procedures for processing.

Fortunately we have a way to do it -- by the means of \emph{structures}.  A
structure is a complex type of a variable that allow to store several values
(possible of a different type) inside.  This is akin to a simple array but while
in an array all the elements belong to one type, in a structure we can use
several different types for fields.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Declaration of a structure}
\index{Programming!Structures!Declaration}

For example, a structure that describes a player may look like this:

\begin{listing}[H]
  \begin{minted}{cpp}
    struct player {
      int x;
      int y;
      char image;
      byte hp;
    };
  \end{minted}
  \caption{A description of a player as a structure.}
  \label{listing:game-dev-structure}
\end{listing}

Variables \mintinline{cpp}{x}, \mintinline{cpp}{y}, \mintinline{cpp}{image} and
\mintinline{cpp}{hp} are \emph{fields} of the structure -- as they describe the
\emph{properties} of an object.

We can declare a structure, for example, somewhere in the global scope, outside
the procedures of our program.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creation and initialization of structure instances}
\index{Programming!Structures!Creation and initialization}

To create a player we have to make an \emph{instance} of the structure.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Creation of "p" variable,
    // that holds an instance of "player" structure:
    struct player p;
  \end{minted}
  \caption{Creation of a structure instance.}
  \label{listing:game-dev-structure-instance}
\end{listing}

When we are creating variables we have to initialize them.  The same with
structures -- and we can perform initialization right after creating of a
structure instance:

\begin{listing}[H]
  \begin{minted}{cpp}
    // Creation of "p" variable,
    // that holds an instance of "player" structure:
    struct player p = {
      0,   // x
      0,   // y
      '@', // image
      100  // HP
    };
  \end{minted}
  \caption{Initialization of a structure instance.}
  \label{listing:game-dev-structure-instance-init}
\end{listing}

It's important to note that the initialization of the structure fields must be
done in the same order as the fields listed in the structure declaration.  The
comments written to the right side of each field in the listing
\ref{listing:game-dev-structure-instance-init} were added specifically so as not
to confuse the order of values.  That helps us to avoid situations like when the
health points of a player suddenly become the symbol code for the player image.

We can use the following syntax to solve the problem of getting the order of
values right:

\begin{listing}[H]
  \begin{minted}{cpp}
    // Creation of "p" variable,
    // that holds an instance of "player" structure:
    struct player p = {
      .x     = 0,
      .y     = 0,
      .image = '@',
      .hp    = 100
    };
  \end{minted}
  \caption{Structure initialization using field names.}
  \label{listing:game-dev-structure-instance-init-names}
\end{listing}

The way that is shown in the listing
\ref{listing:game-dev-structure-instance-init-names} allows us to set the values
for structure fields in an arbitrary order, by explicitly specifying the names
of the fields.  With that, we don't have to add comments to the values anymore,
as it follows from the field names what the value means.  Unfortunately this
approach is not supported on some platforms, namely on Arduino.

Another way of the initialization is to set the field values after a structure
instance is created.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Creation of "p" variable,
    // that holds an instance of "player" structure:
    struct player p;

    void setup() {
      // Setting values for the structure fields.
      p.x = 0;
      p.y = 0;
      p.hp = 100;
      p.image = '@';
    }
  \end{minted}
  \caption{Setting the structure values after the creation of the structure.}
  \label{listing:game-dev-structure-assignment}
\end{listing}

To access the structure fields we can use syntax where the structure field name
is written after the variable that holds the structure instance, separated with
a dot.  As in the case of regular variables, we can assign values to the
structure fields and substitute the field values in expressions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``typedef'' keyword}
\index{Programming!typedef}

In C and C++ languages there is a special \mintinline{cpp}{typedef} keyword that
allows us to create shorter and more concise names for the existing types and
structures.

This is especially useful when we're working with structures.  Thanks to
\mintinline{cpp}{typedef}, we can save ourselves from the necessity of writing
the \mintinline{cpp}{struct} keyword each time when we declare a new variable
with the structure type.

\begin{listing}[H]
  \begin{minted}{cpp}
    struct player {
      int x;
      int y;
      char image;
      byte hp;
    };

    // Creating a short name for a structure.
    typedef struct player player_t;

    // Declaring a variable with "player_t" type:
    player_t p;

    void setup() {
      // Setting the values for the structure:
      p.x = 0;
      p.y = 0;
      p.hp = 100;
      p.image = '@';
    }

    // ...
  \end{minted}
  \caption{An example of \mintinline{cpp}{typedef} keyword usage.}
  \label{listing:game-dev-structure-typedef}
\end{listing}

It is shown in the listing \ref{listing:game-dev-structure-typedef} that we can
set a short name \mintinline{cpp}{player_t} for the structure describing a
player.

There's a frequently used naming convention for the new types in C language
where the underscore along with with ``t'' letter (from ``type'') are added at
the end of the type name.  We will use this style throughout the book.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Nested structures}
\index{Programming!Structures!Nested structures}

Sometimes an entity that we want to describe as a structure is complex enough,
so we may want to separate it into several simpler entities.

In our case we can describe separately the ``Point'' entity, as a structure on
its own.  It will allow us to combine ``x'' and ``y'' into one object and pass
it into procedures.

\begin{listing}[H]
  \begin{minted}{cpp}
    struct point {
      int x;
      int y;
    };

    typedef struct point point_t;

    struct player {
      point_t position;
      char image;
      byte hp;
    };

    typedef struct player player_t;
  \end{minted}
  \caption{An example of nested structures.}
  \label{listing:game-dev-nested-structures}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Usage of structures}
\index{Programming!Structures!Usage}

Now that we have structures, we can make the source code of the game more
convenient and readable.  For example, instead of passing \mintinline{cpp}{x},
\mintinline{cpp}{y} coordinates into procedures that check the presence of an
object on a map, we can pass an instance of \mintinline{cpp}{point_t} structure.

\begin{listing}[H]
  \begin{minted}{cpp}
    // A structure that describes a point on a game map.
    struct point {
      int x;
      int y;
    };

    typedef struct point point_t;

    // A procedure that returns 1 (true) in the case when
    // there's a key in the map cell addressed by "point".
    // Otherwise it returns 0 (false).
    bool is_key(point_t point) {
      return game_map[point.y][point.x] == KEY;
    }
  \end{minted}
  \caption{An example of using a structure for simplifying the game code.}
  \label{listing:game-dev-structure-usage-00}
\end{listing}

We can see in the listing \ref{listing:game-dev-structure-usage-00} that
\mintinline{cpp}{is_key} procedure was re-written so now it accepts an
\mintinline{cpp}{point_t} structure instance as the argument.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Passing a structure instance by its pointer}
\index{Programming!Structures!Passing by the pointer}

There's an important moment that we often have to take into the account: when we
pass a structure instance into a procedure as was shown before, this instance is
being \emph{copied} to the procedure parameters.  Moreover, when the computer
finishes procedure execution, it deletes the copy of a structure instance, as
the rest of the local variables inside the procedure.  Also the copying leads to
memory overhead and slows down the procedure calls.

One of the important takes from all things said is that if would try to change
the structure instance values inside a procedure, it would not work as it will
not affect the procedure instance outside the procedure.

\begin{listing}[H]
  \begin{minted}{cpp}
    // Erroneous procedure definition
    // that changes values inside a structure.
    move(point_t point, int dx, int dy) {
      point.x += dx;
      point.y += dy;
    }

    void loop() {
      // ...

      point_t point = { 10, 20 };
      move(point, 2, 4);

      // Here we would find out that the point
      // coordinates are still 10, 20, instead of
      // expected 12, 24.

      // ...
    }
  \end{minted}
  \caption{Erroneous attempt to change the procedure instance values inside
    procedure.}
  \label{listing:game-dev-structure-usage-01}
\end{listing}

One of the simplest solutions of this problem is to move the structure instance
out to the global scope, instead of passing it into a procedure -- it will allow
us to work with this instance as with any other variable.  But his solution has
notable drawbacks.  For example, as with the case of any other global variable,
a global structure instance will be always getting in the way, provoking us to
make errors and cluttering the code with extra global variables.  After all, the
more global variables we have in our code, the uglier is our code.

\index{Programming!Pointers} The right solution for this problem requires us to
study another topic that we were ignoring up until this moment.  If we want to
change the structure fields inside a procedure, we need to pass the structure
instance itself instead of its copy.  We can achieve this by passing a
\emph{pointer} to a procedure.  By \emph{pointer} we mean an address of memory
where some variable is stored.

Pointers and working with memory is one of the very important topics when we
study such low-level languages as C and C++.  We will discuss pointers in detail
later, for now we have to just figure out all we need for their basic usage.

\end{document}
