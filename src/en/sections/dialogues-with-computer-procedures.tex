\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Procedures, functions and methods}
\index{Programming!Procedures, functions and methods}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The concept of procedure}

At this moment, we already know some basic Arduino commands that allow us to
configure digital ports and control their values, and to wait for a specific
time.  Having such set of tools, we already can do some basic effects of LED
blinking, such as ``Chasing lights''.

Over time, we may notice that with adding more LEDs to a project the size of the
source code grows very quickly, which makes the further work less comfortable.
We somewhat solved this problem by using \emph{loops}, thus instructing the
computer to repeat specific code according to the written parameters of a loop.

Nevertheless, if we take another glance on the implementation of LED blinking
with \mintinline{cpp}{for} loop, we may notice another potential for the further
code improvement.

\begin{listing}[ht]
  \begin{minted}[
      highlightlines={9-12,15-18}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        digitalWrite(p, HIGH);
        delay(100);
        digitalWrite(p, LOW);
        delay(100);
      }
      for (int p = 6; p > 2; p--) {
        digitalWrite(p, HIGH);
        delay(100);
        digitalWrite(p, LOW);
        delay(100);
      }
    }
  \end{minted}
  \label{listing:for-loop-example-1}
  \caption{An example of ``Chasing lights'' effect implemented through
    \mintinline{cpp}{for} loop.}
\end{listing}

We can see in the listing \ref{listing:for-loop-example-1} that
\mintinline{cpp}{loop} contains two \mintinline{cpp}{for} loops, that make the
``Chasing lights'' effect where LEDs blink in order from one side to another,
and then in reverse order.  More importantly, the highlighted parts of the code
(that specifically make the blinking effect) are identical in both loops.

The thing is that our computer has very limited set of commands and the concept
of ``blinking'' is foreign for it -- unless we write the algorithm for it.  But
even with that we are bound to explain this concept to the computer again and
again.  But we have a way to explain the concept of ``blinking'' in such way
that a computer will remember it -- by introducing a new command of ``blinking''
that we can use in the further code.

Such commands usually called \emph{``procedures''} or \emph{``functions''}.

Let's take a look on a modified version of the code.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={7-12, 16, 19}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void blink() {
      digitalWrite(2, HIGH);
      delay(100);
      digitalWrite(2, LOW);
      delay(100);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink();
      }
      for (int p = 6; p > 2; p--) {
        blink();
      }
    }
  \end{minted}
  \label{listing:procedure-example-1}
  \caption{An example of procedure implementation.}
\end{listing}

We may notice that there is declaration of a ``blink'' procedure from the 7th
until 12th line.  Also we can see from lines 8th to 11th the \emph{body} of the
procedure -- that's specifically the useful work that procedure does when it's
called.

Furthermore, on the 16th line the ``blink'' procedure is being \emph{called} --
that is, when the computer executes this line, it remembers what it did before
the procedure, then ``jumps'' into the ``blink'' procedure, executes its body,
and them returns to back the point of the procedure call and continues the
execution of the code that follows the procedure call.

As we can see, we can call procedures arbitrary number of times -- for example,
we call ``blink'' procedure again on the 19th line.

Unfortunately, our example has an important drawback -- ``blink'' procedure
always blinks just one LED (on the 2nd digital port), and we don't have any way
to change that when the procedure is called.  Let's add \emph{parameters} to the
procedure to fix this issue.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Formal and actual parameters}

When we're working with procedures, very often we have to have a way to
influence how the procedure works.  To make it possible we have to specify
\emph{parameters} for the procedure.

\begin{listing}[H]
  \begin{minted}[highlightlines={1}]{cpp}
    void blink(int n) {
      digitalWrite(n, HIGH);
      delay(100);
      digitalWrite(n, LOW);
      delay(100);
    }
  \end{minted}
  \label{listing:procedure-example-2}
  \caption{Declaration of ``blink'' procedure with one parameter.}
\end{listing}

In the listing \ref{listing:procedure-example-2} we can see that the declaration
of ``blink'' procedure was changed -- we have added the variable titled
\mintinline{cpp}{n} in the parenthesis, just after the procedure name.  We may
notice that the variable is not initialized with a value -- it will get the value
when we call the procedure.

Parameters that are specified in the parenthesis in the procedure call are
called \emph{formal parameters}.

The \mintinline{cpp}{n} variable is used in the procedure body as any other
variable.  In our case it is passed into \mintinline{cpp}{digitalWrite} as the
number of a digital port.

\end{document}
