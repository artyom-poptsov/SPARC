\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Procedures, functions and methods}
\index{Programming!Procedures, functions and methods}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The concept of procedure}

At this moment, we already know some basic Arduino commands that allow us to
configure digital ports and control their values, and to wait for a specific
time.  Having such set of tools, we already can do some basic effects of LED
blinking, such as ``Chasing lights''.

Over time, we may notice that with adding more LEDs to a project the size of the
source code grows very quickly, which makes the further work less comfortable.
We somewhat solved this problem by using \emph{loops}, thus instructing the
computer to repeat specific code according to the written parameters of a loop.

Nevertheless, if we take another glance on the implementation of LED blinking
with \mintinline{cpp}{for} loop, we may notice another potential for the further
code improvement.

\begin{listing}[ht]
  \begin{minted}[
      highlightlines={9-12,15-18}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        digitalWrite(p, HIGH);
        delay(100);
        digitalWrite(p, LOW);
        delay(100);
      }
      for (int p = 6; p > 2; p--) {
        digitalWrite(p, HIGH);
        delay(100);
        digitalWrite(p, LOW);
        delay(100);
      }
    }
  \end{minted}
  \label{listing:for-loop-example-1}
  \caption{An example of ``Chasing lights'' effect implemented through
    \mintinline{cpp}{for} loop.}
\end{listing}

We can see in the listing \ref{listing:for-loop-example-1} that
\mintinline{cpp}{loop} contains two \mintinline{cpp}{for} loops, that make the
``Chasing lights'' effect where LEDs blink in order from one side to another,
and then in reverse order.  More importantly, the highlighted parts of the code
(that specifically make the blinking effect) are identical in both loops.

The thing is that our computer has very limited set of commands and the concept
of ``blinking'' is foreign for it -- unless we write the algorithm for it.  But
even with that we are bound to explain this concept to the computer again and
again.  But we have a way to explain the concept of ``blinking'' in such way
that a computer will remember it -- by introducing a new command of ``blinking''
that we can use in the further code.

Such commands usually called \emph{``procedures''} or \emph{``functions''}.

Let's take a look on a modified version of the code.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={7-12, 16, 19}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void blink() {
      digitalWrite(2, HIGH);
      delay(100);
      digitalWrite(2, LOW);
      delay(100);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink();
      }
      for (int p = 6; p > 2; p--) {
        blink();
      }
    }
  \end{minted}
  \label{listing:procedure-example-1}
  \caption{An example of procedure implementation.}
\end{listing}

We may notice that there is declaration of a ``blink'' procedure from the 7th
until 12th line.  Also we can see from lines 8th to 11th the \emph{body} of the
procedure -- that's specifically the useful work that procedure does when it's
called.

Furthermore, on the 16th line the ``blink'' procedure is being \emph{called} --
that is, when the computer executes this line, it remembers what it did before
the procedure, then ``jumps'' into the ``blink'' procedure, executes its body,
and them returns to back the point of the procedure call and continues the
execution of the code that follows the procedure call.

As we can see, we can call procedures arbitrary number of times -- for example,
we call ``blink'' procedure again on the 19th line.

Unfortunately, our example has an important drawback -- ``blink'' procedure
always blinks just one LED (on the 2nd digital port), and we don't have any way
to change that when the procedure is called.  Let's add \emph{parameters} to the
procedure to fix this issue.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Formal and factual parameters}

When we're working with procedures, very often we have to have a way to
influence how the procedure works.  To make it possible we have to specify
\emph{parameters} for the procedure.

\begin{listing}[H]
  \begin{minted}[highlightlines={1}]{cpp}
    void blink(int n) {
      digitalWrite(n, HIGH);
      delay(100);
      digitalWrite(n, LOW);
      delay(100);
    }
  \end{minted}
  \label{listing:procedure-example-2}
  \caption{Declaration of ``blink'' procedure with one parameter.}
\end{listing}

In the listing \ref{listing:procedure-example-2} we can see that the declaration
of ``blink'' procedure was changed -- we have added the variable titled
\mintinline{cpp}{n} in the parenthesis, just after the procedure name.  We may
notice that the variable is not initialized with a value -- it will get the value
when we call the procedure.

Parameters that are specified in the parenthesis in the procedure call are
called \emph{formal parameters}.

The \mintinline{cpp}{n} variable is used in the procedure body as any other
variable.  In our case it is passed into \mintinline{cpp}{digitalWrite} as the
number of a digital port.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={7-12, 16, 19}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void blink(int n) {
      digitalWrite(n, HIGH);
      delay(100);
      digitalWrite(n, LOW);
      delay(100);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(2);
      }
      for (int p = 6; p > 2; p--) {
        blink(3);
      }
    }
  \end{minted}
  \label{listing:procedure-example-3}
  \caption{An example of a procedure call with parameters.}
\end{listing}

Let's take a look at the full \ref{listing:procedure-example-3} listing.  We can
see that on the 16th line when we call ``blink'' procedure we now added the
number 2 in the parenthesis -- this number will be \emph{copied} into the
procedure body, as the value of \mintinline{cpp}{n} variable.  On the 19th line
we called the same procedure, but this time we passed 3 as the parameter value.
Thus in the first loop we will get the 3rd LED blinking on the digital port
number 2 five times, and in the second loop we will get LED blinking on the
digital port number 3.

Parameters that set on the procedure call are called \emph{factual parameters}.

If we want to make the ``Chasing lights'' effect we need to put a variable from
a loop into procedure factual parameters instead of numeric constants (such as 2
or 3.)

\begin{listing}[H]
  \begin{minted}[
      highlightlines={3, 6}
    ]{cpp}
    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(p);
      }
      for (int p = 6; p > 2; p--) {
        blink(p);
      }
    }
  \end{minted}
  \label{listing:procedure-example-4}
  \caption{An example of ``Chasing lights'' effect implementation.}
\end{listing}

It is important to point out that in the example
\ref{listing:procedure-example-4} the value of \mintinline{cpp}{p} variable is
being \emph{copied} into the ``blink'' procedure, where it is becoming the value
of \mintinline{cpp}{n} parameter.

\begin{listing}[H]
  \begin{minted}[highlightlines={1, 3, 5}]{cpp}
    void blink(int n, int d) {
      digitalWrite(n, HIGH);
      delay(d);
      digitalWrite(n, LOW);
      delay(d);
    }
  \end{minted}
  \label{listing:procedure-example-5}
  \caption{Declaration of ``blink'' procedure with two parameters.}
\end{listing}

Now let's take a look at an example where we will influence two procedure
parameters: the number of a digital port and the time of a delay between LED
turning on and off.  For this we will need to modify ``blink'' procedure as is
shown in the listing \ref{listing:procedure-example-5}.

The full code example of a modified procedure is shown in the listing below.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={7-12, 16, 19}
    ]{cpp}
    void setup() {
      for (int p = 2; p < 7; p++) {
        pinMode(p, OUTPUT);
      }
    }

    void blink(int n, int d) {
      digitalWrite(n, HIGH);
      delay(d);
      digitalWrite(n, LOW);
      delay(d);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(p, 200);
      }
      for (int p = 6; p > 2; p--) {
        blink(p, 100);
      }
    }
  \end{minted}
  \label{listing:procedure-example-6}
  \caption{An example of a procedure call with two parameters.}
\end{listing}

Let's discuss the loops inside the \mintinline{cpp}{loop} procedure in the
listing \ref{listing:procedure-example-6}.  We can see that the value of
\mintinline{cpp}{p} variable is being passed into ``blink'' procedure as the
first factual parameter in both loops, while a numerical constant is being
passed in the procedure as the second parameters: in the first loop it's the
number 200 and in the second loop it's 100.

An important point is that the passing of parameters into a loop is
\emph{position-dependent} -- that is, the factual parameters are being copied
into formal parameters in a procedure in the same order as they are specified
inside the parenthesis.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={12}
    ]{cpp}
    // ...

    void blink(int n, int d) {
      digitalWrite(n, HIGH);
      delay(d);
      digitalWrite(n, LOW);
      delay(d);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(200, p);
      }
      // ...
    }
  \end{minted}
  \label{listing:procedure-example-7}
  \caption{An example of a erroneous call of procedure with two parameters.}
\end{listing}

In other words, if we change the order of ``p'' and ``100'' parameters in the
procedure call (as is shown in the \ref{listing:procedure-example-7} listing),
we will get 100 in the ``n'' parameter and the value which is dependent on the
loop iteration in the ``d'' parameter (which obviously does not make much
sense.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Terminology issues}

Concepts of \emph{procedures}, \emph{functions} and even methods exist in most
programming languages.  More often, when we are reading books, listening to
lectures and communicating with other programmers\footnote{Probably the
communication with other, more experienced, programmers is one of the most
important ways of learning.  Here we can just sympathize to introverts.} we will
encounter precisely the concept of functions.  Let's figure out what the
difference between the aforementioned concepts and how we can use them properly
in different contexts.

We will stick to the terminology that is proposed\cite[28]{sicp-en} by the
authors of ``Structure and interpretation of computer programs'' book,
specifically we will separate the terms ``function'' and ``procedure''.  In our
understanding, a ``function'' is a mathematical term that not always can be
applied to what we write in our programs.  In mathematics the description of a
function give almost no information about the sequence of steps that we need to
do to achieve the expected results -- instead, we end up with a
\emph{declarative} description (that answers the question ``what needs to be
done?'')  On the other hand, in informatics (and programming in particular) we
need to know the sequence of steps in details, that allows us to achieve the
expected result (that is, we need knowledge that answers the ``how to do that?''
question.)

Moreover, in the programming, procedures often modify some \emph{global state}
of the system, where they are executed -- for example, they may modify the value
of some global variables, or change the values on digital ports (as in the case
with Arduino) and so on.  Because of that, repeated calls to the same procedure
with the same input parameters may lead to different effects, due to this global
state.  This, usually, differs from the behavior of mathematical functions where
a call to the same procedure with the same parameters will lead each time to the
same results.

With that said, we will be using the term \emph{procedure} in the book.

Other term that we can face sometimes is \emph{method}.  This term is usually
used in the context of object-oriented programming.  We will talk about this
topic later, but for now we can use a short definition that a method is a
procedure declared inside a class.  At this stage the meaning of that words may
elude us but this is fine as our programming knowledge progresses, this term
will inevitably became easy to understand and familiar.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Another glance on procedures}

Let's take a look on a \mintinline{cpp}{blink} procedure example, specifically
on line where we call it.

\begin{listing}[H]
  \begin{minted}[
      highlightlines={12}
    ]{cpp}
    // ...

    void blink(int n, int d) {
      digitalWrite(n, HIGH);
      delay(d);
      digitalWrite(n, LOW);
      delay(d);
    }

    void loop() {
      for (int p = 2; p < 7; p++) {
        blink(200, p);
      }
      // ...
    }
  \end{minted}
  \label{listing:procedure-example-8}
  \caption{An example of procedure call with two parameters.}
\end{listing}

As we can see in example \ref{listing:procedure-example-8}, the call to
\mintinline{cpp}{blink} is very similar to a call to
\mintinline{cpp}{digitalWrite}.  Let's compare those two calls: in one case we
see the name of a procedure being called (\mintinline{cpp}{blink} in one case,
and \mintinline{cpp}{digitalWrite} in another), then we see brackets where
factual parameters are written.  We can draw a conclusion that as those two
things are similar then they are something of the same type.\footnote{The
feeling of similarity in the programming is rarely misleading.  To explain this
figuratively if something looks like a duck and quacks like a duck -- then likely
it is a duck.  While we gain more experience in the programming we will see
similarity of things more often not only inside one programming language, but
between different languages as well.}

And indeed, \mintinline{cpp}{blink} and \mintinline{cpp}{digitalWrite} are
procedures that we call in our code.  The only difference is that
\mintinline{cpp}{digitalWrite} procedure was written by someone else and is
included to the standard library of Arduino procedures, while
\mintinline{cpp}{blink} we wrote ourselves.

An interesting idea to ponder is that by writing our procedures we are sort of
\emph{extending} the programming language with new commands, ``bending'' it to
our task at hand.  And that's perfect!  Because when we have a set of commands
specifically designed for our tasks, solutions may form naturally as if on their
own, without mental struggles from our side.

\end{document}
