\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bitwise operators}
\index{Programming!Bitwise operators}

There are special \emph{bitwise operators} in C language that allow us to
conveniently handle individual bits.  They include:

\begin{itemize}
\item Bitwise ``NOT'' -- denoted by tilde ``$\sim$'' symbol.
\item Bitwise ``AND'' -- denoted by ampersand ``\&'' symbol.
\item Bitwise ``OR'' -- denoted by vertical bar ``|'' symbol.
\item Bitwise exclusive ``OR'' (``XOR'') -- denoted by caret ``\textasciicircum'' symbol.
\item Bitwise left shift (``$<<$'') and right shift (``$>>$''.)
\end{itemize}

The bitwise operation of negation is an \emph{unary} operation -- that is, it is
operating upon only one operand (argument.)  All other listed operations are
\emph{binary} -- that is, they operate upon two operands (arguments.)

Let's discuss each operation in detail.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bitwise ``NOT''}

\tableBitwiseNOT{en}

Unary operation of bitwise ``NOT'' produces logical negation of each bit: zeroes
become ones, and ones become zeroes.  The operation is denoted by tilde symbol
(``$\sim$'') and must be written on the left side of an operand to which the
operation should be applied.

For example, if we apply ``NOT'' to an one-byte value of 5
(\mintinline{cpp}{0b00000101} in binary form) we will get the following result:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = ~a;
  // Result:
  //   NOT 0000 0101
  //     = 1111 1010
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bitwise ``AND''}

\tableBitwiseAND{en}

Bitwise ``AND'' is a binary operation that executes logical ``AND'' upon each
bit pairs of its two operands.  The operation is denoted by ampersand (``\&'')
symbol and accepts two operands (arguments), that must be written on the left
and on the right side of the operator.

For example:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = 0b00000100;
  byte c = a & b;
  // Result:
  //       0000 0101
  //   AND 0000 0100
  //     = 0000 0100
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bitwise ``OR''}

\tableBitwiseOR{en}

Bitwise ``OR'' is a binary operation that executes logical ``OR'' upon each bit
pairs of its two operands.  The operation is denoted by vertical line (``|'')
symbol.

For example:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = 0b00000010;
  byte c = a | b;
  // Result:
  //       0000 0101
  //    OR 0000 0010
  //     = 0000 0111
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Exclusive ``OR''}

\tableBitwiseXOR{en}

Exclusive ``OR'' (or ``XOR'', for short) is a binary operation that can be
applied to two bit values of the same size, and executes logical exclusive
``OR'' operation upon each bit pairs of its operands.  The operation is denoted
by caret (``\textasciicircum'') symbol.

For example:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = 0b00000110;
  byte c = a ^ b;
  // Result:
  //       0000 0101
  //   XOR 0000 0110
  //     = 0000 0011
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bitwise shift}

Bitwise shift is a binary operation that shifts the bits in the left operand by
the number of bits denoted by the right operand.  The direction of the shift is
determined by the kind of the shift operation:

\begin{itemize}
\item Left shift (``LSH'' for short) is denoted by two ``less than'' symbols
  that are written one next to the other (``$<<$'') and shifts bits of the left
  operand to the left side by the number of bits denoted by the right operand.
  The operation adds the amount of zeroes to the right side of the shifted
  value, which is equal to the right operand.  In the same time, leftmost bits
  of the left operand are pushed out (erased) from the value by the shifted
  bits.
\item Right shift (``RSH'' for short) is denoted by two ``more than'' symbols
  that are written one next to the other (``$>>$'') and shifts bits of the left
  operand to the right side by the number of bits denoted by the right operand.
  The operation adds the amount of zeroes to the left size of the shifted value,
  which is equal to the shift value.  In the same time, rightmost bits of the
  left operand are pushed out (erased) from the value by the of shifted bits.
\end{itemize}

Here's an example of left shift by one bit:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = a << 1;
  // Result:
  //   LSH 0000 0101
  //    =  0000 1010
\end{minted}

And here's an example of right shift by one bit:

\begin{minted}{cpp}
  byte a = 0b00000101;
  byte b = a >> 1;
  // Result:
  //   RSH 0000 0101
  //    =  0000 0010
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Practical application of bitwise operations}

\subsubsection{Setting a specified bit to one}

One of the frequent tasks is to set one specified bit in a value to one.  For
that, we can use bitwise ``OR'':

\begin{minted}{cpp}
  byte a = 0b10000000;
  a = a | 0b00010000;
  // Result:
  //       1000 0000
  //    OR 0001 0000
  //     = 1001 0000
\end{minted}

We can use bitwise left shift by 4 position to simplify the code, the result
will be the same, while the code will be shorter:

\begin{minted}{cpp}
  int a = 0b10000000;
  a = a | (1 << 4);
  // Step-by-step evaluation of the result:
  //   1. (1 << 4):
  //       0000 0001
  //   LSH 4
  //     = 0001 0000
  //
  //   2. a | (1 << 4):
  //       1000 0000
  //    OR 0001 0000
  //     = 1001 0000
\end{minted}

\subsubsection{Checking the bit value}

To check if a specified bit in a value is set to one we can use bitwise ``AND''
-- this operation usually called ``application of a bitmask'':

\begin{minted}{cpp}
  byte a = 0b10010000;

  int mask = 0b00010000;
  // Also we can specify the bitmask using the bitwise shift
  // operation, which is more concise and readable:
  //   mask = (1 << 4);

  if (a & mask) {
    // Some action that must be done when the five bit
    || from the right is set to 1.
  }
\end{minted}

\subsubsection{Setting a specified bit to zero}

To ``disable'' a bit in a value we can use bitwise ``AND'', along with an
inverted bitmask:

\begin{minted}{cpp}
  byte a = 0b10010000;
  a = a & ~(1 << 4);
  // Step-by-step evaluation of the result:
  //   1. (1 << 4):
  //       0000 0001
  //   LSH 4
  //     = 0001 0000
  //
  //   2. ~(1 << 4):
  //   NOT 0001 0000
  //     = 1110 1111
  //
  //   3. a & ~(1 << 4):
  //       1001 0000
  //   AND 1110 1111
  //     = 1000 0000
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Exercises}

We can use an I2C device to clearly see those operators in action.

\begin{enumerate}
\item Implement the ``Chasing lights'' effect using the I2C-adapter for an LCD
  with connected LEDs, using \ref{listing:communication-pcf8574} example.  For
  achieving the effect we can use bitwise operators.
\end{enumerate}
