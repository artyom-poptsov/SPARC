\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Переменные и память}

\emph{Переменная} -- это ключевое понятие в программировании. Любая программа
работает с данными. Возьмём для наглядности некую программу- калькулятор,
умеющую складывать два числа. Чтобы микроконтроллер мог работать с этими числами
их нужно где-то хранить. Где? В оперативной памяти. Все данные, которые
используются микроконтроллером во время работы, хранятся именно там. Для работы
нашего калькулятора нужно загрузить в ячейки оперативной памяти два
числа-операнда, которые нужно сложить, например 15 и 3:

\begin{tabular}{p{4cm}|p{6cm}}
  Адрес ячейки & Значение ячейки \\
  \hline \hline
  0000 & 15 \\
  \hline
  0001 & 3 \\
  \hline
  0003 & 0 \\
  ... & ... \\
\end{tabular}

\emph{Переменная} -- это ячейка данных в оперативной памяти (ОЗУ). Объявить
переменную –- значит сказать компьютеру выделить какую-нибудь ячейку памяти для
наших нужд.

Переменная в языке С++ имеет определённый тип и уникальное имя. Объявление
(\emph{инициализация}) переменной выглядит следующим образом:

\begin{verbatim}
тип имя = значение;
\end{verbatim}

То есть, чтобы загрузить в оперативную память два числа 15 и 3, мы должны написать
следующее:

\begin{minted}{cpp}
int a = 15;
int b = 3;
\end{minted}

Слово \texttt{int} это тип переменной, означает, что эта переменная является
числом.

Также следует объявить переменную для хранения результата сложения:

Дальше -- складываем значения двух переменных \texttt{a} и \texttt{b}:

\begin{minted}{cpp}
int result = a + b;
\end{minted}

Здесь мы присвоили переменной \texttt{result} результат операции сложения двух
переменных.

\emph{ВАЖНО!} Имя переменной может состоять только из букв, цифр и нижнего
подчёркивания, причём имя не может начинаться с цифры.

Вернёмся к нашим светодиодам. Объявим новую переменную:

\begin{minted}{cpp}
int k = 500;
\end{minted}

Что мы можем с ней сделать? Например, в программе мигания светодиодом заменим ею
значение задержки в функции \texttt{delay}. Вообще, переменным следует давать
осмысленные имена, в нашем случае пусть это будет не \texttt{k}, а
\texttt{delay\_val}:

\begin{minted}{cpp}
void loop() {
  int delay_val = 500;
  digitalWrite(2, HIGH);
  delay(delay_val);
  digitalWrite(2, LOW);
  delay(delay_val);
}
\end{minted}

Таким образом, мы сможем поменять значения всех задержек одной заменой значения
\texttt{delay\_val}:

\begin{minted}{cpp}
void loop() {
  int delay_val = 600;
  // ...
}
\end{minted}

Можно, например, увеличивать \texttt{delay\_val} на 100 при каждом выполнении
\texttt{loop}:

\begin{minted}{cpp}
void loop() {
  int delay_val = 100;
  digitalWrite(2, HIGH);
  delay(delay_val);
  digitalWrite(2, LOW);
  delay(delay_val);
  delay_val = delay_val + 100;
}
\end{minted}

Кстати, строчку \texttt{delay\_val = delay\_val + 100} можно заменить на
\texttt{delay\_val += 100} и результат будет тем же, но запись короче.

\texttt{+=} -- оператор присваивания, совмещённый со сложением.

Существуют также другие операторы подобного рода -- например, ``-='' (читается
``минус-равно'') Если мы запустим этот код, то увидим, что задержка переключения
светодиодов… не меняется. Почему? При каждом выполнении \texttt{loop} каждый раз
объявляется новая переменная \texttt{delay\_val} со значением 100 и потому
задержка остаётся той же. Сейчас \texttt{delay\_val} объявлена как локальная
переменная внутри \texttt{loop}, следует объявить её за пределами функции, чтобы
она стала глобальной:

\begin{minted}{cpp}
int delay_val = 100;

void loop() {
  digitalWrite(2, HIGH);
  delay(delay_val);
  digitalWrite(2, LOW);
  delay(delay_val);

  delay_val += 100;
}
\end{minted}

Теперь всё будет работать. Но так задержка будет бесконтрольно расти. Решением
будет сделать так, чтобы \texttt{delay\_val} увеличивалась до какого-то
порогового значения, например, до 600. Для этого нужно добавить условие
(\texttt{if}):

\begin{minted}{cpp}
int delay_val = 100;

void loop() {
  digitalWrite(2, HIGH);
  delay(delay_val);
  digitalWrite(2, LOW);
  delay(delay_al);

  if (delay_val < 600){
    delay_val += 100;
  }
}
\end{minted}

Об условиях и других управляющих конструкциях -- в следующей главе.

\end{document}
