\documentclass[../sparc.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ЖК-дисплей}
\index{Разработка игр!Дисплей}

Для вывода информации мы будем использовать \emph{жидкокристаллический дисплей}
(ЖК-дисплей), подключаемый к Arduino.  Принцип работы данных дисплеев аналогичен
обычным ЖК-дисплеям, которые выводят информацию на вашем компьютере.  Более
конкретно мы будем использовать \emph{текстовый} ЖК-дисплей, который
предназначен для вывода текстовых символов.

На текстовых ЖК-дисплеях, экран поделён на клетки, внутри каждой из которых
можно отрисовать один символ (букву, знак препинания, цифру, или просто
какую-либо картинку.)  Между клетками обычно находится расстояние в один
пиксель.  Подобные дисплеи плохо подходят для отрисовки произвольных
изображений, тем не менее, некоторый простор для творчества у нас имеется.

Несмотря на свойства дисплея, которые на первый взгляд кажутся слишком
ограничивающими для наших задач, используя наше мастерство и творческий подход,
мы можем добиться достаточно интересных результатов в плане разработки игр.

Рабочая область дисплея 16x2 (16 столбцов, 2 строки) схематически выглядит, как
показано на рис. \ref{fig:lcd-schematics}.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \draw[gray, step=0.5] (0, 0) grid (8, 1);
    \foreach [count=\i from 0] \x in {0.0, 0.5, 1.0, ..., 7.5} {
      \draw (\x, 1.5) node[anchor=north west] {\i};
    }
    \foreach [count=\i from 0] \y in {0.5, 0.0} {
      \draw (-0.5, \y) node[anchor=south west] {\i};
    }
  \end{tikzpicture}
  \caption{Схематическое изображение дисплея.}
  \label{fig:lcd-schematics}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Подключение дисплея}
\index{Электроника!ЖК-дисплей}

Для упрощения нашей работы мы будем использовать ЖК-дисплей с интерфейсом
передачи данных, который называется ``I2C'' (читается ``ай-ту-си''.)

Подробно о том, что такое ``I2C'', будет сказано в следующем дополнительном
подразделе.

Сейчас же, не вдаваясь в подробности можно сказать, что данный вариант
подключения требует всего 4 провода: питание, земля и две линии передачи данных.

Сам модуль I2C часто уже припаян к дисплею, но может идти и отдельно.  В случае
отдельного модуля, подключение выглядит, как на рис. \ref{fig:lcd-00}.

\begin{figure}[h]
  \centering
  \includegraphics[width=12cm]{schematics/lcd-00}
  \caption{Схема подключения ЖК-дисплея 16x2 по интерфейсу I2C к Arduino Mega
    2560.}
  \label{fig:lcd-00}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Шина I2C \Star}
\index{Электроника!Шина I2C}

\newglossaryentry{I2C}{name=I2C, description={Inter-Integrated Circuit}}

\newglossaryentry{USB}{name=USB, description={Universal Serial Bus --
    ``Универсальная последовательная шина.''}}

\newglossaryentry{PCI}{name=PCI, description={Peripheral component interconnect
    -- ``взаимосвязь периферийных компонентов''}}

\newglossaryentry{I/O}{name=I/O, description={I/O -- ``Input/Output''}}

\textit{\gls{I2C}}, $I^{2}C$ (читается ``ай-ту-си''), -- шина передачи данных,
используемая для связи между интегральными схемами внутри электронных приборов.
Давайте рассмотрим во-первых, что такое ``шина передачи данных''.  Если кратко,
то \textit{шина} (англ. \textit{bus}) в архитектуре компьютера -- это некое
соединение, служащее для передачи данных между функциональными блоками
коммьютера.

Шины передачи данных условно можно разделить на две крупные категории --
\textit{внешние} шины и \textit{внутренние} шины.

К внешним шинам можно отнести наверняка знакомый многим из вас \gls{USB} --
данная шина используется для соединения внешних устройств (таких, как Arduino,
клавиатура, мышь, принтер и т.п.) с компьютером.  Подобные шины как правило
имеют стандартизированный разъём и достаточно большую длину провода.

К внутренним шинам относится уже упомянутый выше \gls{I2C} и \gls{PCI}/PCI
Express (используемой например для подключения сетевой карты к материнской плате
компьютера.  Внутренние шины обычно подразумевают передачу данных на короткие
дистации, оперативное отключение/подключение компонентов не предусмотрено и,
следовательно, некоторые из внутренних шин не имеют своего специализированного
разъёма и бывают просто распаены прямо на плате.

Максимальная длина соединения между компонентами на шине \gls{I2C} не должна
превышать 30 сантиметров, в противном случае данные будут передаваться
ненадёжно.

\gls{I2C} имеет достаточно низкую скорость передачи данных (не более 5МБит/с)
между устройствами.  У каждого устройства есть свой \textit{адрес} на шине --
можно сказать, его поядковый номер.  На одну шину подключить до 127 устройств с
уникальными адресами.  При этом, на шине одно устройство является ведущим (как
правило, это какой-либо микроконтроллер) и остальные устройства являются
ведомыми.

На рис. \ref{fig:i2c-schematics} показана схема шины \gls{I2C}. Как можно видеть
на рисунке, шина использует всего две линии для передачи данных -- ``Serial Data
Line'' (\textbf{SDL}) и ``Serial Clock Line'' (\textbf{SCL}). Обе линии
подтянуты через резисторы \textbf{$R_p$} к напряжению питания (\textbf{Vdd}). На
схеме ``$\mu$C\\Controller'' -- это ведущее устройство, остальные же, указанные как
``Target'', являются ведомыми.

Большинство ЖК-дисплеев имеют уже припаянный к нему \gls{I2C}-модуль, либо же
подобный модуль можно купить и припаять отдельно.  Как правило основой такого
модуля выступает специальная микросхема -- \gls{I/O}-расширитель PCF8574.

Некоторые модели дисплеев изначально имеют I2C-интерфейс и отдельного модуля для
них не требуется, так как необходимая ``обвязка'' уже распаяна прямо на плате
дисплея.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \draw[draw=black] (0, 2) rectangle ++(2, 1) node[pos=.5] {%
      \begin{tabular}{c}%
        $\mu$C\\Controller%
    \end{tabular}};
    \draw[draw=black] (3, 2) rectangle ++(2, 1) node[pos=.5] {
      \begin{tabular}{c}
        ADC\\Target
    \end{tabular}};
    \draw[draw=black] (6, 2) rectangle ++(2, 1) node[pos=.5] {
      \begin{tabular}{c}
        DAC\\Target
    \end{tabular}};
    \draw[draw=black] (9, 2) rectangle ++(2, 1) node[pos=.5] {
      \begin{tabular}{c}
        $\mu$C\\Target
    \end{tabular}};

    %% Horizontal lines.
    \draw [line width=0.5mm] (0, 3.5) -- (11, 3.5) node[right] {SCL};
    \draw [line width=0.5mm] (0, 4.0) -- (11, 4.0) node[right] {SDA};
    \draw [line width=0.5mm] (0, 6.0) -- (11, 6.0) node[right] {Vdd};

    %% Vertical lines.
    \foreach \a/\b in {0.75/1.25, 3.75/4.25, 6.75/7.25, 9.75/10.25} {
      \draw [line width=0.5mm] (\a, 3) -- (\a, 4) node[circle,fill,inner sep=1.5pt]{};
      \draw [line width=0.5mm] (\b, 3) -- (\b, 3.5) node[circle,fill,inner sep=1.5pt]{};
    };

    \draw[line width=0.5mm] (5.25, 4) node[circle,fill,inner sep=1.5pt]{}
    -- (5.25, 6) node[circle,fill,inner sep=1.5pt]{};
    \draw[line width=0.5mm] (5.75, 3.5) node[circle,fill,inner sep=1.5pt]{}
    -- (5.75, 6) node[circle,fill,inner sep=1.5pt]{};

    \draw[draw=black, fill=white] (5.1, 4.5) rectangle ++(0.3, 1);
    \draw[draw=black, fill=white] (5.6, 4.5) rectangle ++(0.3, 1) node[right] {$R_p$};

  \end{tikzpicture}
  \caption{Устройство шины \gls{I2C}.}
  \label{fig:i2c-schematics}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Вывод текста}
\index{Разработка игр!Вывод текста}

\newglossaryentry{LCD}{name=LCD, description={Liquid Crystal Display --
    Жидкокристаллический дисплей}}

Согласно традиции, первая программа, которую мы выведем -- это ``Привет, Мир!''.
Однако поскольку вывод русского текста на большинстве дисплеев организован
сложнее, нежели чем латиницы, то мы будем выводить ``Hello, World!''.

Для этого нам необходимо, во-первых, установить библиотеку для работы с
дисплеем; во-вторых, настроить дисплей на нужный режим работы, и только после
этого мы сможем вывести текст.

Начнём со скачивания библиотеки.  Проще всего это сделать через менеджер
библиотек, доступный из меню ``Инструменты'' (``Tools'').  Существуют несколько
библиотек, которые могут обеспечить работу ЖК-дисплея по протокола I2C.  Мы
можем взять библиотеку ``Liquid Crystal I2C'' версии 1.1.1 под авторством Марко
Шварца (Marco Schwartz).

Установив библиотеку, мы сможем использовать её функционал.

Первым делом в коде нам необходимо подключить библиотеку
``LiquidCrystal\_I2C.h'' -- это делается через специальную команду
\texttt{\#include}.

\begin{minted}{cpp}
#include <LiquidCrystal_I2C.h>
\end{minted}

В глобальной области кода (до функции \texttt{setup} и \texttt{loop}) необходимо
создать специальную переменную, через которую мы будем работать с дисплеем. Эта
переменная отличается от того, что мы видели раннее -- в данной переменной
хранится не число, а ссылка более сложный \emph{объект}\footnote{Термин
``объект'' относится к методологии программирования, которая называется
\emph{объектно-ориентированное программирование} (сокращённо ``ООП''.)  Мы пока
не будем заострять наше внимание на теме ООП, но любознательный читатель может
получить общее представление о данной методологии, например, из соответствующей
статьи в Wikipedia.}, который располагается где-то в памяти при работе программы
внутри микроконтроллера.

Назовём переменную \texttt{lcd}, по сокращению \gls{LCD} -- ``Liquid Crystal
Display'':

\begin{minted}{cpp}
LiquidCrystal_I2C lcd(0x27,  16, 2);
\end{minted}

Далее в функции \texttt{setup} необходимо выполнить настройку дисплея.

\begin{minted}{cpp}
lcd.init();
lcd.backlight();
\end{minted}

После этого уже в функции \texttt{loop} мы можем вывести текст.  Вывод текста,
как правило, делается в два этапа: во-первых, необходимо установить место, в
которое будет ``впечатан'' текст.  Для этого существует специальная функция
\texttt{setCursor}.

\begin{minted}{cpp}
lcd.setCursor(0, 0);
\end{minted}

Первый параметр \texttt{setCursor} задаёт позицию курсора по оси X, второй
параметр задаёт позицию по оси Y.

После этого наконец-то мы можем вывести текст.

\begin{minted}{cpp}
lcd.print("Hello, World!");
\end{minted}

Полностью код будет выглядеть примерно так, как показано ниже.

\begin{minted}{cpp}
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27,  16, 2);

void setup() {
  lcd.init();
  lcd.backlight();
}

void loop() {
  lcd.setCursor(0, 0);
  lcd.print("Hello, World!");
}
\end{minted}

При необходимости очистить экран можно ``затереть'' текст, впечатав поверх
пробелы, или же воспользоваться функцией \texttt{clear}, которая позволяет
очистить экран полностью.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Задачи}
\begin{enumerate}
\item Выровняйте тест по середине дисплея.
\item Сделайте так, чтобы текст мигал.
\item Разработайте ``Бегущую строку'', где текст будет перемещаться по экрану
  справа на лево.
\end{enumerate}

\end{document}
