\documentclass[a4paper,twoside]{book}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fontspec}
\setmainfont{Liberation Serif}
\setmonofont{Liberation Mono}

\usepackage{graphicx}
\renewcommand{\thefigure}{\thesection.\arabic{figure}}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage[absolute,overlay,showboxes]{textpos}
\usepackage{etoolbox}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{lilyglyphs}
\usepackage{tabularx}
\usepackage{pgfplots}
\usepackage{circuitikz}
\usepackage{minted}
\usepackage{glossaries}

\makeglossaries

\usepackage{svg}

\urlstyle{same}
\usepackage[printonlyused,withpage]{acronym}

\graphicspath{ {images/} {../images/} }

\input{sections/commands.tex}

\usepackage{subfiles}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Автомато-программато-компарадио-кружок}
\author{Артём ``avp'' Попцов\\\href{https://memory-heap.org}{memory-heap.org}}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Вступление}
\addcontentsline{toc}{chapter}{Вступление}

\subfile{sections/introduction.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Основные принципы электротехники}

В первую очередь нам с вами надо рассмотреть базовые принципы того, как работает
электроника, чтобы впоследствии уметь собирать простые схемы.

Начнём с рассмотрения условий, которые необходимо выполнить, чтобы через
электрическую цепь шёл ток.

\subfile{sections/electronics-voltage}

\subfile{sections/electronics-circuits}

\subfile{sections/electronics-potential-difference}

\subfile{sections/electronics-resistance}

\subfile{sections/electronics-building-circuits}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Диалоги с компьютером}
\label{chapter:dialogues-with-computer}

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    %% Display.
    \node[rectangle,
      rounded corners = 0.2,
      draw = black,
      minimum width = 3cm,
      minimum height = 2cm] (r) at (1, 2) {Hello, World!};

    \node[rectangle,
      thick,
      rounded corners = 0.25cm,
      draw = black,
      minimum width = 4cm,
      minimum height = 3cm] (r) at (1.25, 2) {};

    %% Display Knobs.
    \node[circle, draw, radius = 0.1cm] (c) at (2.85, 2.0) {};
    \node[circle, draw, radius = 0.1cm] (c) at (2.85, 1.6) {};
    \node[circle, draw, radius = 0.1cm] (c) at (2.85, 1.2) {};

    %% Display Legs.
    \node[rectangle,
      thick,
      draw = black,
      minimum width = 0.2cm,
      minimum height = 0.19cm] (r) at (0, 0.38) {};

    \node[rectangle,
      thick,
      draw = black,
      minimum width = 0.2cm,
      minimum height = 0.19cm] (r) at (2.25, 0.38) {};

    %% System Case.
    \node[rectangle,
      thick,
      rounded corners = 0.25cm,
      draw = black,
      minimum width = 5.5cm,
      minimum height = 1.5cm] (r) at (0.75, -0.48) {};

    %% Floppy Drives.
    \node[rectangle,
      draw = black,
      minimum width = 2cm,
      minimum height = 1.25cm] (r) at (2.25, -0.36) {};

    \node[rectangle,
      draw = black,
      minimum width = 1.75cm,
      minimum height = 0.5cm] (r) at (2.25, -0.1) {};

    \node[rectangle,
      draw = black,
      minimum width = 1.75cm,
      minimum height = 0.5cm] (r) at (2.25, -0.6) {};

    \draw[very thick] (1.5, -0.15) -- (3, -0.15);

    \draw[very thick] (1.8, -0.6) -- (2.7, -0.6);

    %% Control buttons.
    \node[rectangle,
      draw = black,
      minimum width = 1cm,
      minimum height = 0.25cm] (r) at (-0.4, -0.25) {};

    %% Ventilation holes in the case.
    \foreach \offset in {0.1, 0.2, ..., 2.6} {
      \draw[thick] (-1.8 + \offset, -1) -- (-1.8 + \offset, -0.5);
    };

  \end{tikzpicture}
\end{figure}

\subfile{sections/dialogues-with-computer-introduction}

\subfile{sections/dialogues-with-computer-algorithms}

\subfile{sections/dialogues-with-computer-arduino}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Работа с макетной платой}

Макетная плата позволяет собирать схемы (подключать электронику) без применения
пайки --- это упрощает прототипирование и ускоряет процесс разработки проектов.
Компоненты просто вставляются в слоты на макетной плате для соединения
(см. рис. \ref{fig:breadboard-led}.)

\begin{figure}[ht]
  \centering
  \caption{Пример подключения светодиода к Arduino Mega 2560 через макетную
    плату.}
  \includegraphics[width=12cm]{schematics/001-led}
  \label{fig:breadboard-led}
\end{figure}

\begin{itemize}
\item Черный провод подключен к arduino и идёт на вывод GND (минус)
\item Синий провод подключен к arduino и идёт на вывод 5V (плюс)
\end{itemize}

\note{ Обратите внимание, что светодиоды (и некоторые другие элементы)
  подключаются к платформе Arduino через резистор -- это необходимо для
  обеспечения бесперебойной работы схемы и предупреждения всяческих поломок и
  ухудшения работы как отдельных деталей, так и схемы в целом.  }

\section{Подключение Arduino к компьютеру}
Чтобы подключить ардуино к компьютеру вам потребуется сама платформа Arduino (в
нашем случае мы используем Arduino Mega 2560) и кабель стандарта USB-В.

Соедините Arduino с компьютером через USB-кабель. Вы увидите, как на плате
загорится светодиод ``ON''.

Теперь необходимо настроить Arduino IDE для работы с подключенной Arduino, для
этого нужно войти в панель ``Инструменты'' затем ``Плата'' -- в этом меню
выберите 6Arduino с которой вы сейчас работаете, затем в подменю ``Порт''
выберите порт, к которому подключена Arduino.

\newpage
\subfile{sections/dialogues-with-computer-arduino-ide}

\subfile{sections/dialogues-with-computer-program-structure}

\subfile{sections/dialogues-with-computer-memory}

\subfile{sections/dialogues-with-computer-control-flow}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Белый шум}

\subfile{sections/white-noise-introduction}
\subfile{sections/white-noise-signal-types}
\subfile{sections/white-noise-serial-port}
\subfile{sections/white-noise-analog-ports}
\subfile{sections/white-noise-adc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Широтно-импульсная модуляция}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Общее описание принципов работы}
\newglossaryentry{ШИМ}{name=ШИМ, description={Широтно-Импульсная Модуляция}}

Широтно-импульсная модуляция, или сокращённо \emph{\gls{ШИМ}}, позволяет выдавать на
цифровом порту Arduino напряжение в диапазоне от 0 до 5 вольт, используя при
этом только два сигнала -- \texttt{HIGH} (логическая единица, при которой на
порт подается 5 В) и \texttt{LOW} (логический ноль, при котором на порт подается
0 В.) Меняя быстро данные значения на порту, можно добиться, например,
напряжения в 2.5 В.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Длина волны}

При создании ``мигающего светодиода'' мы попеременно подавали на цифровой порт
сигналы \texttt{HIGH} и \texttt{LOW}, с указанием задержки (в миллисекундах).
Если мы посмотрим на вид сигнала на цифровом порту во времени (скажем, с помощью
осциллографа), то увидим примерно следующую картину:


Где \emph{длина периода} -- расстояние между двумя ближайшими друг к другу
точками в пространстве, в которых колебания происходят в одинаковой фазе.

Зная длину периода, можно рассчитать \emph{частоту колебаний}, и наоборот --
зная частоту, можно рассчитать длину волны.

При работе с ШИМ мы будем использовать длину периода, заданную в микросекундах
(мкс). 1 микросекунда -- это одна миллионная часть секунды. Для краткости записи
подобных маленьких величин часто используется возведение числа 10 в
отрицательную степень. Ниже приведена таблица с указанием различных долей
секунды\footnote{Для полного списка кратных и дольных единиц см. статью
\href{https://ru.wikipedia.org/wiki/\%D0\%A1\%D0\%B5\%D0\%BA\%D1\%83\%D0\%BD\%D0\%B4\%D0\%B0}{Секунда}
в Википедии.}:

\begin{tabular}{p{4cm}|p{4cm}|p{6cm}}
  Название & Величина & Пример \\
  \hline \hline
  секунда (с) & $ 1 с $ или $ 10^0 с $ & $ 500 * 10^{0} = 500 с $ \\
  \hline
  миллисекунда (мс) & $ 0.001 c $ или $ 10^{-3} c $ & $ 500 * 10^{-3} = 500 мс $ \\
  \hline
  микросекунда (мкс) & $ 0.000001 c $ или $ 10^{-6} c $ & $ 500 * 10^{-6} = 500 мкс $ \\
  \hline
  наносекунда (нс) & $ 0.000000001 c $ или $ 10^{-9} с $ & $ 500 * 10^{-9} = 500 нс $
\end{tabular}

\section{Коэффициент заполнения}

Каким образом задается напряжение из диапазона? Очень просто: путём изменения
времени подачи того или иного сигнала. Чем больше времени на порту сигнал HIGH,
тем выше напряжение. При этом, длина периода \texttt{P} остаётся фиксированной
(например, 1000 микросекунд). Таким образом для \gls{ШИМ} важно процентное
отношение одного сигнала к другому, и, увеличивая время подачи одного сигнала,
следует уменьшать время подачи другого (следовательно если мы подаем сигнал
\texttt{HIGH} 60\% от отведенного времени, нужно заполнить оставшиеся 40\%
сигналом \texttt{LOW}).

Отношение периода следования сигнала к длительности импульса называется
\emph{скважностью}. В англоязычной литературе величина, обратная скважности,
называется \emph{коэффициентом заполнения} (англ. \emph{duty cycle}).

Мы будем использовать термин ``коэффициент заполнения''.

\example {
  Мы хотим получить 2.5 вольта на цифровом порту 2, имея в
  распоряжении только два значения -- 0 В и 5 В. Для этого нам потребуется
  реализовать ШИМ с коэффициентом заполнения 50\%. При длине волны в 1000
  микросекунд мы должны половину времени (500 микросекунд) заполнить
  положительным сигналом (сигнал \texttt{HIGH}) и подать его на выбранный порт, затем
  остальную часть заполним отрицательным сигналом (сигналом \texttt{LOW}).
  Если всё сделано правильно, то на 2 цифровом порту получим 2.5 вольта.
}

Для генерации нужного сигнала нам потребуется создать инструмент
(\emph{функцию}), который впоследствии мы будем использовать. Мы уже говорили о
важности написания и использования собственных функций в программе -- функции
позволяют нам создавать модульные программы, упрощают поддержку существующего
программного кода и написание нового кода.

Подумаем над тем, какой должна быть наша функция, реализующая ШИМ. Ниже приведён
знакомый нам график, отображающий сигнал на цифровом порту -- мы будем
использовать этот график, как основу для написания функции.

%% TODO: Add the graph.

В программе мы обозначим длину периода константой \texttt{P}, равной 1000 мкс.
Значения задержек, заданных переменными \texttt{d1} и \texttt{d2}, необходимо
вычислить на основе коэффициента заполнения, задаваемого параметром функции
\texttt{duty\_cycle} (который задаётся дробным значением -- к примеру, 0.5.)

Имея перед глазами этот график, нетрудно набросать словесное описание функции
(назовём функцию \texttt{pwm}, как сокращение от англ. \emph{pulse width
  modulation}.)

Начнём с того, что, скорее всего, подобная функция должна принимать три
параметра:
\begin{enumerate}
\item Номер порта (обозначаемый целым числом), на котором следует сгенерировать
  ШИМ сигнал; назовём этот параметр \texttt{pin}.
\item Коэффициент заполнения, заданный дробным числом -- к примеру, 50\% будет
  задано, как 0.5; назовём этот параметр \texttt{duty\_cycle}
\item Длина ШИМ сигнала в микросекундах; назовём этот параметр
  \texttt{signal\_length}.
\end{enumerate}

Запишем тоже самое на языке С++:

\begin{minted}{cpp}
void pwm(int pin, float dc, long signal_length) {
  // тело функции
}
\end{minted}

О том, что такое \texttt{void}, будет сказано позже, пока что стоит принять как
факт, что это начало объявления функции. Наверняка появились вопросы по новым
типам переменных -- \texttt{float} и \texttt{long}. Почему нельзя использовать
привычный \texttt{int}? Дело в том, что переменная типа \texttt{int} не может
хранить дробные числа, а также имеет диапазон значений от -32 768 до 32 767. Для
хранения дробных чисел используется \texttt{float}, а для чисел, не входящих в
диапазон \texttt{int}, стоит использовать \texttt{long}, имеющий диапазон от -2
147 483 648 до 2 147 483 647. Теперь подумаем над телом функции. Первым делом
нам необходимо задать константу \texttt{P}:

\begin{minted}{cpp}
const int P = 1000; // мкс
\end{minted}

Обратите внимание, что мы используем ключевое слово const для того, чтобы
пометить \texttt{WAVE\_LENGTH}, как константу -- мы всё равно не собираемся
менять это значение. Кроме того, мы указали в комментарии, что значение задано в
микросекундах (мкс), что упрощает чтение кода. В C++, да и в других языках,
константа -- это та же переменная, но её значение нельзя менять после её
объявления.

Следующим этапом будет вычисление в теле функции значений переменных \texttt{d1}
и \texttt{d2} на основе значения \texttt{duty\_cycle}, заданного при вызове
функции:

\begin{minted}{cpp}
int d1 = P * duty_cycle;
int d2 = P - d1;
\end{minted}

Видно, что как только мы вычислили \texttt{d1}, вычислить \texttt{d2} не
составляет труда. Осталось только посчитать, сколько раз нужно повторить волну
длиной \texttt{P}, чтобы сгенерировать сигнал длиной \texttt{signal\_length}:

\begin{minted}{cpp}
int count = signal_length / P;
\end{minted}

Теперь у нас есть всё, что нужно для генерации нужного нам сигнала. Поскольку
исходя из описания выше нам нужно будет повторять волну count раз, то для этого
удобно использовать цикл \texttt{for} (цикл со счётчиком):

\begin{minted}{cpp}
for (int c = 0; c < count; c++) {
  digitalWrite(pin, HIGH);
  delayMicroseconds(d1);
  digitalWrite(pin, LOW);
  delayMicroseconds(d2);
}
\end{minted}

Готово! Осталось только задействовать функцию pwm в нашей программе.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Задачи}

\begin{enumerate}
\item Написать программу, плавно включающую и выключающую светодиод. Собрать и
  протестировать схему. 
\item Написать программу, реализующую ``бегущий огонь'' с использованием ШИМ.
  Собрать и протестировать схему.
\item Используя потенциометр, модифицировать систему из задания №2 таким
  образом, чтобы можно было регулировать яркость ``бегущего огня''.
\item Разработать ``бегущий огонь'', где следующий светодиод начинает плавно
  разгораться одновременно с затуханием предыдущего светодиода.
\end{enumerate}

%% \section{Последовательный порт}

%% \subsection{Сбор и обработка данных на стороне компьютера}

%% Другой задачей, решаемой с помощью функций записи данных в последовательный
%% порт, является сбор данных на стороне компьютера. Arduino IDE позволяет нам
%% визуализировать данные через специальный плоттер (доступ к которому можно
%% получить, выбрав в меню ``Инструменты'' пункт ``Плоттер по последовательному
%% соединению'', либо нажав комбинацию клавиш \hotkey{Ctrl + Shift + L}.)

%% \subsection{Передача данных с компьютера на Arduino}

%% Передавать данные с Arduino на компьютер мы уже научились. Теперь посмотрим на
%% передачу данных в обратном направлении. Для того чтобы передать данные с
%% компьютера на Arduino также необходимо выполнить настройку последовательного
%% порта; кроме этого, нам потребуется задействовать несколько новых функций.

%% \subsubsection{Чтение отдельных байт}

%% Функция \texttt{Serial.read} читает байт данных из поступивших на Arduino. То
%% есть возвращает вам некое целое число, с которым вы вольны делать что вашей душе
%% угодно. Каждый вызов этого метода будет возвращать вам следующий байт данных из
%% тех что поступили на Arduino. Если возвращать нечего, то есть вы считали все что
%% было, данная функция вернет -1.

%% \note{ Если передаются именно байты, возникает проблема: -1 это 0xFF в
%%   шестнадцатиричной системе, или 255 в десятичной. Такой же байт, как и все
%%   остальные, из-за чего невозможно. поэтому нужно сперва вызывать функцию available . }

%% Допустим мы отправили 1 байт данных на Arduino и использовали нижеприведенный
%% участок кода:

%% \begin{verbatim}
%% int incoming_byte;
%% void loop() {
%%   if (Serial.available() > 0) {
%%       incoming_byte = Serial.read();
%%   }
%% }
%% \end{verbatim}

%% После того, как вы считаете байт данных, он будет перемещен в вашу переменную
%% \texttt{incoming\_byte} а функция \texttt{Serial.available} снова будет
%% возвращать 0, пока не поступят новые данные.

%% То есть, когда вы считываете байт, показания счетчика принятых байт уменьшается
%% и \texttt{Serial.available} будет показывать на 1 байт меньше.

%% Помните, что функция \texttt{Serial.read} возвращает только 1 байт данных, если
%% например вы передали 4 символа каждый по 1 байту, вам потребуется 4 раза вызвать
%% данную функцию чтобы прочитать эти символы и самостоятельно позаботится о том
%% чтобы разместить их в массив символов либо воспользоваться функцией
%% \texttt{Serial.readBytes}.

%% \subsubsection{Чтение чисел}

%% Функция \texttt{Serial.parseInt} просматривает данные, поступившие на Arduino, и
%% ищет среди них набор кодов (чисел) от 48 до 57, которые соответствуют символам
%% чисел от 0 до 9 и преобразует все это в правильное целочисленное значение. Таким
%% образом если вы с монитора порта передадите "число" (на самом деле, строку)
%% ``72'', данный метод увидит 2 последовательных байта 55 и 51, корректно
%% преобразует его в число 72 и вернет его как правильное целочисленное значение.
%% Давайте напишем маленькую эхо-программу, которая покажет принцип работы данной
%% функции и позволит вам узнать какому символу соответствует то или иное число.

%% \begin{verbatim}
%% int incoming_int = 0;

%% void setup()
%% {
%%   Serial.begin(9600);
%%   Serial.setTimeout(2000);
%% }
%% void loop()
%% {
%%   if (Serial.available() > 0)
%%   {
%%     incoming_int = Serial.parseInt();
%%     Serial.write(incoming_int);
%%   }
%% }
%% \end{verbatim}

%% Данная программа будет работать так. Если в мониторе порта вы введете строку
%% ``72'' то монитор порта отправит его на Arduino как два байта данных в виде
%% чисел 55 и 51, функция \texttt{Serial.parseInt} подождет 2000 миллисекунд (как
%% видите я поменял время ожидание с 1 секунды на 2 секунды, чтобы нагляднее
%% показать кое какие аспекты) увидит эти два значения и преобразует их в одно
%% целочисленное 72 и присвоит его переменной \texttt{incoming\_int}, мы с помощью
%% метода \texttt{Serial.write} передадим число 72 как есть обратно в монитор порта
%% (почему именно этот метод нужен читайте далее) где монитор порта корректно
%% преобразует число 72 в соответствующий символ и покажет нам символ ``H'' который
%% соответствует коду 72. Таким образом мы можем передавать числовые значения с
%% компьютера на платформу Arduino и дальше использовать эти значения.

\chapter{Синтез музыки и технологии}

\section{Звук}
\newglossaryentry{Гц}{name=Гц, description={Герц}}
\newglossaryentry{КГц}{name=КГц, description={Килогерц ($10^3$ Гц)}}
\newglossaryentry{МГц}{name=МГц, description={Мегагерц ($10^6$ Гц)}}
\newglossaryentry{ГГц}{name=ГГц, description={Гигагерц ($10^9$ Гц)}}


Как известно \emph{звук} -- это колебания (вид сигнала), и каждому определённому
звуку соответствует своя частота колебаний.

Частоты измеряются в \emph{Герцах} (\gls{Гц}), и один Герц (1 Гц) означает одно
колебание в секунду. 10 колебаний в секунду -- 10 Гц, 100 колебаний в секунду --
100 Гц и т. д. Если же мы говорим про частоты в 100 Гц и более, то удобнее
использовать приставки Кило- (\gls{КГц}), Мега- (\gls{МГц}) и Гига- (\gls{ГГц}):
сигнал с частотой 1 КГц поданный на цифровой порт колеблет мембрану динамика
1000 раз в секунду.  Ниже приведена таблица некоторых кратных единиц частот в
Герцах:

\begin{tabular}{p{3cm}|p{4cm}|p{3.5cm}}
  Название & Величина & Пример \\
  \hline \hline
  Герц (Гц)
  & $ 1 \mbox{Гц} $ или $ 10^0 \mbox{Гц} $
  & $ 100 * 10^0 \mbox{Гц} = 100 \mbox{Гц} $ \\
  \hline
  Килогерц (КГц)
  & $ 1000 \mbox{Гц} $ или $ 10^3 \mbox{Гц} $
  & $ 100 * 10^3 \mbox{Гц} = 1 \mbox{КГц} $ \\
  \hline
  Мегагерц (МГц)
  & $ 1000000 \mbox{Гц} $ или $ 10^6 \mbox{Гц} $
  & $ 100 * 10^6 \mbox{Гц} = 1 \mbox{МГц} $ \\
  \hline
  Гигагерц (ГГц)
  & $ 1000000000 \mbox{Гц} $ или $ 10^9 \mbox{Гц} $
  & $ 100 * 10^9 \mbox{Гц} = 1 \mbox{ГГц} $ \\
\end{tabular}

Таким образом, для генерации сигнала нам необходимо знать его частоту в Герцах,
либо знать длину волны.

Зная период, мы можем узнать частоту, и наоборот -- поскольку частота является
ничем иным, как количеством повторений заданных колебаний в секунду. Это удобно
представить визуально (\ref{fig:sound-fig-1}.)

\begin{figure}[h]
  \caption{Визуальное представление частоты колебаний 5 Гц.}
  \label{fig:sound-fig-1}
  \includegraphics[width=10cm]{sound-fig-1}
  \centering
\end{figure}

Если известно, что колебание А помещается 5 раз в 1 секунду, то говорят, что
частота данного сигнала равна 5 Гц. Узнать период можно, разделив 1 секунду
(заданную в микросекундах) на частоту (5 Гц):

\begin{equation}
  \frac{1000000 \mbox{мкс}}{5 \mbox{Гц}} = 200000 \mbox{мкс}
\end{equation}

Получается, что длина волны равна 200000 мкс, или $ 200 * 10^3 \mbox{мс} $. Если
же нам известна длина волны и нужно узнать частоту, то необходимо разделить 1
секунду (в микросекундах) на длину волны -- таким образом, получим частоту в
Герцах. Всё просто.

Метод генерации звука похож на \gls{ШИМ}. Основные отличия заключаются в том,
что теперь мы должны изменять длину волны \texttt{len}, оставляя коэффициент
заполнения неизменным -- он описывается константой \texttt{DC} и всегда равен
0.5. Поскольку коэффициент заполнения всегда равен 50\% (0.5), то время подачи
сигналов \texttt{HIGH} и \texttt{LOW} всегда одинаково -- иными словами, нам
достаточно вычислить только задержку \texttt{d1}. Это показано на графике ниже:

Как и в случае с ШИМ, начнём писать функцию, которая будет реализовывать
вышеописанные принципы. Функция будет называться \texttt{play\_tone} и будет
позволять генерировать звук с нужной частотой на указанном цифровом порту.

Посмотрим, что данная функция должна принимать в качестве параметров:
\begin{enumerate}
\item Номер цифрового порта, к которому подключен динамик и куда будет
  выводиться звук; назовём этот параметр ``pin'';
\item Частота ``f'', измеряемая в Герцах. 
\item Длина звукового сигнала; назовём этот параметр ``t''.
\end{enumerate}

На языке C++ это будет выглядеть примерно так:
\begin{minted}{cpp}
void play_tone(int pin, float f, long t) {
    // тело функции
}
\end{minted}

Теперь пришло время написать тело функции. Начнём с того, что зададим
коэффициент заполнения в виде константы:
\begin{minted}{cpp}
const float DC = 0.5; // 50%
\end{minted}

Теперь из частоты найдём период \texttt{p}:
\begin{minted}{cpp}
long p = 1000000 / f;
\end{minted}

Далее посчитаем длину задержки \texttt{d}:
\begin{minted}{cpp}
int d = p * DC;
\end{minted}

И посчитаем, сколько раз нам нужно повторить период длиной \texttt{p}
микросекунд, чтобы заполнить время \texttt{t}:
\begin{minted}{cpp}
int count = t / p;
\end{minted}

Почти всё готово. Осталось только написать цикл, который будет генерировать
заданную волну нужное количество раз. Здесь отлично подойдёт цикл со счётчиком
(\texttt{for}):

\begin{minted}{cpp}
for (int c = 0; c < count; c++) {
  digitalWrite(pin, HIGH);
  delayMicroseconds(d);
  digitalWrite(pin, LOW);
  delayMicroseconds(d);
}
\end{minted}

В общем виде, функция выглядит так:

\begin{minted}{cpp}
void play_tone(int port, float f, long t) {
  const int T = 1000000 / f;
  int d = T / 2;
  int count = t / T;
  for (int i = 0; i < count; i++) {
    digitalWrite(port, HIGH);
    delayMicroseconds(d);
    digitalWrite(port, LOW);
    delayMicroseconds(d);
  }
}
\end{minted}

Наша функция генерации звука завершена. Теперь нам нужно подключить динамик к
Arduino и протестировать нашу систему.

\note{Во многих случаях одна и та же задача может быть решена несколькими
  способами. К примеру, функция \texttt{play\_tone} может быть реализована
  иначе; предложенная нами реализация является только одной из корректных. Как
  вариант, вы можете реализовать вариант функции, которая оперирует не длиной
  волны, а частотой. Подумайте над этим в свободное время. И не бойтесь
  экспериментировать! }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Подключение динамика}

Есть несколько вариантов динамиков, которые вы можете встретить. Например, есть
обычные динамики, где мембрана колеблется магнитным полем и тем самым создаёт
колебания воздуха, которые мы слышим, как звук. Есть пьезодинамики, в которых
звук генерируется за счёт обратного пьезоэлектрического эффекта -- механической
деформации пьезоэлектрика под действием электрического поля.\footnote{См. статью
``Пьезоэлектрический эффект'' в Википедии для более подробного описания эффекта.}

Подключение и обычных динамиков и пьезодинамиков похоже; для наших задач
подойдёт как пьезодинамик ``для Arduino'', так и обычный динамик-пищалка из
персонального компьютера (а вы знали, что у вас в компьютере к системной плате
подключен динамик?)

Схема подключения представлена на рис. \ref{fig:sound-fig-2}.

%% TODO: Перерисовать схему.  Убрать резистор.
\begin{figure}[h]
  \caption{Подключение динамика-''пищалки'' к Arduino Mega 2560.}
  \label{fig:sound-fig-2}
  \includegraphics[width=10cm]{sound-fig-2}
  \centering
\end{figure}

Соберём указанную схему на макетной плате, и загрузим нашу программу генерации
звука в Arduino. Не забудьте добавить в тело функции \texttt{loop} вызов нашей
функции \texttt{play\_tone} и настроить цифровой порт, к которому подключен
динамик, на вывод.

Порт, к которому подключен динамик, лучше задать в виде константы
\texttt{SPEAKER\_PIN} в самом начале программы (до функции \texttt{setup}.)

\subsection{Задачи}
\begin{enumerate}
\item Сгенерируйте постоянный сигнал с частотой 261.63 Гц.
\item Сделайте так, чтобы сигнал менялся между 261.63 Гц и 349.23 Гц с частотой
  в 1 секунду. 
\item Модифицируйте систему таким образом, чтобы частота сигнала зависела от
  положения ручки потенциометра. 
\item Сделайте включение звукового сигнала по нажатию кнопки.
\end{enumerate}

Теперь мы можем генерировать звуковой сигнал с нужной нам частотой. Однако, если
мы хотим сгенерировать что-нибудь интересное -- вроде мелодии -- то нам
потребуется использовать вполне определённые частоты. Здесь нам очень кстати
будет хотя бы начальное знание музыкальной теории, но если таких знаний нет --
не беда, разберём по ходу дела.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Теория ритма}

Наш путь в музыку начнётся с разбора теории построения \emph{ритмов}. Думаю,
большинство из нас представляют, что такое ритм -- у многих именно он вызывает
например рефлекс покачивания головой в такт, или машинальное отстукивание ритма
на столешница стола, когда думаем над чем-то.

Чтобы понять, как строится ритм, необходимо знать две простые вещи, о которых мы
сейчас поговорим.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Понятие \emph{такта}}

Во-первых, музыкальное произведение делится на отрезки времени, называемые
\emph{тактами} -- как правило одинаковой длительности.\footnote{Музыка отличается
большим разнообразием, и композиторы придумывают всё новые трюки, как получить
желаемое впечатление у слушателя, поэтому здесь мы говорим с некоторыми
допущениями.}

На рисунке ниже показано, как может выглядеть музыкальная композиция из шести
тактов:

\begin{tikzpicture}
  \draw[thick, ->] (0, 0.5) -- (12, 0.5) node[anchor=north west] {t};
  \foreach \x/\n in {0/1, 2/2, 4/3, 6/4, 8/5, 10/6} {
    \draw (\x, 0) -- (\x, 1) -- (\x, 1) node[midway, above] {\n};
  };
\end{tikzpicture}

Протяжённость одного такта во времени определяется быстротой ритма, и про это мы
поговорим позже. Пока можно представить, что один отрезок занимает одну условную
единицу времени. Можете принять эту условую единицу за отрезок времени, удобный
для вашего восприятия -- например, одну секунду.

Во-вторых, эти такты делятся на ещё на более мелкие части, по которым, как по
``ячейкам'', раскладываются различные звуки. Достаточно большая часть музыки
пронизана математикой, и первое математическое, с чем мы столкнёмся -- это
простые дроби. Одним из популярных способов деления такта на части является
$\frac{4}{4}$ или, по-другому называемый ``четыре четверти''. В таком способе
деления такта в него умещается ровно единица некоторого условного времени, про
которое мы говорили выше.\footnote{Существуют более сложные способы деления
такта на части, которые дают суммарное значение меньше или больше единицы -- про
это мы поговорим позднее.}

Если мы поделим каждый такт на четыре части, то получим следующую картину:

\begin{tikzpicture}
  \draw[thick, ->] (0, 0.5) -- (12, 0.5) node[anchor=north west] {t};
  \foreach \x/\n in {0/1, 2/2, 4/3, 6/4, 8/5, 10/6} {
    \draw (\x, 0) -- (\x, 1) -- (\x, 1) node[midway, above] {\n};
  };

  \foreach \x/\n in {0, 0.5, ..., 10} {
    \draw (\x, 0) -- (\x, 0.5);
  };
\end{tikzpicture}

Возьмём отдельный такт и посмотрим на него внимательно:

\begin{tikzpicture}
  \draw[thick] (0, 0.5) -- (8, 0.5) node[anchor=north west] {t};
  \foreach \x/\n in {0/1, 8/2} {
    \draw (\x, 0) -- (\x, 1)  -- (\x, 1) node[midway, above] {\n};
  };

  \foreach \x in {0, 2, ..., 6} {
    \draw (\x, 0) -- (\x, 0.5) node[pos=0.25, right] {$ \frac{1}{4} $};
  };
\end{tikzpicture}

Если просуммируем все части, то снова получим единицу:

\begin{equation}
  \frac{1}{4} + \frac{1}{4} + \frac{1}{4} + \frac{1}{4} = \frac{1}{1}
\end{equation}

На каждую из четвертей можно задать какой-то звук -- пока нам не важно, насколько
он будет музыкальный. Допустим, что три четверти будут звучать с частотой 50Гц,
и одна часть -- с частотой 100Гц:

\begin{tikzpicture}
  \draw[thick] (0, 0.5) -- (8, 0.5) node[anchor=north west] {t};
  \foreach \x/\n in {0/1, 8/2} {
    \draw (\x, 0) -- (\x, 1) -- (\x, 1) node[midway, above] {\n};
  };

  \foreach \x in {0, 2, ..., 6} {
    \draw (\x, 0) -- (\x, 0.5) node[pos=0.25, right] {$ \frac{1}{4} $};
  };

  \foreach \x/\freq in {0/50, 2/50, 4/50, 6/100} {
    \draw (\x, 0) -- (\x, 0.5) node[pos=1.5, right] {\freq Гц};
  };
\end{tikzpicture}

Поздравляю -- мы только что получили с простой ритм. Попробуем запрограммировать
его, беря за длину такта \texttt{T} одну секунду, или 1000000 (миллион)
микросекунд.

Между ``ударами'' необходимо поставить короткую задержку (например, в 100 мс),
чтобы удары одинаковой частоты, идущие один за другим, не сливались в один
долгий звук.

\begin{minted}{cpp}
// Номер порта, куда подключен динамик.
const int SPEAKER = 2;

void setup() {
  pinMode(SPEAKER, OUTPUT);
}

// Функция воспроизведения звука указанной частоты.
void play_tone(int port, float f, long t) {
  const int T = 1000000 / f;
  int d = T / 2;
  int count = t / T;
  for (int i = 0; i < count; i++) {
    digitalWrite(port, HIGH);
    delayMicroseconds(d);
    digitalWrite(port, LOW);
    delayMicroseconds(d);
  }
}

void loop() {
  const long T = 1000000; // Длина такта в микросекундах
  play_tone(SPEAKER, 50, T / 4); // Четверть
  delay(100); // Задержка между звуками
  play_tone(SPEAKER, 50, T / 4); // Четверть
  delay(100);
  play_tone(SPEAKER, 50, T / 4); // Четверть
  delay(100);
  play_tone(SPEAKER, 100, T / 2); // Половина
  delay(100);
}
\end{minted}

Можно теперь взять что-то посложнее.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Более сложные ритмы}

Возможно некотыре из вас знают такую зажигательную композицию, как ``We Will
Rock You'' в исполнении группы Queen\footnote{Официальное музыкальное видео на
данную композицию можно посмотреть здесь:
\url{https://www.youtube.com/watch?v=-tJYN-eG1zk}}. Данная композиция имеет
чётко выраженный, легко узнаваемый ритм, который можно упрощенно описать как
``два притопа, один прихлоп'', вокруг которого строится вся композиция -- вы сами
можете достаточно легко повторить этот ритм, коротко топая ногой два раза, и
потом делая ``долгий'' хлопок руками.

Структура этого ритма может быть описана следующим набором простых дробей
(\ref{fig:queen-we-will-rock-you-rhythm-1}.) Частоты звуков мы опять же берём
произвольно.

\begin{figure}[ht]
  \label{fig:queen-we-will-rock-you-rhythm-1}
  \caption{Ритм мелодии ``We Will Rock You''}
  \begin{tikzpicture}
    \draw[thick] (0, 0.5) -- (8, 0.5) node[anchor=north west] {t};
    \foreach \x/\n in {0/1, 8/2} {
      \draw (\x, 0) -- (\x, 1) -- (\x, 1) node[midway, above] {\n};
    };

    \foreach \x in {0, 2} {
      \draw (\x, 0) -- (\x, 0.5) node[pos=0.25, right] {$ \frac{1}{4} $};
    };

    \draw (4, 0) -- (4, 0.5) node[pos=0.25, right] {$ \frac{1}{2} $};

    \foreach \x/\freq in {0/50, 2/50} {
      \draw (\x, 0) -- (\x, 0.5) node[pos=1.5, right] {\freq Гц};
    };
    \draw (4, 0) -- (4, 0.5) node[pos=1.5, right] {100 Гц};
  \end{tikzpicture}
\end{figure}

Как мы видимо из рисунка \ref{fig:queen-we-will-rock-you-rhythm-1}, деление
такта на части не обязательно должно быть всегда равномерным -- здесь мы получили
две четверти, и одну половину. Суммарно же у нас опять выходит единица (см.
формулу \ref{equation:queen-we-will-rock-you-rhythm-1}.) Попутно вспоминаем, что
для сложения простых дробей нам необходимо их привести к общему знаменателю.

\begin{equation}
  \label{equation:queen-we-will-rock-you-rhythm-1}
  \frac{1}{4} + \frac{1}{4} + \frac{1}{2} = \frac{1}{4} + \frac{1}{4} + \frac{2}{4} = \frac{4}{4} = \frac{1}{1} = 1
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Музыкальная запись ритма}

С точки зрения музыкальной нотации, данный ритм можно записать примерно
следующим образом (см. рисунок \ref{fig:lilypond-queen-1}.)

\begin{figure}[ht]
  \caption{Ритм мелодии ``We Will Rock You'' в музыкальной нотации (упрощенная версия.)}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      e,4 e4 e'2
    }
  \end{lilypond}
  \label{fig:lilypond-queen-1}
\end{figure}

Если вы не знакомы с музыкальной нотацией (т.е. способом записи музыки), и
изображение выглядит для вас совершенно непонятно, то не отчаивайтесь -- на
данном этапе нам достаточно увидеть, что есть три ``закорючки'', которые
обозначают звуки разной длительности: ``\quarterNote'' ($\frac{1}{4}$),
``\quarterNote'' ($\frac{1}{4}$) и ``\halfNote'' ($\frac{1}{2}$).

Расположение ``закорючек'' слева направо говорит нам о порядке ``извлечения''
звуков из музыкальных инстнументов, а каждый вид начертания ``закорючки''
соответствует длительности звука, согласно следующей таблице
(\ref{table:music-notes-legths}.)

\begin{table}[ht]
  \caption{Некоторые возможные длительности нот.}
\begin{tabular}{p{3cm}|p{4cm}|p{3.5cm}}
  Начертание & Длительность & Название \\
  \hline \hline
  \wholeNote     & $\frac{1}{1}$ & ``Целая'' \\
  \hline
  \halfNote      & $\frac{1}{2}$ & ``Половина'' \\
  \hline
  \quarterNote   & $\frac{1}{4}$ & ``Четверть'' \\
  \hline
  \eighthNote     & $\frac{1}{8}$ & ``Восьмая'' \\
  \hline
  \sixteenthNote & $\frac{1}{16}$ & ``Шестнадцатая'' \\
  \hline
\end{tabular}
\label{table:music-notes-legths}
\end{table}

Существуют и более длинные и более короткие ноты, но они встречаются реже, чем
перечисленные в таблице \ref{table:music-notes-legths}, поэтому для краткости мы
их рассматривать не будем.

Какие выводы мы можем сделать в итоге? Что в музыкальной нотации звуки, которые
необходимо ``извлечь'' из музыкального инструмента, записываются слева на право,
как и обычный, привычный нам русский текст (или английский, к слову говоря.)

Мы можем расположить музыкальную запись для удобства нашего понимания на
графике, где ось $\mbox{X}$, будет обозначать время, идущее слева направо:

\begin{figure}[ht]
  \caption{Музыкальный ``график''.}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      e,4 e4 e'2
    }
  \end{lilypond}
  \begin{tikzpicture}
    \draw[thick, ->] (0, 0.5) -- (12, 0.5) node[anchor=north east] {Время};
  \end{tikzpicture}

  \label{fig:lilypond-queen-1}
\end{figure}

С точки зрения программирования, код воспроизведения ритма может быть следующим:

\begin{minted}{cpp}
// Здесь пропущен уже известный вам код настройки системы и реализации
// функции воспроизведения звука.

void loop() {
  const long T = 1000000; // Длина такта в микросекундах
  play_tone(SPEAKER, 50, T / 4); // Четверть
  delay(100);
  play_tone(SPEAKER, 50, T / 4); // Четверть
  delay(100);
  play_tone(SPEAKER, 100, T / 2); // Половина
  delay(100);
}
\end{minted}

Теперь нам нужно более точно определить, какова длительность целого отрезка
времени, чтобы посчитать длину его частей.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Темп музыки}
\newglossaryentry{BPM}{name=BPM, description={Beats Per Minute -- удары в минуту}}

\emph{Темпом} в музыке скорость исполнения музыки, если говорить упрощенно. В
современной музыке темп измеряется в \emph{ударах в минуту} (буквальный перевод
английского ``Beats per Minute'', сокращённо называемый \emph{\gls{BPM}}.)

Темп в музыке может задаваться с помощью специального маятника, который
раскачивается из стороны в сторону с равномерной скоростью, делая удары (или
щелчки) в крайних положениях. Такой маятник называется \emph{метрономом}.

\begin{figure}[h]
  \caption{Схематическое изображение механического метронома (источник:
    \url{https://commons.wikimedia.org/wiki/File:Metronome_(PSF).png}).}
  \label{fig:sound-metronome}
  \includegraphics[width=10cm]{Metronome}
  \centering
\end{figure}

В современном мире роль механического маятника часто заменяет специальное
компактное электронное устройство или даже приложение для мобельного телефона,
издающее щелчки через равные промежутки времени с заданной скоростью.

Чем больше ударов в минуту, тем выше темп -- и выше скорость ритма. Примерами BPM
могут служить 60, 80 и 100 ударов в минуту.

Но как связать скорость ритма с делением такта на части? Оказывается,
равномерные удары метронома задают длину одной четверти ($\frac{1}{4}$), на
которые у нас в примерах выше делился такт.

Таким образом, если темп ритма задан в 100 ударов в минуту, то это значит, что в
минуту помещается ровно 100 четвертей.

\begin{tikzpicture}
  \draw[thick] (0, 0.5) -- (10, 0.5) node[anchor=north west] {t};
  \draw (0, -0.5) -- (0, 1.5);
  \draw (10, -0.5) -- (10, 1.5);
  \draw (1, 1.5) node[anchor=north west] {1 минута (60 секунд) / 100 ударов};
  \foreach \x in {0.0, 0.1, 0.2, ..., 10.0} {
    \draw (\x, 0) -- (\x, 1);
  };
\end{tikzpicture}

Расстояние между двумя ударами можно рассчитать по формуле \ref{equation:bpm}.

\begin{equation}
  \label{equation:bpm}
  \frac{\mbox{60 с}}{\mbox{100 ударов}} = \mbox{0.6 с} = \mbox{60 мс} = \mbox{60000 мкс}
\end{equation}

Исходя из формулы \ref{equation:bpm} мы получаем длительность одной четверти в
0.6с. Но для удобства рассчётов мы должны посчитать длину целого такта, а не его
части. Поскольку в такт, который мы рассматриваем в примере, помещается четыре
четверти, для нахождения целого достаточно умножить четверть на четыре (см.
формулу \ref{equation:whole-note-calcualtion-1}).

\begin{equation}
  \label{equation:whole-note-calcualtion-1}
  \frac{1}{4} * 4 = \frac{4}{4} = \frac{1}{1} = 1
\end{equation}

Зная это, можно вывести общую формулу \ref{equation:whole-note-calcualtion-2}
для вычисления длительности целого такта.

\begin{equation}
  \label{equation:whole-note-calcualtion-2}
  \frac{\mbox{60 c}}{\mbox{BPM}} * 4 = \mbox{Длина целого такта}
\end{equation}

Теперь мы можем музыкально точно рассчитать длину звуков, из которых строится
ритм произведения -- в том числе, композиции ``We Will Rock You'', которую мы
рассматривали выше. Для неё BPM равен примерно 80 ударов в минуту.\footnote{В
разных источниках могут быть указаны разные варианты BPM, но в целом темп этой
композиции обычно находится в диапазоне от 84 до 88 ударов в минуту.}

Попробуем запрограммировать его.

\begin{minted}{cpp}
// Номер порта, куда подключен динамик.
const int SPEAKER = 2;

void setup() {
  pinMode(SPEAKER, OUTPUT);
}

// Функция воспроизведения звука указанной частоты.
void play_tone(int port, float f, long t) {
  const int T = 1000000 / f;
  int d = T / 2;
  int count = t / T;
  for (int i = 0; i < count; i++) {
    digitalWrite(port, HIGH);
    delayMicroseconds(d);
    digitalWrite(port, LOW);
    delayMicroseconds(d);
  }
}

void loop() {
  const int BPM = 80; // Удары в минуту

  // Одна минута в микросекундах
  const long MINUTE = 60000000;

  // Длина целого такта в микросекундах
  const long T = (MINUTE / BPM) * 4;

  play_tone(SPEAKER, 50, T / 4); // Четверть
  delay(100);
  play_tone(SPEAKER, 50, T / 4); // Четверть
  delay(100);
  play_tone(SPEAKER, 100, T / 2); // Половина
  delay(100);
}
\end{minted}

Если вы загрузите данный проект в Arduino, то обнаружите, что ритм получился
слишком медленный и не совпадает с темпом оригинальной композиции. Так произошло
потому, что мы не учли один важный момент -- в такте должно быть две группы ``два
притопа, один прихлоп'' (см. рисунок \ref{fig:lilypond-queen-2}.)

\begin{figure}[ht]
  \caption{Ритм мелодии ``We Will Rock You'' в музыкальной нотации (полная версия.)}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      e,8 e8 e'4 e,8 e8 e'4
    }
  \end{lilypond}
  \label{fig:lilypond-queen-2}
\end{figure}

Из-за этого в оригинале композиция кажется в два раза быстрее -- не потому, что
там выше BPM, а просто по тому, что сами ноты короче.

Адаптируем наш код соответствующим образом.

\begin{minted}{cpp}
// ...

void loop() {
  const int BPM = 80; // Удары в минуту

  // Одна минута в микросекундах
  const long MINUTE = 60000000;

  // Длина целого такта в микросекундах
  const long T = (MINUTE / BPM) * 4;

  play_tone(SPEAKER, 50, T / 8); // Восьмая
  delay(100);
  play_tone(SPEAKER, 50, T / 8); // Восьмая
  delay(100);
  play_tone(SPEAKER, 100, T / 4); // Четверть
  delay(100);
  play_tone(SPEAKER, 50, T / 8); // Восьмая
  delay(100);
  play_tone(SPEAKER, 50, T / 8); // Восьмая
  delay(100);
  play_tone(SPEAKER, 100, T / 4); // Четверть
  delay(100);
}
\end{minted}

Ритм готов, однако мы всё ещё выбираем частоты наших ``инструментов''
произвольно -- пришло время это исправить.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Базовые принципы благозвучия}

Человеческий слух устроен так, что нам может нравиться сочетание одних частот
звуков, и не нравиться сочетание других. Говорят, что те звуки, которые хорошо
сочетаются, образуют \emph{консонанс}, тогда как ``неприятные'' комбинации
образуют \emph{диссонанс}.

Например, частоты 50 Гц и 100 Гц звучат в сочетании довольно неплохо, хотя и не
являются музыкальными -- а всё потому, что одна частота ровно в два раза больше
другой. Понимание такого малозначимого, казалось бы, факта, позволяет нам
строить достаточно мелодичные произведения путём сочетания звуков, кратных по
частоте друг другу.

Воспроизведение одинаковых по частоте звуков образует идеальный консонанс, так
как их волны накладываются друг на друга, при этом усиливаясь.

\experiment{0}{ Запрограммируйте две Arduino таким образом, чтобы они
  воспроизводили одинаковые частоты и включите их одновременно. Сможете ли вы
  услышать, что частоты совпадают?  Что вы чувствуете, когда это происходит?

  Перепрограммируйте Arduino, чтобы частоты различались на 10Гц, 20Гц, 30Гц и
  т.д., увеличивая шаг сначала на 10Гц, потом на 100Гц. Какие комбинации
  получились неприятные, какие терпимые, какие приятные?}

\experiment{1}{ Попробуйте воспроизвести какую-нибудь звуковую частоту на Arduino,
  и одновременно подстроить звук вашего голоса под этот звук, пропев
  какую-нибудь гласную (например, ``А'') -- возможно у вас произойдёт тот самый
  ``Ага!'' момент, когда вы услышите совпадение частоты вашего голоса и звука
  динамика.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Октавная система}

Как вы, возможно, знаете, музыка строится из нот -- их всего семь: ``до'',
``ре'', ``ми'', ``фа'', ``соль'', ``ля'', ``си''. Каждой ноте соответствует
определённая частота. Но если мы с вами возьмём пианино (или синтезатор) и
посмотрим на его клавиатуру, то увидим, что клавишь на пианино гораздо больше,
чем нот.  Почему?

Оказывается, ноты объединяются в группы, которые называются \emph{октавами}. В
одной октаве семь нот (от ``до'' до ``си''), всего октав девять.

Для удобства мы пронумеруем все октавы от 0 (октава с самыми низкими частотами)
и до 8 (октава с самыми высокими частотами.)

Таким образом мы получаем $7 * 9 = 63$ разных нот\footnote{На самом деле, разных
звуков в октавной системе больше, чем нот -- об этом речь пойдёт чуть позже.} в
октавной системе.

Каким же образом ноты можно легко различить, если они называются одинаково и
различаются только номером октавы? Оказывается, для этого есть достаточно
удобная \emph{научная нотация} -- в таблице \ref{table:scientific-music-notation}
показано соотвествие слоговых названий нот (``до'', ``ре'', ``ми'', ``фа'',
``соль'', ``ля'', ``си'') и обозначений в научной нотации.

\begin{tabular}{p{4cm}|p{4cm}}
  Слоговое обозначение & Научное обознечение \\
  \hline \hline
  До   & С \\
  \hline
  Ре   & D \\
  \hline
  Ми   & E \\
  \hline
  Фа   & F \\
  \hline
  Соль & G \\
  \hline
  Ля   & A \\
  \hline
  Си   & B (H) \\
  \hline
  \label{table:scientific-music-notation}
\end{tabular}

Обратите внимание, что нота ``Си'' может быть обозначена либо буквой ``B''
(английский вариант), либо буквой ``H'' (немецкий вариант.) Мы с вами будем
использовать только английский вариант и всегда записывать ``Си'' как ``B''.

Прелесть научной нотации не только в краткости записи нот (что удобно для их
программирования), но и в том, что после буквы обычно ставится цифра -- номер
октавы, к которой принадлежит нота. Например, ``C0'' -- то нота ``До'' нулевой
октавы, а нота ``G5'' -- это нота ``Соль'' пятой октавы.

Одинаковые ноты из разных октав различаются своей частотой звука -- причём, не
просто различаются ``как попало'', а согласно строгому правилу: они кратны друг
другу. Если взять ноту ``C0'' (``до'' нулевой октавы) и ``C1'' (``до'' первой
октавы), то их частоты будут различаться ровно в два раза.

Тут стоит вспомнить, что звуки, частоты которых различаются в кратное количество
раз, приятны нашему слуху. Бинго! Мы только что поняли небольшую частичку
музыкальной теории.

Если же мы хотим рассчитать частоту нот не из смежных октав, а допустим ноту
``C0'' и ноту ``C3'' из третьей октавы, то мы должны использовать более
``хитрую'' формулу. Дело в том, что каждая следующая октава повышает частоту
выбранной ноты ровно в два раза.

Формула вычисления частоты выбранной ноты из нулевой октавы в произвольной
октаве представлена ниже (\ref{equation:music-note-frequency-equation}.)

\begin{equation}
  f * 2^n
  \label{equation:music-note-frequency-equation}
\end{equation}

Где ``f'' -- это частота выбранной ноты нулевой октавы, а ``n'' -- то номер
октавы, начиная с нуля.

Возьмём с вами для сравнения нулевую и четвёртую по счёту октаву -- частоты нот
представлены в таблице \ref{table:fourth-octave} (полная таблица октав
представлена в в \nameref{section:appendixA}.)

\begin{tabular}{p{2cm}|p{3cm}|p{2cm}|p{3cm}}
  № октавы & Слоговое обозначение & Научное обознечение & Частота (Гц) \\
  \hline \hline

  \multirow{7}{*}{0}
  \musicnote{0}{C}{16.352}
  \cline{2-4}
  \musicnote{0}{D}{18.354}
  \cline{2-4}
  \musicnote{0}{E}{20.602}
  \cline{2-4}
  \musicnote{0}{F}{21.827}
  \cline{2-4}
  \musicnote{0}{G}{24.500}
  \cline{2-4}
  \musicnote{0}{A}{27.500}
  \cline{2-4}
  \musicnote{0}{B}{30.868}
  \hline

  \multirow{7}{*}{4}
  \musicnote{4}{C}{261.630}
  \cline{2-4}
  \musicnote{4}{D}{293.660}
  \cline{2-4}
  \musicnote{4}{E}{329.630}
  \cline{2-4}
  \musicnote{4}{F}{349.230}
  \cline{2-4}
  \musicnote{4}{G}{392.000}
  \cline{2-4}
  \musicnote{4}{A}{440.000}
  \cline{2-4}
  \musicnote{4}{B}{493.880}
  \hline
  \label{table:fourth-octave}
\end{tabular}

Видно, что нота ``C0'' имеет частоту 16.352 Гц. Если мы подставим это значение в
формулу \ref{equation:music-note-frequency-equation}, то получим частоту ноты
``C4'' (см. формулу \ref{equation:music-note-frequency-equation-example}.)

\begin{equation}
  f * 2^n = \mbox{C0} * 2^4 = 16.352 * 2^4 = 261,632
  \label{equation:music-note-frequency-equation-example}
\end{equation}

Поздавляем -- с полученными знаниями мы теперь можем запрограммировать простую
мелодию.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программирование простых мелодий}

Для того, чтобы запрограммировать мелодию, нам потребуется узнать ноты, из
которых состоит данная мелодия, и их порядок. Как правило, эта информация
записывается в виде нотной записи -- но если вы ещё не умеете читать нотную
запись, то можно найти мелодии в упрощенной записи, где используется буквенная
(научная) нотация. К примеру, возьмём мелодию ``Twinkle, Twinkle, Little
Star'' \footnote{\url{https://ru.wikipedia.org/wiki/Twinkle,_Twinkle,_Little_Star}}
-- английскую колыбельную:

\begin{figure}[ht]
  \caption{``Twinkle, Twinkle, Little Star''}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      c4 c g' g
      a a g2
      f4 f e e
      d d c2
      g'4 g f f
      e e d2
      g4 g f f
      e e d2
      c4 c g' g
      a a g2
      f4 f e e
      d d c2
    }
    \layout {
      indent = 0\mm
      line-width = 100\mm
      ragged-last = ##t
    }
  \end{lilypond}
  \label{fig:sound-fig-3}
\end{figure}

Из таблицы \ref{table:music-notes-legths}, мы уже знаем, как различать нотные
``закорючки'', чтобы понять их длительность, но мы пока не разбирали, как
определить частоты нот по нотной записи. Поэтому ниже приводится полный список
нот композиции в правильном порядке (см.
\ref{table:twinklet-winkle-little-star-notes}), где ноты разбиты по строкам
таким образом, чтобы каждая строка соответствовала одному такту.

\begin{tabular}{p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}}
  № такта & \multicolumn{4}{c}{Ноты} \\
  \hline \hline
  0 & C4 & C4 & G4 & G4 \\
  \hline
  1 & A4 & A4 & G4 & \\
  \hline
  2 & F4 & F4 & E4 & E4 \\
  \hline
  3 & D4 & D4 & C4 & \\
  \hline
  4 & G4 & G4 & F4 & F4 \\
  \hline
  5 & E4 & E4 & D4 & \\
  \hline
  6 & G4 & G4 & F4 & F4 \\
  \hline
  7 & E4 & E4 & D4 & \\
  \hline
  8 & C4 & C4 & G4 & G4 \\
  \hline
  9 & A4 & A4 & G4 & \\
  \hline
  \label{table:twinkle-twinkle-little-star-notes}
\end{tabular}

Используя наши знания про нотные ``закорючки'', попробуем назначить длительность
для каждой из нот, подписав его в скобках.

\begin{tabular}{p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}}
  № такта & \multicolumn{4}{c}{Ноты} \\
  \hline \hline
  0 & C4 ($\frac{1}{4}$) & C4 ($\frac{1}{4}$) & G4 ($\frac{1}{4}$) & G4 ($\frac{1}{4}$) \\
  \hline
  1 & A4 ($\frac{1}{4}$) & A4 ($\frac{1}{4}$) & G4 ($\frac{1}{2}$) & \\
  \hline
  2 & F4 ($\frac{1}{4}$) & F4 ($\frac{1}{4}$) & E4 ($\frac{1}{4}$) & E4 ($\frac{1}{4}$) \\
  \hline
  3 & D4 ($\frac{1}{4}$) & D4 ($\frac{1}{4}$) & C4 ($\frac{1}{2}$) & \\
  \hline
  4 & G4 ($\frac{1}{4}$) & G4 ($\frac{1}{4}$) & F4 ($\frac{1}{4}$) & F4 ($\frac{1}{4}$) \\
  \hline
  5 & E4 ($\frac{1}{4}$) & E4 ($\frac{1}{4}$) & D4 ($\frac{1}{2}$) & \\
  \hline
  6 & G4 ($\frac{1}{4}$) & G4 ($\frac{1}{4}$) & F4 ($\frac{1}{4}$) & F4 ($\frac{1}{4}$) \\
  \hline
  7 & E4 ($\frac{1}{4}$) & E4 ($\frac{1}{4}$) & D4 ($\frac{1}{2}$) & \\
  \hline
  8 & C4 ($\frac{1}{4}$) & C4 ($\frac{1}{4}$) & G4 ($\frac{1}{4}$) & G4 ($\frac{1}{4}$) \\
  \hline
  9 & A4 ($\frac{1}{4}$) & A4 ($\frac{1}{4}$) & G4 ($\frac{1}{2}$) & \\
  \hline
  \label{table:twinkle-twinkle-little-star-notes}
\end{tabular}

Для того, чтобы запрограммировать данную мелодию, удобно в начале программы
объявить каждую ноту в виде константы. Каждая константа будет хранить частоту
звука.\footnote{Имена констант обычно пишутся заглавными буквами, т.е.
правильнее было бы именовать эти константы ``C4'', ``D4'', ``E4'' и т.д. Однако мы
используем здесь буквы в нижнем регистре, чтобы избежать конфликтов имён с
константами, которые уже есть в Arduino (к примеру, ``A4''.)}

Нам пока потребуются только ноты из четвёртой октавы. Константы разумно объявить
до функции \texttt{setup}, в самом верху программы.

\begin{minted}{cpp}
const float c4 = 261.630;
const float d4 = 293.660;
const float e4 = 329.630;
const float f4 = 349.230;
const float g4 = 392.000;
const float a4 = 440.000;
const float b4 = 493.880;
\end{minted}

Также нам нужно знать темп мелодии -- то есть, BPM. Для ``Twinkle, Twinkle,
Little Star'' это параметр равен 120 ударов в минуту.

Как только мы объявили все необходимые константы и узнали BPM, то
запрограммировать мелодию не составит труда.

\begin{minted}{cpp}
// ...

void loop() {
  const long BPM = 120;
  const long MINUTE = 60 * 1000000;
  const long T = (MINUTE / BPM) * 4;

  // 0-й такт.
  play_tone(SPEAKER_PIN, c4, T / 4);
  delay(100);
  play_tone(SPEAKER_PIN, c4, T / 4);
  delay(100);
  play_tone(SPEAKER_PIN, g4, T / 4);
  delay(100);
  play_tone(SPEAKER_PIN, g4, T / 4);
  delay(100);

  // 1-й такт.
  play_tone(SPEAKER_PIN, a4, T / 4);
  delay(100);
  play_tone(SPEAKER_PIN, a4, T / 4);
  delay(100);
  play_tone(SPEAKER_PIN, g4, T / 2);
  delay(100);

  // и так далее
}
\end{minted}

Допишите необходимые части кода (\texttt{setup}, \texttt{play\_tone} и т.д.) и
загрузите его в Arduino. Если вы всё сделали правильно, то у вас должна заиграть
мелодия. Прекрасно!

Но данное решение является не совсем оптимальным с точки зрения количества кода,
которое необходимо напмсать. Решением данной проблемы является использование
\emph{массивов}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Использование массива для программирования мелодии}

\emph{Массив} -- это переменная, состоящая из группы других переменных одного
типа. В массиве мы сможем хранить ноты нашей мелодии.

Визуально массив можно представить в виде последовательности ``коробочек'',
каждая из которых имеет порядковый номер (называемый \emph{индексом}) и может
хранить один элемент (\ref{table:array-example-1}.)

\begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
  \hline
  c4 & c4 & g4 & g4 & a4 & a4 & g4 \\
  \hline
  \multicolumn{1}{c}{0}
  & \multicolumn{1}{c}{1}
  & \multicolumn{1}{c}{2}
  & \multicolumn{1}{c}{3}
  & \multicolumn{1}{c}{4}
  & \multicolumn{1}{c}{5}
  & \multicolumn{1}{c}{6}
  \label{table:array-example-1}
\end{tabular}

В приведённом примере массив хранит семь элементов, при этом номер (индекс)
первого элемента равен нулю (``Настоящие программисты считают с нуля!''), а
номер последнего равен шести. Если мы попытаемся взять несуществующий элемент
(например, седьмой, или минус первый), то это приведёт к ошибке.

Нам нужно создать массив из нужного количества элементов, если быть точным, то
28 элементов, по количеству нот, используемых в нашей мелодии, и заполнить
массив значениями. Всё так же, как и раньше -- указываем тип переменной и её
название, но чтобы указать, что это массив, после имени пишем квадратные скобки
и в них количество элементов, из которых будет состоять массив:

\begin{minted}{cpp}
float melody[28] = {
  c4, c4, g4, g4,
  a4, a4, g4,
  f4, f4, e4, e4,
  d4, d4, c4,
  g4, g4, f4, f4,
  e4, e4, d4,
  g4, g4, f4, f4,
  e4, e4, d4,
};
\end{minted}

Для обращения к определённым элементам массива нужно написать имя массива и в
квадратных скобках номер элемента. Например, если захотелось нам поменять
значение нулевого элемента, то мы могли бы сделать это так:

\begin{minted}{cpp}
melody[0] = g4;
\end{minted}

Этот массив стоит объявить перед функцией \texttt{loop} в нашей программе.
Внутри же loop мы можем пройтись по данному массиву в цикле и воспроизвести
каждую из нот, использовав в качестве номера элемента счётчик цикла:

\begin{minted}{cpp}
// ...

void loop() {
  const long BPM = 120;
  const long MINUTE = 60 * 1000000;
  const long T = (MINUTE / BPM) * 4;

  for (int note_idx = 0; note_idx < 28; note_idx++) {
    play_tone(SPEAKER_PIN, melody[note_idx], T / 4);
    delay(100);
  }
}
\end{minted}

Заметьте, насколько сократилась запись нашей мелодии. Однако мы временно
потеряли возможность задавать длительность для каждой ноты в отдельности.

Чтобы это исправить, можно создать дополнительный массив с длительностями нот --
назовём его \texttt{melody\_t}.

Каждый элемент нашего массива \texttt{melody\_t} будет содержать длительность
ноты из массива \texttt{melody} в виде знаменателя простой дроби, где в
числителе у нас находится длина такта. Например, нота номер ноль (``C4'') из
массива \texttt{melody} имеет в музыкальном произведении длительность
$\frac{1}{4}$, следовательно её длительность в массива \texttt{melody\_t} будет
записана, как 4.

\begin{minted}{cpp}
// Массив с нотами (их частотами.)
float melody[28] = {
  c4, c4, g4, g4,
  a4, a4, g4,
  f4, f4, e4, e4,
  d4, d4, c4,
  g4, g4, f4, f4,
  e4, e4, d4,
  g4, g4, f4, f4,
  e4, e4, d4,
};

// Массив с длительностями нот.
float melody_t[28] = {
  4,  4,  4,  4,
  4,  4,  2,
  4,  4,  4,  4,
  4,  4,  2,
  4,  4,  4,  4,
  4,  4,  2,
  4,  4,  4,  4,
  4,  4,  2,
};
\end{minted}

После этого следует обновить наш код воспроизведения мелодии:

\begin{minted}{cpp}
// ...

void loop() {
  const long BPM = 120;
  const long MINUTE = 60 * 1000000;
  const long T = (MINUTE / BPM) * 4;

  for (int note_idx = 0; note_idx < 28; note_idx++) {
    play_tone(SPEAKER_PIN,
              melody[note_idx],
              T / melody_t[note_idx]);
    delay(100);
  }
}
\end{minted}

Обратите внимание на код \texttt{T / melody\_t[note\_idx]}, который рассчитывает
как раз длительность ноты -- в числителе простой дроби стоит \texttt{T}, а в
знаменателе -- \texttt{melody\_t[note\_idx]}.

\begin{equation}
  \mbox{Длина ноты в микросекундах} = \frac{\mbox{T}}{\mbox{melody\_t[note\_idx]}}
\end{equation}

При всём этом запись из двух массивов выглядит достаточно громоздко, так как
нужно следить за тем, чтобы оба массива (нот и их длительностей) совпадали по
размеру.

Чтобы решить эту проблему, мы можем использовать двумерные массивы, о которых
пойдёт речь в следующем разделе.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Двумерные массивы}

Было бы круто разместить наши ноты таким образом, чтобы кажая нота лежала в
ячейке массива вместе со своей длительностью. К счастью у нас есть такая
возможность -- мы можем использовать \emph{Двумерные массивы}.

Схематическое изображение двумерного массива представлено в виде таблицы
\ref{table:array-example-2}.

\begin{table}[ht]
  \centering
  \begin{tabular}{r|l|l|l}
    \multicolumn{1}{l}{№ строки} & \multicolumn{2}{l}{№ столбца}                 &   \\
    \multicolumn{1}{l}{}         & \multicolumn{1}{l}{0} & \multicolumn{1}{l}{1} &   \\ 
    \cline{2-3}
    0                            & с4                    & 4                     &   \\ 
    \cline{2-3}
    1                            & с4                    & 4                     &   \\
    \cline{2-3}
    2                            & g4                    & 4                     &   \\
    \cline{2-3}
    3                            & g4                    & 4                     &   \\
    \cline{2-3}
    4                            & a4                    & 4                     &   \\
    \cline{2-3}
    5                            & a4                    & 4                     &   \\
    \cline{2-3}
    6                            & g4                    & 2                     &   \\
    \cline{2-3}
  \end{tabular}
  \label{table:array-example-2}
\end{table}

Каждая строка нашего массива должна содержать описание одной ноты. Столбец с
номером ноль содержит частоту ноты, а столбец номер один содержит её
длительность в виде знаменателя простой дроби, где в числителе у нас находится
длина такта. Например, нота номер ноль (``C4'') имеет в музыкальном произведении
длительность $\frac{1}{4}$, следовательно её длительность будет записана, как 4.

Записать программно мелодию в виде двумерного массива можно следующим образом:

\begin{minted}{cpp}
float melody[28][2] = {
  {c4, 4}, {c4, 4}, {g4, 4}, {g4, 4},
  {a4, 4}, {a4, 4}, {g4, 2},
  {f4, 4}, {f4, 4}, {e4, 4}, {e4, 4},
  {d4, 4}, {d4, 4}, {c4, 2},
  {g4, 4}, {g4, 4}, {f4, 4}, {f4, 4},
  {e4, 4}, {e4, 4}, {d4, 2},
  {g4, 4}, {g4, 4}, {f4, 4}, {f4, 4},
  {e4, 4}, {e4, 4}, {d4, 2},
};
\end{minted}

Как можно видеть, теперь каждый элемент массива -- это по сути одномерный массив
из двух элементов, записанный в фигурных скобках. Например, элемент номер ноль
нашего массива \texttt{melody} содержит массив \texttt{\{c4, 4\}} -- частота ноты
и её длительность.

Теперь мы можем адаптировать код воспроизведения мелодии под наши задачи:

\begin{minted}{cpp}
// ...

void loop() {
  const long BPM = 120;
  const long MINUTE = 60 * 1000000;
  const long T = (MINUTE / BPM) * 4;

  for (int note_idx = 0; note_idx < 28; note_idx++) {
    play_tone(SPEAKER_PIN,
              melody[note_idx][0],
              T / melody[note_idx][1]);
    delay(100);
  }
}
\end{minted}

Используя двумерные массивы, можно кратко и ёмко описать мелодию, даже намного
более сложную, чем ``Twinkle, Twinkle, Little Star''.

На этом этапе нам необходимо разобрать, как же работает \emph{нотный стан}
(называемый также \emph{нотоносцем}), на котором располагаются ноты -- для того,
чтобы уметь самостоятельно определять, где какая нота (частота) находится.

\section{Нотный стан}

Мы можем программировать простые мелодии, не зная нотной записи -- используя
готовые примеры из интернета -- и для большинства популярных мелодий (вроде
``Имперского марша'' из ``Звёздных войн'') найти ноты в научной нотации (или даже
готовые программы для Arduino!) не составит труда. Но в какой-то момент мы можем
столкнуться с ситуацией, когда для нашей любимой мелодии есть только ноты и
более ничего. Поэтому, прежде, чем двигаться дальше, неплохо бы остановиться
нотной записи.

Посмотрим ещё раз на мелодию ``Twinkle, Twinkle, Little Star''.

\begin{figure}[ht]
  \caption{``Twinkle, Twinkle, Little Star''}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      c4 c g' g
      a a g2
      f4 f e e
      d d c2
      g'4 g f f
      e e d2
      g4 g f f
      e e d2
      c4 c g' g
      a a g2
      f4 f e e
      d d c2
    }
    \layout {
      indent = 0\mm
      line-width = 100\mm
      ragged-last = ##t
    }
  \end{lilypond}
  \label{fig:sound-fig-4}
\end{figure}

Ранее мы проигнорировали расположение нот по оси ``Y'' и вместо этого
использовали готовые буквенные обозначения. Теперь пришло время внимательно
посмотреть на эти группы по пять линий и обозначения на них.

Начнём с линий -- они называются \emph{нотным станом} (его также называют
``нотоносцем'', поскольку он ``несёт'' на себе ноты.)

Поверх нотного стана записываются ноты и другие обозначения. В самом начале
линий пишется большая закорючка, называемая \emph{ключом} -- ключ определяет
положение определённой ноты на нотном стане. Выше в мелодии ``Twinkle, Twinkle,
Little Star'' используется только один из видов ключа -- называемого
\emph{скрипичным ключом}. Скрипичный ключ обводит кружочком-завитком ту линию,
на которой располагается нота ``соль'' четвёртой октавы (``G4''):

\begin{figure}[ht]
  \caption{Скрипичный ключ и нота ``G4''.}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      g'1
    }
  \end{lilypond}
  \label{fig:lilypond-clef-example}
\end{figure}

Как можно видеть на рисунке выше, вторая линия снизу соответствует ноте ``Соль''
-- поскольку она обведена скрипичным ключом. Следовательно, все ноты, которые
``зацепились'' за эту линию, будут нотой ``Соль'' четвёртой октавы (``G4''.)

Но ноты могут записываться не толькн на саимих линиях, но и посерёдке между
ними.

Схематически расположение нот можно представить в виде следующего графика:

\begin{tikzpicture}
  \node (image) at (4, 0) {
    \begin{lilypond}
      \relative c' {
        \numericTimeSignature
        \time 4/4
        c4 d4 e4 f4 g4 a4 b4
      }
    \end{lilypond}
  };
  \draw[thick, ->] (0, -1.0) -- (10, -1.0) node[anchor=north east] {x (Время)};
  \draw[thick, ->] (0, -1.0) -- (0, 1.0) node[anchor=north east] {y (Частота)};
  \label{fig:lilypond-music-graph-1}
\end{tikzpicture}

На данном ``музыкальном'' графике по-порядку выстроены ноты ``C'', ``D'', ``E'',
``F'', ``G'', ``A'', ``B''. При движении вверх по оси ``y'', частота звуков
повышается, при движени вниз -- понижается.

Следовательно, если мы будем двигаться выше по линейкам, то между второй снизу и
третьей линейкой (она является средней на рисунке) будет находиться следующая
нота после ``Соль'' (``G4'') -- а именно нота ``Ля'' (``A4''). Третья же линейка
(средняя) соответствует ноте ``Си'' (``B4'') и так далее. Если мы пойдём ещё
выше, от над средней линейкой находится уже начало следующей, пятой октавы -- то
есть, нота ``До'' (``C5''.)

Если будем двигаться вниз от ноты ``Соль'' чётвёртой октавы, то будем идти в
обратную сторону: между первой снизу и второй линией находится нота ``Фа''
(``F4''), самая первая (нижняя) линия соответствует ноте ``Ми'' (``E4''.)

Для того, чтобы запомнить расположение нот на нотном стане, можно
воспользоваться ``запоминалками'' -- мнемониками. В интернете их можно найти
великое множество. Вот наш вариант мнемоники для скрипичного ключа:

\begin{tikzpicture}
  \node (image) at (4, 2) {
    \includegraphics[width=8cm]{music-clef-mnemonic}
  };
  \draw[thick, ->] (0, -1.0) -- (10, -1.0) node[anchor=north east] {x (Время)};
  \draw[thick, ->] (0, -1.0) -- (0, 4.0) node[anchor=north east] {y (Частота)};
  \label{fig:lilypond-music-graph-1}
\end{tikzpicture}

Если читать слова снизу вверх, то образуется фраза ``\textbf{E}ating
\textbf{G}reen \textbf{B}ananas \textbf{D}isgusts \textbf{F}riends \textbf{A}nd
\textbf{C}oworkers'' (``Поедание зелёных бананов вызывает отвращение у друзей и
коллег по работе''). Первая буква слова кодирует ноту в научной нотации. Вверху
мы, помимо основных пяти линеек, подрисовали ещё две дополнительных линии,
выделив их пунктиром. На нотном стане дополнительные линии сверху и снизу
добавляются, если не хватает основных линий для записи композиции. Мнемоника
кодирует только основные линии нотного стана, однако зная их, мы можем понять,
какие ноты находятся между линиями.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Паузы в музыке}

Есть ещё один момент, на котором мы до текущего момента не заостряли внимание ---
паузы в произведении. Правильные паузы также важны, как и сами ноты.

В нотной записи паузы отмечаются специальными значками (см. рисунок
\ref{fig:lilypond-rest-example-1}.) \footnote{В музыке существуют паузы,
занммающие несколько тактов, либо очень короткие паузы -- тридцать вторые,
шестьдесят четвёртые и т.п. Используются они редко, поэтому мы их не будем
разбирать здесь.}

\begin{figure}[ht]
  \caption{Паузы в музыке.}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      r1-"Целая."
    }
  \end{lilypond}
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      r2-"Половинная." r2
    }
  \end{lilypond}
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      r4-"Четвертная." r4 r4 r4
    }
  \end{lilypond}
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      r8-"Восьмая." r8 r8 r8 r8 r8 r8 r8
    }
  \end{lilypond}
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      r16-"Шестнадцатая." r16 r16 r16
      r16 r16 r16 r16
      r16 r16 r16 r16
      r16 r16 r16 r16
    }
  \end{lilypond}
  \label{fig:lilypond-rest-example-1}
\end{figure}

Целая пауза равна по длине целой ноте, половинная --- половине целой ноты и т.д.
Иными словами, мы можем использовать подход, примененный нами для высчитывания
длительности нот, для расчета длительности пауз в произведении.

Обозначения пауз с их длительностями предтсавлены в таблице
\ref{table:music-rest-legths}.

\begin{table}[ht]
  \caption{Некоторые возможные длительности пауз.}
  \begin{tabular}{p{3cm}|p{4cm}|p{3.5cm}}
    Начертание & Длительность & Название \\
    \hline \hline
    \wholeNoteRest     & $\frac{1}{1}$ & ``Целая'' \\
    \hline
    \halfNoteRest      & $\frac{1}{2}$ & ``Половина'' \\
    \hline
    \crotchetRest        & $\frac{1}{4}$ & ``Четверть'' \\
    \hline
    \quaverRest    & $\frac{1}{8}$ & ``Восьмая'' \\
    \hline
    \semiquaverRest & $\frac{1}{16}$ & ``Шестнадцатая'' \\
    \hline
  \end{tabular}
  \label{table:music-rest-legths}
\end{table}

Для реализации паузы в программе необходимо во-первых создать специальную ноту с
нулевой частотой. Пауза в музыке называется ``Покой'' (или ``Rest''
по-английски), поэтому для обозначения паузы в программе мы будем использовать
заглавную букву ``R''.

\begin{verbatim}
const float R = 0; // Пауза ("Rest")
\end{verbatim}

Далее нам необходимо изменить функцию \texttt{play\_tone} таким образом, чтобы
она могла корректно ``воспроизводить'' паузы. Для этого нам необходимо добавить
такое условие, чтобы, если частота ноты больше нуля, то функция выполняла тот
код, который мы использовали раньше; иначе -- чтобы выполнялась просто задержка.

\begin{minted}{cpp}
// Функция воспроизведения звука указанной частоты.
void play_tone(int port, float f, long t) {
  if (f > 0) {
    const int T = 1000000 / f;
    int d = T / 2;
    int count = t / T;
    for (int i = 0; i < count; i++) {
      digitalWrite(port, HIGH);
      delayMicroseconds(d);
      digitalWrite(port, LOW);
      delayMicroseconds(d);
    }
  } else {
    delay(t / 1000); // Пауза
  }
}
\end{minted}

Обратите внимание, что для создания задержки мы используем код \texttt{delay(t /
  1000)} -- делить \texttt{t} на 1000 необходимо по той причине, что время
проигрывания ноты (\texttt{t}) задаётся в микросекундах, а функция
\texttt{delay} принимает время ожидания в миллисекундах. Чтобы преобразовать
микросекунды в миллисекунды, достаточно поделить количество микросекунд на 1000
(так как в каждой микросекунде содержится 1000 миллисекунд.) Почему же мы не
могли использовать функцию \texttt{delayMicroseconds} для организации задержек
(пауз) прямо в микросекундах, без преобразования? Ответ прост --
\texttt{delayMicroseconds} не умеет долго ждать, и значения \texttt{t} для неё
будут слишком большими; если мы попытаемся использовать
\texttt{delayMicroseconds} с большими отрезками времени, то она не будет
корректно их обрабатывать, и задержка получится неправильной.

Для наглядной демонстрации использования пауз возьмём другое музыкальное
произведение -- ``Кабы небыло зимы'' из мультфильма ``Простоквашино''.

\begin{figure}[ht]
  \caption{Часть мелодии ``Кабы небыло зимы'' из мультфильма ``Простоквашино''.}
  \begin{lilypond}
    \relative c' {
      \key g \major
      \numericTimeSignature
      \time 4/4
      b8 b b'8. fis16 a8 g e4 |
      d8 d << b'8. d8. >> << c16 a >> << c8 a >> << b8 g8 >> r4
      d'8 c a fis << a c >> << g b >> << g4 b >>
      b,8 b << g'8. b8. >> << fis16 a >> << fis8 a >> << e8 g8 >> r4
    }
    \layout {
      indent = 0\mm
      line-width = 120\mm
      ragged-last = ##t
    }
  \end{lilypond}
  \label{fig:lilypond-melody-prostokvashino}
\end{figure}

В нотной записи на рисунке \ref{fig:lilypond-melody-prostokvashino} представлена
часть мелодии, которую мы попытаемся переложить на программный код. Полную
версию мелодии можно увидеть на рисунке
\ref{fig:lilypond-melody-prostokvashino-full}.

Можно заметить две четвертные паузы (\crotchetRest), которые необходимо добавить
в массив нот, чтобы произведение звучало, как в оригинале.

Можно также заметить двойные ноты, записанные одна над другой -- это значит, что
данные ноты должны играться одновременно. Для упрощения нашей задачи мы пока
будем брать самую верхнюю ноту из группы.

Попробуем вписать ноты в массив и послушать, как они будут звучать. Чтобы не
запутаться, разобъём ноты по группам, согласно тактам (по одной группе на
строке) -- а рядом с каждой группой в виде комментария напишем номер этого такта
(например, такт номер ноль мы пометили \texttt{/* 0 */}.)

\begin{minted}{cpp}
float prostokvashino[28][2] = {
  /* 0 */ {b3, 8}, {b3, 8}, {b4, 8}, {f4, 16}, {a4, 8}, {g4, 8}, {e4, 4},
  /* 1 */ {d4, 8}, {d4, 8}, {d5, 8}, {c5, 16}, {c5, 8}, {b4, 8}, {R,  4},
  /* 2 */ {d5, 8}, {c5, 8}, {a4, 8}, {f4, 8},  {c5, 8}, {b4, 8}, {b4, 4},
  /* 3 */ {b3, 8}, {b3, 8}, {b4, 8}, {a4, 16}, {a4, 8}, {g4, 8}, {R,  4},
};
\end{minted}

При воспроизведении мелодия будет похожей на оригинал, однако вы можете заметить
некоторые ``несоответствия''. Источников данных несоответствий несколько. Первый
источник проблем в том, мы не учитываем, что длительность некоторых нот, которые
помечены точкой справа (вот так: ``\eighthNoteDotted'') больше стандартной.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ноты с точками}

В музыкальной нотации точка, которая ставится справа от ноты, увеличивает её
длительность на половину от базовой.

Например, если у нас точка идёт после восьмушки (``\eighthNoteDotted''), то
следовательно к её длительности будет прибавляться половина от её длительности.
Половинка от восьмушки -- это шестнадцатая. Чтобы сложить простые дроби, которые
у нас получились, необходимо привести их к общему знаменателю. И формула
вычисления длительности будет следующая:

\begin{equation}
  \mbox{\eighthNoteDotted} = \mbox{\eighthNote} + \mbox{\sixteenthNote}
  = \frac{1}{8} + \frac{1}{16} = \frac{2}{16} + \frac{1}{16} = \frac{3}{16}
\end{equation}

Получившееся число $\frac{3}{16}$ для нас неудобно, так как мы в программе
подставляем в числитель дроби длительность одного такта, а тут у нас получается,
что необходимо поставить длину трёх тактов. Чтобы избавиться от этой неудобной
тройки в числителе, мы можем разделить числитель и знаменатель на 3.

\begin{equation}
  \frac{3 / 3}{16 / 3} = \frac{1}{16 / 3}
\end{equation}

Получившееся число $16 / 3$ необходимо подставить в массив с нашими нотами.
Например, третья нота нулевого такта -- ``B4'' -- как раз восьмая с точкой. В
массиве её длительность надо исправить -- вместо \texttt{\{b4, 8\}} написать
\texttt{\{b4, 16.0 / 3.0\}}. Тоже самое необходимо сделать с другими нотами,
возле которых стоит точка.

Для того, чтобы даннй код уместился в книгу, нам пришлось разбить каждый такт на
две строки, но по комментариям и отступам должно быть понятно, что происходит в
коде.

\begin{minted}{cpp}
float prostokvashino[28][2] = {
  /* 0 */ {b3, 8},  {b3, 8}, {b4, 16.0 / 3.0},
  /*   */ {f4, 16}, {a4, 8}, {g4,          8}, {e4, 4},
  /* 1 */ {d4, 8},  {d4, 8}, {d5, 16.0 / 3.0},
  /*   */ {c5, 16}, {c5, 8}, {b4,          8}, {R,  4},
  /* 2 */ {d5, 8},  {c5, 8}, {a4,          8},
  /*   */ {f4, 8},  {c5, 8}, {b4,          8}, {b4, 4},
  /* 3 */ {b3, 8},  {b3, 8}, {b4, 16.0 / 3.0},
  /*   */ {a4, 16}, {a4, 8}, {g4,          8}, {R,  4},
};
\end{minted}

Теперь наша мелодия звучит ещё более похоже на оригинал.

Здесь стоит упомянуть, что в музыке встречаются ноты двумя точками справа, что
даёт удлинение ноты на половину её длительности и на половину от половины -- но
подобные ситуации редки из-за неудобства рассчёта необходимой длительности при
чтении музыкантом нот с листа. То ли дело нам, программистам -- прочитали
неспеша, запрограммировали, а там пусть компьютер сам пыжится над нашим
творением!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Полутона, диезы и бемоли}

Мы с вами всю эту главу говорим, что нот в октаве семь, и суммарно звуков 63
штуки, если считать по всем октавам. Но это не совсем точно -- на самом деле
звуков в октаве не семь, а двенадцать!

Вот так сюрприз. Откуда берутся дополнительные пять звуков? Оказывается, что в
музыке есть так называемые \emph{полутона}, которые позволяют разнообразить
музыку новыми звуками.

Нагляднее всего эти скрытные звуки легче всего увидеть на клавиатуре пианино.

\begin{figure}[ht]
  \caption{Одна октава на клавиатуре пианино.}
  \centering
  \begin{tikzpicture}
    \draw (0, 0) -- (7, 0);
    \foreach \x/\note in {0/C, 1/D, 2/E, 3/F, 4/G, 5/A, 6/B, 7/} {
      \draw (\x, 0) -- (\x, 2) -- (\x, 0) node[anchor=south west] {\note};
    };
    \foreach \x in {1, 2, 4, 5, 6} {
      \node[
        rectangle,
        draw,
        fill=black,
        minimum width=0.5cm,
        minimum height=1.35cm
      ] (r) at (\x, 1.30) {};
    };
  \end{tikzpicture}
  \label{fig:lilypond-music-graph-1}
\end{figure}

Видно, что между парами нот ``C''--``D'', ``D''--``E'', ``F''--``G'',
``G''--``A'', ``A''--``B'' находятся чёрные клавиши. Если мы посчитаем, сколько
всего клавиш в одной октаве, то получим двенадцать штук -- двенадцать звуков.

Объясняется это тем, что между двумя соседними клавишами \emph{расстояние в один
полутон}, если представить частотный диапазон октавы как некий отрезок.
Большинство пар нот имеют друг от друга достаточное расстояние, чтобы туда,
ровно посерёдке, добавить ещё одну клавишу (исключение составляют пары
``B''--``C'', ``E''--``F''.)

Каких-то особых закорючек для этих дополнительных звуков в музыке не
применяется, однако есть ``модификаторы'' для основных семи нот, поднимающих или
понижающих их частоту на полутон.

Для того, чтобы например получить частоту клавиши между парой ``C''--``D'',
можно поднять частоту ``C'' на пол-тона, либо понизить частоту ``D'' на те же
пол-тона.

Модификатор, повышающий частоту ноты на пол-тона называется \emph{диезом}, тогда
как аналогичный модификатор, понижающий частоту на пол-тона, называется
\emph{бемолем}.

Ноты с модификатором ``Диез'' помечаются решёткой (``\#''), стоящей перед нотой
-- например, на рис. \ref{fig:lilypond-f4-sharp} изображена ``Фа Диез''
четвёртой октавы.

\begin{figure}[ht]
  \caption{``Фа Диез'' четвёртой октавы.}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      fis4
    }
  \end{lilypond}
  \label{fig:lilypond-f4-sharp}
\end{figure}

Чтобы высчитать частоту ``F4\#'', надо найти среднее арифметическое для частот
ноты ``F4'' и следующей перед ней ноты ``G4'' (см. формулу
\ref{quation:f-sharp-calculation}.)

\begin{equation}
  \frac{\mbox{F4} + \mbox{G4}}{2} = \mbox{F4\#}
  \label{quation:f-sharp-calculation}
\end{equation}

Программно вычислить ``F4\#'' не составляет труда, как показано в коде ниже.
Заметьте, что мы обозначили получившуюся частоту, как \texttt{f4s}, так как ``Фа
Диез'' по-английски пишется, как ``Fa Sharp'', и мы используем букву ``s'' из
слова ``sharp'' после ноты для краткости.

\begin{minted}{cpp}
const float f4  = 349.230;
const float g4  = 392.000;
const float f4s = (f4 + g4) / 2; // F4 Диез
\end{minted}

Подобный подход работает и с другими нотами.

Кстати, для тех нот, после которых нет чёрной клавиши (``B'', ``E''), диезом
является просто следующая нота -- например, ``E4\#'' -- это ``F4'', а ``B4\#'' не
что иное, как ``C5''.

Таким образом:

\begin{minted}{cpp}
const float e4  = 329.630;
const float f4  = 349.230;
const float e4s = f4; // E4 Диез
\end{minted}

Бемоли по логике работают схоже с диезами, с одним отличием -- они
\textbf{понижают} частоту ноты на половину тона. Обозначаются бемоли специальным
символом ``\flat'', который ставится перед нотой, на которую ``накладывается''
модификатор ``бемоль''.

Для примера возьмём ``E4\flat'' (см. рисунок \ref{fig:lilypond-e4-flat}.)

\begin{figure}[ht]
  \caption{``Фа Диез'' четвёртой октавы.}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      ees4
    }
  \end{lilypond}
  \label{fig:lilypond-e4-flat}
\end{figure}

Бемоль для неё -- это частота ровно посерёдке между ``E4'' и предыдущей нотой от
неё (``D4''), как показано на формуле \ref{equation:e-flat-calculation}.

\begin{equation}
  \frac{\mbox{E4} + \mbox{D4}}{2} = \mbox{E4\flat}
  \label{equation:e-flat-calculation}
\end{equation}

Для обозначения бемолей в программном коде мы будем добавлять букву ``f'' к
имени ноты, после её номера октавы, так как в английском ноты с бемолями
называются ``приплюcнутыми'' (``flat'') -- например, ``E4 Бемоль'' будет
называться ``E4 Flat''.\footnote{В музыке иногда встречатеся двойные диезы и
двойные бемоли, что означает необходимость брать ноту на два полутона выше или
ниже -- по сути, брать следующую или предыдующую ноту.}

\begin{minted}{cpp}
const float d4  = 293.660;
const float e4  = 329.630;
const float e4f = (e4 + d4) / 2; // E4 Бемоль
\end{minted}

Все эти диезы и бемоли мы пока с вами рассматривали в вариантах, когда
знак-модификатор пишется разу перед нотой, на которую ``накладывается
заклинание'' -- они называются знаками ``по-месту'', или ``случайными'' (англ.
\emph{accidentals}.) Но музыкантам неудобно писать подобные модификаторы перед
каждой нотой, если подобных случаев в композиции много. Чтобы решить эту
проблему, в музыке используются знаки диезов и бемолей, которые ставятся в
начале нотного стана -- в начале линий нотоносца. Влияние таких значков
распространяется на все ноты подобные той, на которую наложено ``заклинание''.

Вернёмся к мелодии ``Кабы небыло зимы''.  Если посмотреть на начало каждой
строки, то можно увидеть решёнку на ``F5'' -- это означает, что все ноты ``F''
будут диезами.

\begin{tikzpicture}
  \node (image) at (4, 0) {
    \begin{lilypond}
      \relative c' {
        \key g \major
        \numericTimeSignature
        \time 4/4
        b8 b b'8. fis16 a8 g e4 |
        d8 d << b'8. d8. >> << c16 a >> << c8 a >> << b8 g8 >> r4
      }
      \layout {
        indent = 0\mm
        line-width = 120\mm
        ragged-last = ##t
      }
    \end{lilypond}
  };
  \draw[red, thick, ->] (0.0, 1.0) node[anchor=south west] {F5 Диез} -- (-0.5, 0.5);
  \label{fig:lilypond-melody-prostokvashino-2}
\end{tikzpicture}

Зная это, мы можем соответствующим образом модифицировать код нашей мелодии.

\begin{minted}{cpp}
const float f4s = (f4 + g4) / 2;

// ...

float prostokvashino[28][2] = {
  /* 0 */ {b3,  8},  {b3, 8}, {b4, 16.0 / 3.0},
  /*   */ {f4s, 16}, {a4, 8}, {g4,          8}, {e4, 4},
  /* 1 */ {d4,  8},  {d4, 8}, {d5, 16.0 / 3.0},
  /*   */ {c5,  16}, {c5, 8}, {b4,          8}, {R,  4},
  /* 2 */ {d5,  8},  {c5, 8}, {a4,          8},
  /*   */ {f4s, 8},  {c5, 8}, {b4,          8}, {b4, 4},
  /* 3 */ {b3,  8},  {b3, 8}, {b4, 16.0 / 3.0},
  /*   */ {a4,  16}, {a4, 8}, {g4,          8}, {R,  4},
};

// ...
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Музыкальный размер}

Вы могли видеть, что на нотном стане в самом начале, возле скрипичного (или
басового) ключа часто написано $\frac{4}{4}$ -- что же это означает?

Пометка $\frac{4}{4}$ (читается как ``четыре четверти'') обозначает
\emph{музыкальный размер} произведения.  С точки зрения кодирования мелодии в
программе это не влияет ни на частоту нот, ни на их длительность.  При этом,
однако, данная пометка напрямую влияет на звучание произведения, и без её учёта
все произведения будут звучать ``плоско'' и менее интересно.

Удивительный эффект музыкальный размер даёт благодаря \emph{акцентированию}
определённых нот.

Например, посмотрим ещё раз на ``Twinkle, Twinkle, Little Star''
(\ref{fig:lilypond-musical-scale-example-1}.)

\begin{figure}[ht]
  \caption{``Twinkle, Twinkle, Little Star'' в размере четыре четверти.}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      c4 c g' g
      a a g2
      f4 f e e
      d d c2
      g'4 g f f
      e e d2
      g4 g f f
      e e d2
      c4 c g' g
      a a g2
      f4 f e e
      d d c2
    }
    \layout {
      indent = 0\mm
      line-width = 100\mm
      ragged-last = ##t
    }
  \end{lilypond}
  \label{fig:lilypond-musical-scale-example-1}
\end{figure}

Поскольку композиция записана в музыкальном размере ``четыре четверти'', то в
один такт убирается ровно четыре четвёртных ноты, или суммарно единица (или одна
целая нота.)  Числитель данной дроби указывает, сколько частей -- или, по-другому
называемые \emph{долей} -- убирается в такт.  Знаменатель дроби указывает, на
какие именно доли делится такт.  В размере ``четыре четверти'' такт делится на
четыре части по одной четвертной ноте.

При игре музыкального произведения на каком-либо инструменте акцент идёт обычно
на первую ноту из такта -- на её \emph{сильную долю}.  Доли, которые не
акцентированы, называются \emph{слабыми долями}.

С точки зрения исполнения акцентированные ноты должны звучать громче, или
каким-либо другим способом выделяться в общем звучании.

Акцент нот обозначается значком ``>'' над (или под) нотой.  Если мы расставим
значки, обозначающие акцент, то получим следующую запись
(см. рис. \ref{fig:lilypond-musical-scale-example-2}.)

\begin{figure}[ht]
  \caption{``Twinkle, Twinkle, Little Star''}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 4/4
      c4-> c g'-> g
      a-> a g2->
      f4-> f e->  e
      d-> d c2->
      g'4-> g f-> f
      e-> e d2->
      g4-> g f-> f
      e-> e d2->
      c4-> c g'-> g
      a-> a g2->
      f4-> f e-> e
      d-> d c2->
    }
    \layout {
      indent = 0\mm
      line-width = 100\mm
      ragged-last = ##t
    }
  \end{lilypond}
  \label{fig:lilypond-musical-scale-example-2}
\end{figure}

Музыкальный размер ``четыре четверти'' называется \emph{сложным}, так как он
получен слиянием двух более \emph{простых} размеров, а именно ``две четверти''.

Таким образом, в размере ``четыре четверти'' кроме сильной доли, появляется
вторая доля, называемая \emph{относительно сильной}.

Как можно видеть на рис. \ref{fig:lilypond-musical-scale-example-2}, первый
(основной) акцент ставится на первую ноту в такте -- в нашем случае, первую
четверть.  Второй, второстепенный, акцент ставится на третью ноту в такте, или
же можно сказать, что на первую ноту второй половины такта (относительно сильную
долю.)  Основной акцент по определению более выраженный, чем второстепенный.

Если мы возьмём другой музыкальный размер -- например, две четверти
($\frac{2}{4}$), то произведение будет звучать по-другому, поскольку основной и
единственный акцент будет на первую ноту каждого такта, и относительно слабая
доля будет отстуствовать.

\begin{figure}[ht]
  \caption{``Twinkle, Twinkle, Little Star'' в размере две четверти.}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 2/4
      c4-> c
      g'-> g
      a-> a
      g2->
      f4-> f e->  e
      d-> d c2->
      g'4-> g f-> f
      e-> e d2->
      g4-> g f-> f
      e-> e d2->
      c4-> c g'-> g
      a-> a g2->
      f4-> f e-> e
      d-> d c2->
    }
    \layout {
      indent = 0\mm
      line-width = 100\mm
      ragged-last = ##t
    }
  \end{lilypond}
  \label{fig:lilypond-musical-scale-example-3}
\end{figure}

Музыкальный размер ``две четверти'' используется в таких стилях музыки, как
например полька.

Если мы возьмём музыкальный размер ``три четверти''
(см. рис. \ref{fig:lilypond-musical-scale-example-4}), в такт будет убираться
ровно три четвертных ноты.  Таким образом, акцент будет идти на первую четверть
из трёх в каждом такте.  При этом, некоторые ноты длиной $\frac{1}{2}$ как бы
``разрезаются'' тактовой чертой на две четверти.

\begin{figure}[ht]
  \caption{``Twinkle, Twinkle, Little Star'' в размере три четверти}
  \centering
  \begin{lilypond}
    \relative c' {
      \numericTimeSignature
      \time 3/4
      c4->  c g'
      g->   a a
      g2->  f4
      f->   e e
      d->   d c4~4->
      g'4   g
      f->   f e
      e->   d2
      g4->  g f
      f->   e e
      d2    c4
      c->   g' g
      a->   a g4~4->
      f4    f
      e->   e d
      d->   c2
    }
    \layout {
      indent = 0\mm
      line-width = 100\mm
      ragged-last = ##t
    }
  \end{lilypond}
  \label{fig:lilypond-musical-scale-example-4}
\end{figure}

Такая запись в отношении ``Twinkle, Twinkle, Little Star'' выглядит
противоестественно, и после таких экспериментов к вам в дверь может постучатся
музыкальная инквизиция.

Тем не менее, если мы сыграем в таком размере композицию музыкальном
инструменте, то она будет звучать вальсирующе, ведь музыкальнй размер ``две
четверти'' обычно используется для вальса.

Каким же образом мы можем выразить эти музыкальные нюансы в нашем программном
коде и в реализации аппаратной части, чтобы они украсили наше музыкальное
произведение?  Изменение кода включает в себя несколько этапов.

Во-первых, самым простым для нас способом выделить какие-то определённые ноты
является подключение дополнительного динамика с меньшей громкостью к Arduino.
Ноты, которые должны звучать тише, будут отправляться на него.  А те ноты,
которые должны быть акценированными, будут отправлятсья на громкий динамик.
Допустим, громкий динамик будет у нас на цифровом порту 2, а тихий динамик -- на
цифровом порту 3.

\begin{minted}{cpp}
const int LOUD_SPEAKER_PIN  = 2; // Громкий динамик.
const int QUIET_SPEAKER_PIN = 3; // Тихий динамик.

// ...

void setup() {
  pinMode(LOUD_SPEAKER_PIN, OUTPUT);
  pinMode(QUIET_SPEAKER_PIN, OUTPUT);
}
\end{minted}

Во-вторых, двумерный массив нот должен теперь иметь не два столбца, а три, так
как в третьем столбце мы как раз будем хранить громкость ноты.  Исходя из
параметра громкости, который на данный момент может иметь всего два уровня -- 0
(тихо) и 1 (громко), мы будем выбирать динамик для воспроизведения ноты.

Для размера ``четыре четверти'' мы будем первую ноту из такта делать громче
остальных.

\begin{minted}{cpp}
// ...

float twinkle_twinkle_little_star[][3] = {
  /* 0 */ {c4, 4, 1}, {c4, 4, 0}, {g4, 4, 0}, {g4, 4, 0},
  /* 1 */ {a4, 4, 1}, {a4, 4, 0}, {g4, 4, 0},
  /* 2 */ {f4, 4, 1}, {f4, 4, 0}, {e4, 4, 0}, {e4, 4, 0},
  /* 3 */ {d4, 4, 1}, {d4, 4, 0}, {c4, 4, 0},

  /* 4 */ {g4, 4, 1}, {g4, 4, 0}, {f4, 4, 0}, {f4, 4, 0},
  /* 5 */ {e4, 4, 1}, {e4, 4, 0}, {d4, 4, 0},
  /* 6 */ {g4, 4, 1}, {g4, 4, 0}, {f4, 4, 0}, {f4, 4, 0},
  /* 7 */ {e4, 4, 1}, {e4, 4, 0}, {d4, 4, 0},

  /* 4 */ {c4, 4, 1}, {c4, 4, 0}, {g4, 4, 0}, {g4, 4, 0},
  /* 5 */ {a4, 4, 1}, {a4, 4, 0}, {g4, 4, 0},
  /* 2 */ {f4, 4, 1}, {f4, 4, 0}, {e4, 4, 0}, {e4, 4, 0},
  /* 3 */ {d4, 4, 1}, {d4, 4, 0}, {c4, 4, 0},
};

// ...
\end{minted}

Далее при воспроизведении музыки нам надо выбирать нужный динамик, в
соответствии с громкостью (акцентом) ноты.

\begin{minted}{cpp}
// ...

void loop() {
  const long BPM = 120;
  const long MINUTE = 60 * 1000000;
  const long T = (MINUTE / BPM) * 4;

  for (int note_idx = 0; note_idx < 28; note_idx++) {
    if (melody[note_idx][2] == 1) {
      // Нота с акцентом
      play_tone(LOUD_SPEAKER_PIN,
                melody[note_idx][0],
                T / melody[note_idx][1]);
    } else {
      // Нота без акцента
      play_tone(QUIET_SPEAKER_PIN,
                melody[note_idx][0],
                T / melody[note_idx][1]);
    }
    delay(100);
  }
}
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Басовый ключ}

Кроме скрипичного ключа в музыке часто используется \emph{басовый ключ}.  Обычно
басовый ключ используется для тех музыкальных инструментов, у которых частотный
диапазон находится ниже, чем охватывает скрипичный ключ.

Мнемоника для басового ключа представлена на
рис. \ref{fig:lilypond-music-graph-2}.

\begin{figure}[ht]
  \caption{Мнемоника для запоминания нот басового ключа.}
  \begin{tikzpicture}
    \node (image) at (4, 2) {
      \includegraphics[width=8cm]{music-bass-clef-mnemonic}
    };
    \draw[thick, ->] (0, -1.0) -- (10, -1.0) node[anchor=north east] {x (Время)};
    \draw[thick, ->] (0, -1.0) -- (0, 4.0) node[anchor=north east] {y (Частота)};
  \end{tikzpicture}
  \label{fig:lilypond-music-graph-2}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{chapter}{Словарь терминов}
\printglossaries

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{chapter}{Приложения}
\chapter*{Приложения}

\subfile{sections/appendix-octaves}

\newpage
\section{Приложение Б}

\begin{figure}[ht]
  \caption{Мелодия ``Кабы небыло зимы'' из мультфильма ``Простоквашино''.}
  \begin{lilypond}
    \relative c' {
      \key g \major
      \numericTimeSignature
      \time 4/4
      %% 0
      (b'8 b cis dis e4-.) << g,8 b e >> r8 \bar ".|:"
      %% 1
      b,8 b b'8. fis16 a8 g e4 |
      %% 2
      d8 d << b'8. d8. >> << c16 a >> << c8 a >> << b8 g8 >> r4
      %% 3
      d'8 c a fis << a c >> << g b >> << g4 b >>
      %% 4
      b,8 b << g'8. b8. >> << fis16 a >> << fis8 a >> << e8 g8 >> r4
      %% 5
      b,8 b b'8. fis16 a8 g8 e4
      %% 6
      d8 d << b'8. d8. >> << a16 c >> << a8 c >> << g8 b8 >> r8 e4
      %% 7
%%       e8)
%%       d8 d
    }
    \layout {
      indent = 0\mm
      line-width = 120\mm
      ragged-last = ##t
    }
  \end{lilypond}
  \label{fig:lilypond-melody-prostokvashino-full}
\end{figure}

\end{document}

